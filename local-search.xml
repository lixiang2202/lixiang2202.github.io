<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【UE-C++】智能指针</title>
    <link href="/2024/12/30/link/UE/UE-C++/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2024/12/30/link/UE/UE-C++/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="【UE-C-】智能指针"><a href="#【UE-C-】智能指针" class="headerlink" title="【UE-C++】智能指针"></a>【UE-C++】智能指针</h1>]]></content>
    
    
    <categories>
      
      <category>UE</category>
      
      <category>UE-C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE</tag>
      
      <tag>UE-C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE-DS】UE网络框架</title>
    <link href="/2024/12/30/link/UE/DS/3_UE%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/3_UE%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/"/>
    <url>/2024/12/30/link/UE/DS/3_UE%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/3_UE%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="UE网络框架"><a href="#UE网络框架" class="headerlink" title="UE网络框架"></a>UE网络框架</h1><p>本篇通过分析Actor同步、属性同步和RPC流程源码，在分析过程中，对UE网络框架进行逐步的介绍，涉及到关键的概念会进行单独的详细的说明，并对序列化、ViewTarget等做详细说明。</p><blockquote><p><em>建议对照源码阅读本文，有条件的情况下，可以进行断点调试观察执行细节。(可以下载本篇内容的实例代码，<a href="https://gitee.com/lixiang2202/uedemo_ds">点击</a>查看。)</em></p></blockquote><p>在文章最后，将会对UE网络框架做完整的、总结性的介绍。</p><p>本文参考了大量网络上优秀的文章，在最后列出所有参考文章的链接，供扩展阅读。</p><h2 id="Actor同步"><a href="#Actor同步" class="headerlink" title="Actor同步"></a>Actor同步</h2><p>首先介绍一下Actor首次创建后的同步流程，从服务器端对复制Actor的收集、序列化、打包、发送再到客户端的数据接收、反序列化、Actor创建的流程来初步了解UE网络同步框架。</p><p>在服务器创建一个复制（<code>bReplicates = true</code>）Actor后，将会开始同步流程，客户端则会同步创建这个Actor，并且和服务器的Authority Actor对应起来。</p><blockquote><p><em><strong>网络同步框架的核心是 <code>UNetDriver</code>对象，该对象负责管理UNetConnections:</strong></em></p><ul><li>服务器NetDriver将维护一个NetConnects列表，每个连接代表一个连接的玩家，负责复制Actor数据</li><li>客户端NetDriver管理连接到服务器的单个连接</li></ul></blockquote><h3 id="服务器发送Actor"><a href="#服务器发送Actor" class="headerlink" title="服务器发送Actor"></a>服务器发送Actor</h3><ul><li><p><strong>UNetDriver::TickFlush</strong><br>服务器在 <code>UNetDriver::TickFlush</code>里，每一帧都会去处理同步Actor相关的处理。如果是服务器端，并且已经有连接的ClientConnections，则会执行 <code>UNetDriver::ServerReplicateActors </code></p><blockquote><p><em><strong>UNetConnections，表示每一条具体的客户端与服务器之间的连接。</strong></em></p><blockquote><p>在服务器上，每一个客户端到服务器的连接(<code>ClientConnection</code>)定义在  <code>UNetDriver::ClientConnections </code>，是一个数组。<br>在客户端上，该客户端到服务器的连接(<code>ServerConnection</code>)定义在 <code>UNetDriver::ServerConnection</code>，只有一个值。</p></blockquote></blockquote></li><li><p><strong>UNetDriver::ServerReplicateActors</strong></p><ul><li>执行 <code>ServerReplicateActors_PrepConnections</code>来获取当帧可以tick的Client数量，更新连接的ViewTarget。（会考虑是否存在有效的客户端连接，及限制每帧最多tick多少Actor等）</li><li>通过 <code>ServerReplicateActors_BuildConsiderList</code>来获取所有需要复制的Actor列表 <code>ConsiderList</code>（会考虑Actor的有效性、同步频率、休眠状态、可见性等）。</li><li>遍历所有ClientConnections，调用 <code>ServerReplicateActors_PrioritizeActors</code>来对当前ClientConnection下的所有复制Actor进行排序，然后调用 <code>ServerReplicateActors_ProcessPrioritizedActorsRange</code>去处理Actor的同步</li></ul></li><li><p><strong>UNetDriver::ServerReplicateActors_ProcessPrioritizedActorsRange</strong><br>在该方法中，遍历Actor，如果发现了新创建了需要同步的Actor，则为其创建UActorChannel。</p><blockquote><p><em><strong>UActorChannel，用于管理复制Actor的创建和生命周期，在一个连接上的数据和处理。</strong></em></p></blockquote><p>然后调用 <code>UActorChannel::ReplicateActor</code>进行Actor的复制。下述为源码的简化版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">int32 <span class="hljs-title">UNetDriver::ServerReplicateActors_ProcessPrioritizedActorsRange</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  UNetConnection* Connection, </span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-type">const</span> TArray&lt;FNetViewer&gt;&amp; ConnectionViewers, </span></span><br><span class="hljs-params"><span class="hljs-function">  FActorPriority** PriorityActors, </span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-type">const</span> TInterval&lt;int32&gt;&amp; ActorsIndexRange, </span></span><br><span class="hljs-params"><span class="hljs-function">  int32&amp; OutUpdated, <span class="hljs-type">bool</span> bIgnoreSaturation )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">for</span> ( int32 j = ActorsIndexRange.Min; j &lt; ActorsIndexRange.Min + ActorsIndexRange.Max; j++ )<br>  &#123; <span class="hljs-comment">// 遍历所有需要复制的Actor</span><br>    FNetworkObjectInfo*ActorInfo = PriorityActors[j]-&gt;ActorInfo;<br>    <span class="hljs-comment">// Normal actor replication</span><br>    UActorChannel* Channel = PriorityActors[j]-&gt;Channel;<br>    <span class="hljs-keyword">if</span> ( !Channel || Channel-&gt;Actor ) <span class="hljs-comment">//make sure didn&#x27;t just close this channel</span><br>    &#123; <br>      <span class="hljs-keyword">if</span> ( Channel == <span class="hljs-literal">NULL</span> <br>      &amp;&amp; GuidCache-&gt;<span class="hljs-built_in">SupportsObject</span>( Actor-&gt;<span class="hljs-built_in">GetClass</span>() ) <br>      &amp;&amp; GuidCache-&gt;<span class="hljs-built_in">SupportsObject</span>( Actor-&gt;<span class="hljs-built_in">IsNetStartupActor</span>() ? Actor : Actor-&gt;<span class="hljs-built_in">GetArchetype</span>() ) )<br>      &#123; <span class="hljs-comment">// 没有UActorChannel，则为其创建一个UActorChannel</span><br>        <span class="hljs-comment">// Create a new channel for this actor.</span><br>        Channel = (UActorChannel*)Connection-&gt;<span class="hljs-built_in">CreateChannelByName</span>( NAME_Actor, EChannelCreateFlags::OpenedLocally );<br>        <span class="hljs-keyword">if</span> ( Channel )<br>        &#123;<br>          Channel-&gt;<span class="hljs-built_in">SetChannelActor</span>(Actor, ESetChannelActorFlags::None);<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> ( Channel )<br>      &#123; <span class="hljs-comment">// 处理Actor复制</span><br>        <span class="hljs-keyword">if</span> ( Channel-&gt;<span class="hljs-built_in">ReplicateActor</span>() )<br>        &#123;<br>          ActorUpdatesThisConnectionSent++;<br>          ActorInfo-&gt;LastNetReplicateTime = World-&gt;TimeSeconds;<br>        &#125;<br>        ActorUpdatesThisConnection++;<br>        OutUpdated++;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ActorsIndexRange.Max;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>UActorChannel::ReplicateActor</strong><br>通过 <code>PackageMapClient::SerializeNewActor</code>对其进行序列化。</p></li><li><p><strong>PackageMapClient::SerializeNewActor</strong></p><blockquote><p><em><strong>PackageMapClient，负责UObject的序列化、反序列化以及Actor和NetworkGUID的双向映射，每一个Connection都有一个PackageMapClient对象</strong></em></p></blockquote><ul><li><p>调用 <code>UPackageMapClient::SerializeObject</code>，为其赋予一个新的 <code>NetworkGUID</code>(<code>FNetGUIDCache::GetOrAssignNetGUID</code>)，并将映射关系存到 <code>PackageMapClient</code>中。</p><blockquote><p><em><strong>NetworkGUID，网络相关的全局唯一标示符。</strong></em><br>复制的Actor在服务器、客户端都有一致的NetworkGUID，由此来进行关联</p></blockquote></li><li><p>调用 <code>UPackageMapClient::ExportNetGUID</code>，把GUID和Archetype（CDO Path）信息加入Bunch，以便让客户端解包时可以通过信息创建对象。</p><blockquote><p><em><strong>Bunch, 在CS网络连接的通道之间发送的数据。当一个连接接收到一个数据包时，该数据包将被分解成单独的Bunch，这些Bunche被传递到单独的通道以进一步处理。</strong></em><br>一个Packet可以不包含Bunch、单个Bunch或者多个Bunch。当一个Bunch太大时，在传输之前会把它切成许多小Bunch，这些Bunch将被标记为Partiallnitial、Partial或PartialFinal。利用这些信息，在接收端重新组装Bunch。</p></blockquote></li><li><p>调用 <code>FObjectReplicator::ReplicateProperties</code>进行属性复制<br><em>这部分内容比较独立且复杂，本节仅对Actor的同步做分析，属性复制的内容将在后续【属性同步】中详解。</em></p></li><li><p>序列化Actor的Location、Rotation、Scale、Velocity。<br>调用 <code>ConditionallySerializeQuantizedVector</code>和 <code>Rotation.NetSerialize</code>。</p></li></ul></li><li><p><strong>UChannel::SendBunch</strong><br>发送Bunch。在这个过程中如果Bunch过大，则会进行分割。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// This is the max number of bits we can have in a single bunch</span><br>  <span class="hljs-type">const</span> int64 MAX_SINGLE_BUNCH_SIZE_BITS  = Connection-&gt;<span class="hljs-built_in">GetMaxSingleBunchSizeBits</span>();<br>  <span class="hljs-comment">// Max bytes we&#x27;ll put in a partial bunch</span><br>  <span class="hljs-type">const</span> int64 MAX_SINGLE_BUNCH_SIZE_BYTES = MAX_SINGLE_BUNCH_SIZE_BITS / <span class="hljs-number">8</span>;<br>  <span class="hljs-comment">// Max bits will put in a partial bunch (byte aligned, we dont want to deal with partial bytes in the partial bunches)</span><br>  <span class="hljs-type">const</span> int64 MAX_PARTIAL_BUNCH_SIZE_BITS = MAX_SINGLE_BUNCH_SIZE_BYTES * <span class="hljs-number">8</span>;<br>  TArray&lt;FOutBunch*&gt;&amp; OutgoingBunches = Connection-&gt;<span class="hljs-built_in">GetOutgoingBunches</span>();<br>  OutgoingBunches.<span class="hljs-built_in">Reset</span>();<br>  <span class="hljs-keyword">if</span>( Bunch-&gt;<span class="hljs-built_in">GetNumBits</span>() &gt; MAX_SINGLE_BUNCH_SIZE_BITS )<br>  &#123;<br>  uint8 *data = Bunch-&gt;<span class="hljs-built_in">GetData</span>();<br>  int64 bitsLeft = Bunch-&gt;<span class="hljs-built_in">GetNumBits</span>();<br>  <span class="hljs-keyword">while</span>(bitsLeft &gt; <span class="hljs-number">0</span>)<br>  &#123;<br>  FOutBunch * PartialBunch = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FOutBunch</span>(<span class="hljs-keyword">this</span>, <span class="hljs-literal">false</span>);<br>  int64 bitsThisBunch = FMath::<span class="hljs-built_in">Min</span>&lt;int64&gt;(bitsLeft, MAX_PARTIAL_BUNCH_SIZE_BITS);<br>  PartialBunch-&gt;<span class="hljs-built_in">SerializeBits</span>(data, bitsThisBunch);<br>  OutgoingBunches.<span class="hljs-built_in">Add</span>(PartialBunch);<br>  bitsLeft -= bitsThisBunch;<br>  data += (bitsThisBunch &gt;&gt; <span class="hljs-number">3</span>);<br>  &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>  OutgoingBunches.<span class="hljs-built_in">Add</span>(Bunch);<br>  &#125;<br></code></pre></td></tr></table></figure><p>后续流程为：<code>UChannel::SendRawBunch</code>-&gt;<code>UNetConnection::SendRawBunch</code>，进行包头和包体的封装。并调用 <code>UNetConnection::FlushNet</code>处理数据的发送。</p></li><li><p><strong>UNetConnection::FlushNet</strong><br>刷新所有待发送的数据，将其合并到一个数据包中通过 <code>LowLevelSend</code>进行发送。最终调用到 <code>Socket::Send() </code></p></li></ul><p>调用堆栈如下：</p><h3 id="客户端接収Actor"><a href="#客户端接収Actor" class="headerlink" title="客户端接収Actor"></a>客户端接収Actor</h3><ul><li><p><strong>UIpNetDriver::TickDispatch</strong><br>客户端通过 <code>TickDispatch</code>检测服务器消息，收到消息后通过 <code>ServerConnection</code>以及 <code>Channel</code>进行解析<br>这里首先会检查是否存在 <code>ServerConnection</code>，如果不存在则尝试处理握手创建Connection(<code>UIpNetDriver::ProcessConnectionlessPacket</code>)，前提是已经允许连接服务器。</p></li><li><p><strong>UNetConnection::ReceivedRawPacket</strong><br>接收原始数据，<code>UNetConnection::DispatchPacket</code>进行数据的处理，如果没有 <code>UActorChannel</code>则创建Channel <code>UNetConnection::CreateChannelByName</code>，并调用 <code>UChannel::ReceivedRawBunch</code>，由Channl进一步处理Bunch。<br>期间调用 <code>UPackageMapClient::ReceiveNetGUIDBunch</code>来接收Object和GUID的关系。</p></li><li><p><strong>UChannel::ReceivedRawBunch</strong><br>处理、组装Bunch等一系列处理，流程是 <code>UChannel::ReceivedRawBunch</code>-&gt;<code>UChannel::ReceivedNextBunch</code>-&gt;<code>UChannel::ReceivedSequencedBunch</code>-&gt;<code>UActorChannel::ReceivedBunch</code><br>处理完Bunch信息后，调用 <code>UActorChannel::ProcessBunch</code>，进行下一步处理。</p></li><li><p><strong>UActorChannel::ProcessBunch</strong><br>如果Actor不存在，则反序列化Actor <code>UPackageMapClient::SerializeNewActor</code>，关联Channel <code>UActorChannel::SetChannelActor</code>。</p><blockquote><p><code>SerializeNewActor</code>方法在首次同步Actor的时候是一个非常重要的函数，用于Actor的序列化，后文中会专门对序列化反序列化进行详细的介绍。<br>在这里，Bunch作为一个FArchive的基类，此时我们需要解析这个Bunch，所以 <code>Ar.IsLoading() == true</code>，细节也在后续对序列化的介绍中进行说明。</p></blockquote><p>在 <code>SerializeNewActor</code>中，通过 <code>UPackageMapClient::SerializeObject</code>反序列化出来CDO，然后将Location、rotation、velocity等反序列化出来。<br>最后调用 <code>UWorld::SpawnActorAbsolute</code>将Actor创建出来并赋予位置等信息。<br>最终调用 <code>AActor::PostNetInit</code>进而执行 <code>AActor::BeginPlay</code>。</p></li></ul><p>调用堆栈如下：</p><img src="/2024/12/30/link/UE/DS/3_UE%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/3_UE%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/1735572968417.png" class="" width="1735572968417"><h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p>在上述Actor的同步过程中，<code>UPackageMapClient::SerializeNewActor</code>是一个非常重要的方法，负责了Actor的序列化和反序列化。本节重点讲述Actor的序列化。</p><h3 id="FArchive"><a href="#FArchive" class="headerlink" title="FArchive"></a>FArchive</h3><p>在了解Actor的序列化之前，需要预先熟悉UE的序列化框架。<code>class FArchive</code>是UE序列化中最重要的类，实现了对各种类型的序列化处理，是各种 <code>Archive</code>的基类。</p><p>观察 <code>FArchive</code>类，发现其实现了很多重载 <code>&lt;&lt;</code>操作符方法，通过友元(friend)，为每个需要序列化的类型实现了操作符的重载：</p><img src="/2024/12/30/link/UE/DS/3_UE%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/3_UE%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/1735743413662.png" class="" width="1735743413662"><p>这样，对任意类型的变量进行序列化，有以下写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br>FArchive Archive;<br>Archive &lt;&lt; num;<br></code></pre></td></tr></table></figure><p>下面是对int32类型的序列化方法的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">FORCEINLINE <span class="hljs-keyword">friend</span> FArchive&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(FArchive&amp; Ar, int32&amp; Value)<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEVIRTUALIZE_FLinkerLoad_Serialize</span><br>  <span class="hljs-keyword">if</span> (!Ar.<span class="hljs-built_in">FastPathLoad</span>&lt;<span class="hljs-built_in">sizeof</span>(Value)&gt;(&amp;Value))<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  &#123;<br>    Ar.<span class="hljs-built_in">ByteOrderSerialize</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;uint32&amp;&gt;(Value));<br>  &#125;<br>  <span class="hljs-keyword">return</span> Ar;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到首先将Value转换为uint32类型后，调用了 <code>FArchive::ByteOrderSerialize</code>方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">FArchive&amp; <span class="hljs-title">ByteOrderSerialize</span><span class="hljs-params">(T&amp; Value)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">static_assert</span>(!TIsSigned&lt;T&gt;::Value, <span class="hljs-string">&quot;To reduce the number of template instances, cast &#x27;Value&#x27; to a uint16&amp;, uint32&amp; or uint64&amp; prior to the call or use ByteOrderSerialize(void*, int32).&quot;</span>);<br><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsByteSwapping</span>()) <span class="hljs-comment">// Most likely case (hot path)</span><br>  &#123;<br>    <span class="hljs-built_in">Serialize</span>(&amp;Value, <span class="hljs-built_in">sizeof</span>(T));<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">SerializeByteOrderSwapped</span>(Value); <span class="hljs-comment">// Slowest and unlikely path (but fastest than SerializeByteOrderSwapped(void*, int32)).</span><br>&#125;<br></code></pre></td></tr></table></figure><p>IsByteSwapping()返回了大于1字节的字节序是否需要交换，这常用于判断本地字节序大小端模式。但无论如何最终都会调用到 <code>FArchive::Serialize()</code></p><p>在观察一个稍微复杂一些的对TArray的序列化处理（定义在Array.h，因为代码较长，做了一下精简）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ElementType, <span class="hljs-keyword">typename</span> AllocatorType&gt;<br>FArchive&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(FArchive&amp; Ar, TArray&lt;ElementType, AllocatorType&gt;&amp; A)<br>&#123;<br><span class="hljs-keyword">return</span> TArrayPrivateFriend::<span class="hljs-built_in">Serialize</span>(Ar, A);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ElementType, <span class="hljs-keyword">typename</span> AllocatorType&gt;</span><br><span class="hljs-function"><span class="hljs-type">static</span> FArchive&amp; <span class="hljs-title">Serialize</span><span class="hljs-params">(FArchive&amp; Ar, TArray&lt;ElementType, AllocatorType&gt;&amp; A)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 首先将数组大小进行序列化</span><br>  SizeType SerializeNum = Ar.<span class="hljs-built_in">IsLoading</span>() ? <span class="hljs-number">0</span> : A.ArrayNum;<br>  Ar &lt;&lt; SerializeNum;<br><br>  <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-keyword">sizeof</span>(ElementType) == <span class="hljs-number">1</span> || TCanBulkSerialize&lt;ElementType&gt;::Value)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-comment">// 如果是简单类型(int、float、char等)，则提供一个高效的方法进行序列化</span><br>    <span class="hljs-comment">// 忽略了其他分支，核心是调用Ar.Serialize方法</span><br>    Ar.<span class="hljs-built_in">Serialize</span>(A.<span class="hljs-built_in">GetData</span>(), A.<span class="hljs-built_in">Num</span>() * <span class="hljs-built_in">sizeof</span>(ElementType));<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Ar.<span class="hljs-built_in">IsLoading</span>())<br>  &#123;<br>    <span class="hljs-keyword">for</span> (SizeType i=<span class="hljs-number">0</span>; i&lt;SerializeNum; i++)<br>    &#123;<br>      Ar &lt;&lt; A.<span class="hljs-built_in">AddDefaulted_GetRef</span>(); <span class="hljs-comment">// 底层调用new一个新对象然后调用&lt;&lt;</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    A.ArrayNum = SerializeNum;<br>    <span class="hljs-keyword">for</span> (SizeType i=<span class="hljs-number">0</span>; i&lt;A.ArrayNum; i++)<br>    &#123;<br>      Ar &lt;&lt; A[i];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> Ar;<br>&#125;;<br></code></pre></td></tr></table></figure><p>简述流程就是：首先将数组大小进行序列化，然后在将遍历每个对象执行 <code>&lt;&lt;</code>操作，如果对象是简单类型，最终调用的仍然是 <code>FArchive::Serialize()</code>。<br>至此，我们发现，所有的 <code>operator&lt;&lt;</code>，都是把将要序列化的内容的起始地址和大小算法，最终调用 <code>FArchive::Serialize()</code>。而在 <code>FArchive</code>中 <code>Serialize()</code>的实现是一个空实现的虚方法。所以<strong>真正的序列化交由子类去实现，<code>FArchive</code>负责将任意数据处理抽象成为起始地址和大小。</strong>这样每个具体的FArchive不需要去考虑需要序列化对象的类型，仅处理如何序列化即可。<br>除此之外 <code>FArchive</code>还继承了 <code>FArchiveState</code>，提供了很多有用的帮助方法，如：</p><ul><li>Tell：返回当前处理到的数据为止</li><li>TotalSize: 数据流大小</li><li>AtEnd：是否已经存储到最后为止了等等</li><li>IsLoading：当前Archive是用于加载数据（读）</li><li>IsSaving：当前Archive是用于保存数据（写）<br>当然一些方法仍旧需要子类去实现。</li></ul><blockquote><p><em><code>FArchive</code>的设计思路参照了设计模式-访问者模式。</em><br><em><strong>访问者模式</strong>：封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于其内部各个元素的新操作。更多可参考：<a href="https://zhuanlan.zhihu.com/p/380161731">秒懂设计模式之访问者模式（Visitor Pattern） - 知乎</a></em><br><em><code>FArchive</code>即访问者模式中的访问者，目的是序列化别人的访问者。UE很巧妙的将访问函数设计成通过重载操作符来实现，使用了友元friend去实现每个访问者的操作符重载。操作符的参数，左边是访问者FArchive，右边是被访问者。</em></p></blockquote><p>FArchive的继承实现的非常多，拥有的功能也是五花八门，有文件系统IO的、内存统计的、网络IO的</p><p>本篇中提到的在Actor同步流程中，对网络传递的Bunch数据提供了</p><ul><li>FOutBunch：用于将数据写入网络数据包<br>继承链是：FOutBunch-&gt;FNetBitWriter-&gt;FBitWriter-&gt;FBitArchive-&gt;FArchive</li><li>FInBunch：用于从网络接收数据并进行反序列化<br>继承链是：FInBunch-&gt;FNetBitReader-&gt;FBitReader-&gt;-&gt;FBitArchive-&gt;FArchive</li></ul><blockquote><p>本篇的重点在于介绍UE网络同步框架，而FArchive的各种实现又过于庞大，好在究其源码细节，没有特别复杂的实现。感兴趣的可以自行阅读代码，对于网络序列化的核心在于FBitReader和FBitWriter中对于各种Serialize方法的重写。FNetBitWriter和FNetBitReader中对各种类型的 <code>operator&lt;&lt;</code>进行了重写，重点是实现在UPackageMap的SerializeObject方法。</p></blockquote><blockquote><p>对于FArchive的理解到此，就可以比较轻松的理解UE网络框架中对于序列化部分。但对于UE的序列化框架，还有更多细节没有探究，如常见的Archive的实现细节、对C++原生类的序列化、自定义序列化等。若读者对此十分感兴趣，可以参考<a href="https://zhuanlan.zhihu.com/p/617464719">UE 序列化介绍及源码解析 - 知乎</a>。本文不在进行深入介绍。</p></blockquote><h3 id="Actor的序列化"><a href="#Actor的序列化" class="headerlink" title="Actor的序列化"></a>Actor的序列化</h3><p>序列化出一个新的Actor分为两种，一种是静态Actor，一种是动态Actor。</p><ul><li><p><strong>静态Actor</strong><br>已经加载到地图中、或是CDO对象、或是原生对象，则是静态Actor</p><blockquote><p><code>HasAnyFlags(RF_WasLoaded | RF_DefaultSubObject) || IsNative() || IsDefaultSubobject()</code></p></blockquote><p>静态对象，序列化的过程不需要序列化三位信息，但是需要序列化其Outer和GUID和PathName。客户端需要找到该UObject绑定NetUID。（因此就通过其Outer和自身的PathName来找到该UObject)</p></li><li><p><strong>动态Actor</strong><br>理论上，不是静态Actor，就是动态Actor。</p><blockquote><p><code>bool IsDynamic() const&#123; return IsValid() &amp;&amp; !IsStatic(); &#125;</code></p></blockquote><p>动态对象通过一个ArcheType以及通过序列化一些基本的三位信息和速度信息来在客户端Spawn一个ArcheType,并赋予它一些三维信息和速度，是它和原来的Actor看起来一模一样。</p></li></ul><h3 id="SerializeNewActor"><a href="#SerializeNewActor" class="headerlink" title="SerializeNewActor"></a>SerializeNewActor</h3><p>有了上述序列化的了解后，理解 <code>SerializeNewActor</code>就简单很多了(但源码中充斥着各种细节、边界问题的处理，阅读起来依然会造成各种困扰，建议在阅读代码时，不要过于纠结细节，而是要了解UE的设计思路和整体架构即可)。下面是精简的源码，并加以注释：<br>首先，在网络同步中，这个方法分别在以下两个地方被调用：</p><ul><li><code>UActorChannel::ProcessBunch</code><br>在客户端接收到Bunch后，调用 <code>UActorChannel::ProcessBunch</code>-&gt;<code>UPackageMapClient::SerializeNewActor</code>，其中第一个参数的类型是 <code>FInBunch</code>，表示从网络接收的数据，<code>IsLoading() == true</code>。</li><li><code>UActorChannel::ReplicateActor</code><br>在服务器端，当Actor需要同步时，调用 <code>UActorChannel::ReplicateActor</code>-&gt;<code>UPackageMapClient::SerializeNewActor</code>，其中第一个参数的类型是 <code>FOutBunch</code>，表示需要发送的数据，<code>IsSaving() == true</code>。</li></ul><p>无论是序列化还是反序列化，调用的都是 <code>UPackageMapClient::SerializeObject</code>，因为输入的 <code>FArchive</code>不同，在逻辑的执行过程中，会根据 <code>FArchive</code>进行不同的处理（<code>IsLoading or IsSavig</code>）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">UPackageMapClient::SerializeNewActor</span><span class="hljs-params">(FArchive&amp; Ar, <span class="hljs-keyword">class</span> UActorChannel *Channel, <span class="hljs-keyword">class</span> AActor*&amp; Actor)</span></span><br><span class="hljs-function"></span>&#123;<br>  FNetworkGUID NetGUID; <span class="hljs-comment">// 用于存储网络GUID</span><br>  UObject *NewObj = Actor;<br>  <span class="hljs-comment">// 对于保存数据(IsSaving),调用SerializeObject为其分配一个NetWorkGUID(FNetGUIDCache::GetOrAssignNetGUID),将CDO Path加入Bunch(UPackageMapClient::ExportNetGUID)</span><br>  <span class="hljs-comment">// 对于加载数据(IsLoading),调用InternalLoadObject从Bunch中读取NetGUID(UPackageMapClient::ImportNetGUID),并尝试恢复Actor(UPackageMapClient::GetObjectFromNetGUID、StaticFindObject、FNetGUIDCache::GetObjectFromNetGUID),Actor可能是创建的(动态Actor)，也有可能是在内存中查找的(静态Actor)。</span><br>  <span class="hljs-comment">// 无论如何，接口都输出了NetGUID</span><br>  <span class="hljs-built_in">SerializeObject</span>(Ar, AActor::<span class="hljs-built_in">StaticClass</span>(), NewObj, &amp;NetGUID);<br>  <span class="hljs-comment">// 将NetGUID设置给UActorChannel</span><br>  Channel-&gt;ActorNetGUID = NetGUID;<br><br>  Actor = <span class="hljs-built_in">Cast</span>&lt;AActor&gt;(NewObj);<br><br>  <span class="hljs-comment">// 返回给调用者，表示是否是动态Actor</span><br>  <span class="hljs-type">bool</span> bActorWasSpawned = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">if</span> ( NetGUID.<span class="hljs-built_in">IsDynamic</span>() ) <span class="hljs-comment">// 动态Actor,进行额外的处理（三维数据：位置、缩放、旋转、速度）</span><br>  &#123;<br>    UObject* Archetype = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 基于CDO的一个实例</span><br>    UObject* ActorLevel = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// ULevel</span><br>    <span class="hljs-comment">// 序列化Actor的三维信息</span><br>    FVector Location = FVector::ZeroVector;<br>    FVector Scale = FVector::OneVector;<br>    FVector Velocity = FVector::ZeroVector;<br>    FRotator Rotation = FRotator::ZeroRotator;<br>    <span class="hljs-type">bool</span> SerSuccess = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">if</span> (Ar.<span class="hljs-built_in">IsSaving</span>()) <span class="hljs-comment">// 保存数据</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> (UChildActorComponent* CAC = Actor-&gt;<span class="hljs-built_in">GetParentComponent</span>())<br>      &#123; <span class="hljs-comment">// 如果是ChildActor，则需要从ChildActorTemplate中获取Archetype</span><br>        Archetype = CAC-&gt;<span class="hljs-built_in">GetSpawnableChildActorTemplate</span>();<br>      &#125;<br>      <span class="hljs-keyword">if</span> (Archetype == <span class="hljs-literal">nullptr</span>)<br>      &#123; <span class="hljs-comment">// 直接从Actor中获取Archetype</span><br>        Archetype = Actor-&gt;<span class="hljs-built_in">GetArchetype</span>();<br>      &#125;<br><br>      <span class="hljs-comment">// If enabled, send the actor&#x27;s level to the client. If left null, the client will spawn the actor in the persistent level.</span><br>      <span class="hljs-keyword">if</span> (UE::Net::Private::SerializeNewActorOverrideLevel)<br>      &#123;<br>        ActorLevel = Actor-&gt;<span class="hljs-built_in">GetLevel</span>();<br>      &#125;<br>      <span class="hljs-comment">// 以下是在获取Actor的三维信息</span><br>      <span class="hljs-type">const</span> USceneComponent* RootComponent = Actor-&gt;<span class="hljs-built_in">GetRootComponent</span>();<br><br>      <span class="hljs-keyword">if</span> (RootComponent)<br>      &#123;<br>        Location = FRepMovement::<span class="hljs-built_in">RebaseOntoZeroOrigin</span>(Actor-&gt;<span class="hljs-built_in">GetActorLocation</span>(), Actor);<br>        Rotation = Actor-&gt;<span class="hljs-built_in">GetActorRotation</span>();<br>        Scale = Actor-&gt;<span class="hljs-built_in">GetActorScale</span>();<br><br>        <span class="hljs-keyword">if</span> (USceneComponent* AttachParent = RootComponent-&gt;<span class="hljs-built_in">GetAttachParent</span>())<br>        &#123;<br>          FTransform ParentToWorld = AttachParent-&gt;<span class="hljs-built_in">GetSocketTransform</span>(RootComponent-&gt;<span class="hljs-built_in">GetAttachSocketName</span>());<br>          Scale = Scale * ParentToWorld.<span class="hljs-built_in">GetSafeScaleReciprocal</span>(ParentToWorld.<span class="hljs-built_in">GetScale3D</span>());<br>        &#125;<br>        Velocity = Actor-&gt;<span class="hljs-built_in">GetVelocity</span>();<br>      &#125;<br>    &#125;<br><br>    FNetworkGUID ArchetypeNetGUID; <span class="hljs-comment">// 用于存储Archetype的NetGUID</span><br>    <span class="hljs-built_in">SerializeObject</span>(Ar, UObject::<span class="hljs-built_in">StaticClass</span>(), Archetype, &amp;ArchetypeNetGUID);<br><br>    <span class="hljs-keyword">if</span> (Ar.<span class="hljs-built_in">IsSaving</span>() || (Connection &amp;&amp; (Connection-&gt;<span class="hljs-built_in">GetNetworkCustomVersion</span>(FEngineNetworkCustomVersion::Guid) &gt;= FEngineNetworkCustomVersion::NewActorOverrideLevel)))<br>    &#123;<br>      <span class="hljs-built_in">SerializeObject</span>(Ar, ULevel::<span class="hljs-built_in">StaticClass</span>(), ActorLevel);<br>    &#125;<br><br>    <span class="hljs-comment">// SerializeCompressedInitial</span><br>    <span class="hljs-comment">// only serialize the components that need to be serialized otherwise default them</span><br>    <span class="hljs-type">bool</span> bSerializeLocation = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">bool</span> bSerializeRotation = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">bool</span> bSerializeScale = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">bool</span> bSerializeVelocity = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 下面省略一系列判断三维信息是否有效</span><br>    &#123;<br>    <span class="hljs-comment">// 定义了一个lambda函数，用于序列化三维信息</span><br>      <span class="hljs-keyword">auto</span> ConditionallySerializeQuantizedVector = [<span class="hljs-keyword">this</span>, &amp;Ar, &amp;SerSuccess](<br>        FVector&amp; InOutValue,<br>        <span class="hljs-type">const</span> FVector&amp; DefaultValue,<br>        <span class="hljs-type">bool</span> bShouldQuantize,<br>        <span class="hljs-type">bool</span>&amp; bWasSerialized)<br>      &#123;<br>        <span class="hljs-comment">// 省略细节，核心是</span><br>        <span class="hljs-comment">// Ar.SerializeBits</span><br>        <span class="hljs-comment">// FVector_NetQuantize10::NetSerialize()</span><br>        <span class="hljs-comment">// Ar &lt;&lt; InOutValue</span><br>      &#125;;<br>      <span class="hljs-comment">// 位置的序列化</span><br>      <span class="hljs-built_in">ConditionallySerializeQuantizedVector</span>(Location, FVector::ZeroVector,  GbQuantizeActorLocationOnSpawn, bSerializeLocation);<br>      <span class="hljs-comment">// 旋转的序列化</span><br>      Ar.<span class="hljs-built_in">SerializeBits</span>(&amp;bSerializeRotation, <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">if</span> (bSerializeRotation)<br>      &#123;<br>        <span class="hljs-keyword">if</span> (GbQuantizeActorRotationOnSpawn)<br>        &#123;<br>          Rotation.<span class="hljs-built_in">NetSerialize</span>(Ar, <span class="hljs-keyword">this</span>, SerSuccess);<br>        &#125; <br>        <span class="hljs-keyword">else</span><br>        &#123;<br>          Ar &lt;&lt; Rotation;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        Rotation = FRotator::ZeroRotator;<br>      &#125;<br>      <span class="hljs-comment">// 缩放的序列化</span><br>      <span class="hljs-built_in">ConditionallySerializeQuantizedVector</span>(Scale, FVector::OneVector, GbQuantizeActorScaleOnSpawn, bSerializeScale);<br>      <span class="hljs-comment">// 速度的序列化</span><br>      <span class="hljs-built_in">ConditionallySerializeQuantizedVector</span>(Velocity, FVector::ZeroVector, GbQuantizeActorVelocityOnSpawn, bSerializeVelocity);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> ( Ar.<span class="hljs-built_in">IsLoading</span>() ) <span class="hljs-comment">// 加载数据</span><br>    &#123;<br>      <span class="hljs-comment">// 如果没有找到Actor，则创建Actor并设置其三维信息</span><br>      <span class="hljs-keyword">if</span> ( Actor == <span class="hljs-literal">NULL</span> )<br>      &#123;<br>        <span class="hljs-keyword">if</span> ( Archetype )<br>        &#123;<br>          ULevel* SpawnLevel = <span class="hljs-built_in">Cast</span>&lt;ULevel&gt;(ActorLevel);<br>          <span class="hljs-keyword">if</span> (SpawnLevel == <span class="hljs-literal">nullptr</span> || SpawnLevel-&gt;<span class="hljs-built_in">GetWorld</span>() != <span class="hljs-literal">nullptr</span>)<br>          &#123;<br>            <span class="hljs-comment">// 生成Spawn信息</span><br>            FActorSpawnParameters SpawnInfo;<br>            SpawnInfo.Template = <span class="hljs-built_in">Cast</span>&lt;AActor&gt;(Archetype);<br>            SpawnInfo.OverrideLevel = SpawnLevel;<br>            SpawnInfo.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;<br>            SpawnInfo.bRemoteOwned = <span class="hljs-literal">true</span>;<br>            SpawnInfo.bNoFail = <span class="hljs-literal">true</span>;<br><br>            UWorld* World = Connection-&gt;Driver-&gt;<span class="hljs-built_in">GetWorld</span>();<br>            FVector SpawnLocation = FRepMovement::<span class="hljs-built_in">RebaseOntoLocalOrigin</span>(Location, World-&gt;OriginLocation);<br>            <span class="hljs-comment">// 创建Actor</span><br>            Actor = World-&gt;<span class="hljs-built_in">SpawnActorAbsolute</span>(Archetype-&gt;<span class="hljs-built_in">GetClass</span>(), <span class="hljs-built_in">FTransform</span>(Rotation, SpawnLocation), SpawnInfo);<br>            <span class="hljs-keyword">if</span> (Actor)<br>            &#123;<br>              <span class="hljs-comment">// Velocity was serialized by the server</span><br>              <span class="hljs-keyword">if</span> (bSerializeVelocity)<br>              &#123;<br>                Actor-&gt;<span class="hljs-built_in">PostNetReceiveVelocity</span>(Velocity);<br>              &#125;<br><br>              <span class="hljs-comment">// Scale was serialized by the server</span><br>              <span class="hljs-keyword">if</span> (bSerializeScale)<br>              &#123;<br>                Actor-&gt;<span class="hljs-built_in">SetActorRelativeScale3D</span>(Scale);<br>              &#125;<br><br>              GuidCache-&gt;<span class="hljs-built_in">RegisterNetGUID_Client</span>(NetGUID, Actor);<br>              bActorWasSpawned = <span class="hljs-literal">true</span>;<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> bActorWasSpawned;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="属性同步"><a href="#属性同步" class="headerlink" title="属性同步"></a>属性同步</h2><p>了解了Actor的同步后，再来看属性同步。在梳理流程先，首先明确几个核心的类：</p><ul><li>FRepLayout</li><li>FRepState</li><li>FReplicationChangelistMgr</li><li>FObjectReplicator</li></ul><h3 id="服务器发送属性变化"><a href="#服务器发送属性变化" class="headerlink" title="服务器发送属性变化"></a>服务器发送属性变化</h3><ul><li><code>UNetDriver::TickFlush</code>中调用<code>ServerReplicateActors</code>，遍历所有ClientConnection，计算Actor相关性，不相关的不同步，相关的则进入<code>FObjectReplicator::ReplicateProperties</code>函数</li><li><code>FObjectReplicator::ReplicateProperties</code>比较属性和发送同步数据<blockquote><p><em><strong>FObjectReplicator:属性同步真正执行的类，负责属性比较，属性发送，属性接收</strong></em>，其内部维护了&#96;FRepLayout、RepState指针、ActorChannel指针、FReplicationChangeListMgr指针。</p></blockquote><a href="https://zhuanlan.zhihu.com/p/640723352">https://zhuanlan.zhihu.com/p/640723352</a></li></ul><h3 id="客户端接收属性变化"><a href="#客户端接收属性变化" class="headerlink" title="客户端接收属性变化"></a>客户端接收属性变化</h3><h2 id="RPC原理"><a href="#RPC原理" class="headerlink" title="RPC原理"></a>RPC原理</h2><h2 id="关键流程"><a href="#关键流程" class="headerlink" title="关键流程"></a>关键流程</h2><h3 id="Channel关联Actor"><a href="#Channel关联Actor" class="headerlink" title="Channel关联Actor"></a>Channel关联Actor</h3><p><a href="https://zhuanlan.zhihu.com/p/533713823">UE4网络同步-Actor同步流程详解 - 知乎</a></p><h3 id="ViewTarget"><a href="#ViewTarget" class="headerlink" title="ViewTarget"></a>ViewTarget</h3><h2 id="网络同步框架"><a href="#网络同步框架" class="headerlink" title="网络同步框架"></a>网络同步框架</h2><h3 id="核心类图"><a href="#核心类图" class="headerlink" title="核心类图"></a>核心类图</h3><img src="/2024/12/30/link/UE/DS/3_UE%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/3_UE%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%9B%BE.dio.png" class="" title="核心类图"><ul><li>NetDriver<br>网络处理的核心，负责管理UNetConnections。<br>服务器NetDriver将维护一个NetConnects列表，每个连接代表一个连接的玩家，负责复制Actor数据<br>客户端NetDriver管理连接到服务器的单个连接</li><li>NetConnection<br>在服务器和客户端上，NetDriver负责接收来自网络的数据包并将这些数据包传递给适当的NetConnection</li><li>Packet<br>在CS网络连接之间发送的数据，由Packet包的元数据和Bunches组成</li><li>Bunche<br>在CS网络连接的通道之间发送的数据。当一个连接接收到一个数据包时，该数据包将被分解乘单独的Bunch，这些Bunche被传递到单独的通道以进一步处理。<br>一个Packet可以不包含Bunch、单个Bunch或者多个Bunch。当一个Bunch太大时，在传输之前会把它切成许多小Bunch，这些Bunch将被标记为Partiallnitial、Partial或PartialFinal。利用这些信息，在接收端重新组装Bunch。</li></ul><p><a href="https://zhuanlan.zhihu.com/p/533713823">UE4网络同步-Actor同步流程详解 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/533738684">UE4网络同步-RPC流程详解 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/533748683">UE4网络同步-客户端连接DS的流程 - 知乎</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/640723352">UE4 网络同步框架源码解析 - 知乎</a><br><a href="https://zhuanlan.zhihu.com/p/617464719">UE 序列化介绍及源码解析 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/532800522">UE4网络同步-基础流程 - 知乎</a><br><a href="https://zhuanlan.zhihu.com/p/682972215">UE4 属性同步(一)-同步前的准备 - 知乎</a><br><a href="https://zhuanlan.zhihu.com/p/683938349">UE4 属性同步(二) - 属性对比 - 知乎</a><br><a href="https://zhuanlan.zhihu.com/p/685266581">UE4 属性同步(三) - 属性同步发送 - 知乎</a><br><a href="https://zhuanlan.zhihu.com/p/687813320">UE4 属性同步(四) - 属性同步接收 - 知乎</a><br><a href="https://zhuanlan.zhihu.com/p/678112760">UE4 浅谈网络同步中的RPC - 知乎</a><br><a href="https://zhuanlan.zhihu.com/p/533738684">UE4网络同步-RPC流程详解 - 知乎</a><br><a href="https://zhuanlan.zhihu.com/p/245358090">[UE4 Network] RPC 之哪里调用 和 哪里执行 - 知乎</a><br><a href="https://zhuanlan.zhihu.com/p/187254524">[UE4 Network] RPC 调用的一些细节 - 知乎</a><br><a href="https://zhuanlan.zhihu.com/p/56548096">UE4网络同步思考（一）—经典同步方案 - 知乎</a><br><a href="https://zhuanlan.zhihu.com/p/56922476">UE4网络同步思考（二）—大世界同步方案ReplicationGraph - 知乎</a><br><a href="https://zhuanlan.zhihu.com/p/34723199">《Exploring in UE4》网络同步原理深入（上）[原理分析] - 知乎</a><br><a href="https://zhuanlan.zhihu.com/p/55596030">《Exploring in UE4》网络同步原理深入（下）[原理分析] - 知乎</a><br><a href="https://zhuanlan.zhihu.com/p/34721113">《Exploring in UE4》关于网络同步的理解与思考[概念理解] - 知乎</a><br><a href="https://blog.csdn.net/qq_48223371/article/details/143139048">虚幻引擎DS服务器(专用服务器)初步搭建及简单数据同步应用(二)_虚幻分布式服务器-CSDN博客</a><br><a href="https://blog.uwa4d.com/archives/USparkle_Exploring.html">《Exploring in UE4》网络同步原理深入（上） - UWA问答 | 博客 | 游戏及VR应用性能优化记录分享 | 侑虎科技</a></p><p><a href="https://zhuanlan.zhihu.com/p/426563588">UE4的RPC调用过程刨析与指针参数C++网络同步解读 - 知乎</a></p>]]></content>
    
    
    <categories>
      
      <category>UE</category>
      
      <category>UE多人游戏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE</tag>
      
      <tag>Dedicated Server</tag>
      
      <tag>网络开发</tag>
      
      <tag>Actor复制</tag>
      
      <tag>RPC</tag>
      
      <tag>UE源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE-DS】编写多人游戏</title>
    <link href="/2024/12/29/link/UE/DS/2_%E7%BC%96%E5%86%99%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/2_%E7%BC%96%E5%86%99%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/"/>
    <url>/2024/12/29/link/UE/DS/2_%E7%BC%96%E5%86%99%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/2_%E7%BC%96%E5%86%99%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="编写多人游戏-基础篇"><a href="#编写多人游戏-基础篇" class="headerlink" title="编写多人游戏-基础篇"></a>编写多人游戏-基础篇</h1><blockquote><p>网络上UE网络同步开发相关资料非常多，本篇结合官方文档和网络上的优秀文章对UE多人游戏开发做一个相对全面的介绍。在文章最后，有列出所有的参考资料。</p></blockquote><p>在UE中，多人游戏与单人游戏的唯一不同是网络同步相关的Actor在服务器和客户端各有一份，服务器端是主控，客户端一般是服务器的Actor的副本，一般有两种：Autonomous（客户端对其有操控权，如客户端所操控的Pawn）；Simulated（纯副本，客户端无操控权，如其他客户端所操控的Pawn）。</p><p>UE的网络框架，基于CS架构（客户端-服务器），重要的决策由服务器端来做，这套框架的重点有两点：</p><ul><li>把游戏世界中，需要同步的内容同步到每个客户端。如玩家的位置、属性、状态等。其实就是变化的Actor向客户端发送相关的信息，让Actor保持最新状态，即<strong>Actor属性同步</strong>。</li><li>做重要的决策，如游戏的开始结束、子弹的生成、位置更新等。其实就是客户端在做某些事情的适合，需要能够请求服务器去执行一些方法，然后客户端根据结果去决定客户端的表现，UE为此机制提供了<strong>远程函数调用</strong>机制，即<strong>RPC</strong>。</li></ul><h2 id="Actor所有者和所属连接"><a href="#Actor所有者和所属连接" class="headerlink" title="Actor所有者和所属连接"></a>Actor所有者和所属连接</h2><p>UE的多人游戏采用客户端-服务器模型。客户端链接到服务器时，在服务器上创建玩家控制器。这里衍生出两个概念：<strong>所有者(Actor Owner)<strong>和</strong>所属连接(Owning Connection)</strong><br>当客户端在服务器上运行时，玩家控制器将拥有一个Pawn，供客户端在游戏中控制：</p><ul><li>玩家控制器是Pawn的<strong>所有者</strong></li><li>Actor的<strong>所属连接</strong>将确定哪个连接的客户端有权做出更改和远程调用。</li></ul><blockquote><p><em>本篇文章提到的<strong>服务器</strong>指的是<strong>DedicatedServer</strong>或<strong>ListenServer</strong>，后文不在赘述</em></p></blockquote><p>这对<strong>Actor复制</strong>、<strong>属性复制</strong>、<strong>RPC</strong>来说很重要。</p><img src="/2024/12/29/link/UE/DS/2_%E7%BC%96%E5%86%99%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/2_%E7%BC%96%E5%86%99%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/ActorOwnerAndOwningActor.dio.png" class="" title="ActorOwnerAndOwningActor"><p>如上图所示，在客户端1上，你的输入将在 <code>PlayerController1</code>中处理，然后传达给 <code>Pawn1</code>。<br>当客户端1连接到服务器时，在服务器上会建立网络连接 <code>NetConnection1</code>并创建 <code>PlayerControllorS1</code>。<code>PawnS1</code>由 <code>PlayerControllerS1</code>拥有。<code>PawnS1</code>的所属连接是 <code>NetConnection1</code>，这是 <code>PlayerControllerS1</code>的所属连接。</p><h2 id="网络模式和身份"><a href="#网络模式和身份" class="headerlink" title="网络模式和身份"></a>网络模式和身份</h2><h3 id="游戏运行模式"><a href="#游戏运行模式" class="headerlink" title="游戏运行模式"></a>游戏运行模式</h3><p>在编辑器中，通常有三种模式运行：</p><img src="/2024/12/29/link/UE/DS/2_%E7%BC%96%E5%86%99%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/2_%E7%BC%96%E5%86%99%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/1734535616615.png" class="" width="1734535616615"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// LevelEditorPlaySettings.h</span><br><span class="hljs-built_in">UENUM</span>()<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">EPlayNetMode</span> : <span class="hljs-type">int</span><br>&#123;<br><span class="hljs-function">PIE_Standalone <span class="hljs-title">UMETA</span><span class="hljs-params">(DisplayName=<span class="hljs-string">&quot;Play Standalone&quot;</span>)</span>,</span><br><span class="hljs-function">PIE_ListenServer <span class="hljs-title">UMETA</span><span class="hljs-params">(DisplayName=<span class="hljs-string">&quot;Play As Listen Server&quot;</span>)</span>,</span><br><span class="hljs-function">PIE_Client <span class="hljs-title">UMETA</span><span class="hljs-params">(DisplayName=<span class="hljs-string">&quot;Play As Client&quot;</span>)</span>,</span><br><span class="hljs-function">&#125;</span>;<br></code></pre></td></tr></table></figure><ul><li><p>PIE_Standalone<br>将启动一个独立进程游戏。此操作不会创建专用服务器，也不会自动连接到一个服务器。也就是说启动一个单机游戏。<br>打开 <code>bLaunchSeparateServer</code>选项，则可以创建Server。客户端需要主动连接Server。</p><img src="/2024/12/29/link/UE/DS/2_%E7%BC%96%E5%86%99%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/2_%E7%BC%96%E5%86%99%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/1735055074459.png" class="" width="1735055074459"></li><li><p>PIE_Client<br>编辑器将用作客户端，打开界面是一个客户端，跑的是客户端代码。当设置多玩家时，多个窗口代表多个客户端。同时UE还会启动一个Server。这个Server是否与编辑器处于同一进程，由 <code>RunUnderOneProcess</code>设置控制。</p><p>如果勾选该设置，Server会在UE进程下，否则Server会单独启一个进程来创建。<br>这个模式下，启动的Client会自动连接Server</p><blockquote><p>勾选 <code>RunUnderOneProcess</code>选项，则client和server在同一个进程下，在断点时会断到客户端和服务器的代码，即使使用的是PIE_Client模式。可能会产生一些BUG，比如一些全局的对象或单例在Client和Server在同一进程下的情况。</p></blockquote></li><li><p>PIE_ListenServer<br>编辑器将同时用作服务器和客户端。基于客户端数量，可打开超出的额外实例。设置多玩家的时候，多个窗口还是代表多个Client，但是由一个窗口的实例下，会生成Server。</p></li></ul><h3 id="网络身份"><a href="#网络身份" class="headerlink" title="网络身份"></a>网络身份</h3><p>同步是基于Actor的，在网络同步的过程中，需要知道每个Actor的<strong>网络身份</strong>。Actor是服务器独有的、客户端独有、是否同步、同步的Actor是服务器的还是客户端的还是客户端拥有控制权的…</p><p>Actor有两个重要的属性：<code>Role</code>和 <code>RemoteRole</code>。有了这两个属性，你可以明确此Actor的<strong>网络身份</strong>。</p><p>这两个属性定义在 <code>Actor.h</code>中，类型为 <code>ENetRole</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Actor.h</span><br><span class="hljs-comment">/** Describes how much control the local machine has over the actor. */</span><br><span class="hljs-built_in">UPROPERTY</span>(Replicated, VisibleInstanceOnly, Category=Networking)<br>TEnumAsByte&lt;<span class="hljs-keyword">enum</span> <span class="hljs-title class_">ENetRole</span>&gt; Role;<br><br><span class="hljs-comment">/** Describes how much control the remote machine has over the actor. */</span><br><span class="hljs-built_in">UPROPERTY</span>(Replicated, Transient, VisibleInstanceOnly, Category=Networking)<br>TEnumAsByte&lt;<span class="hljs-keyword">enum</span> <span class="hljs-title class_">ENetRole</span>&gt; RemoteRole;<br><br><span class="hljs-comment">// EngineType.h</span><br><span class="hljs-comment">/** The network role of an actor on a local/remote network context */</span><br><span class="hljs-built_in">UENUM</span>(BlueprintType)<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">ENetRole</span> : <span class="hljs-type">int</span><br>&#123;<br><span class="hljs-function">ROLE_None <span class="hljs-title">UMETA</span><span class="hljs-params">(DisplayName = <span class="hljs-string">&quot;None&quot;</span>)</span>,</span><br><span class="hljs-function">ROLE_SimulatedProxy <span class="hljs-title">UMETA</span><span class="hljs-params">(DisplayName = <span class="hljs-string">&quot;Simulated Proxy&quot;</span>)</span>,</span><br><span class="hljs-function">ROLE_AutonomousProxy <span class="hljs-title">UMETA</span><span class="hljs-params">(DisplayName = <span class="hljs-string">&quot;Autonomous Proxy&quot;</span>)</span>,</span><br><span class="hljs-function">ROLE_Authority <span class="hljs-title">UMETA</span><span class="hljs-params">(DisplayName = <span class="hljs-string">&quot;Authority&quot;</span>)</span>,</span><br><span class="hljs-function">ROLE_MAX <span class="hljs-title">UMETA</span><span class="hljs-params">(Hidden)</span>,</span><br><span class="hljs-function">&#125;</span>;<br></code></pre></td></tr></table></figure><p>可以通过 <code>GetLocalRole</code>获取自身的网络身份，通过 <code>GetRemoteRole</code>去获取远端的自身的网络身份。</p><ul><li><strong>ROLE_Authority</strong><br>代表具有<strong>主控权</strong>，在服务器生成的Actor的Role就是ROLE_Authority。<blockquote><p><em>注意：客户端生成的Role也是ROLE_Authority</em></p></blockquote></li><li><strong>ROLE_AutonomousProxy</strong><br>代表服务器同步下来的Actor，并由客户端主控，一般是本客户端PlayerController所有用的Actor（一般是Pawn）。这些Actor是可以操作和预表现的，但是要经过服务器的校验和纠错。<blockquote><p><em>比如玩家操作的角色，其实是生成在服务器同步下来的，但是客户端具有操控权。比如6v6的游戏，服务器会有12个角色生成，每个客户端也会有12个角色，但是每个客户端只对自己的角色具有操控权，也就是<strong>ROLE_AutonomousProxy</strong>，其他11个客户端是没有操控权的，其实也就是<strong>ROLE_SimulatedProxy</strong></em></p></blockquote></li><li><strong>ROLE_SimulatedProxy</strong><br>客户端模拟，代表从服务器同步下来的Actor，并且客户端无操控权。</li></ul><p>各种情况下有如下区分：</p><ul><li><strong>服务器生成的同步Actor</strong><br>Role &#x3D;&#x3D; ROLE_Authority<br>RemoteRole取决于是否有主控客户端，如果有就是ROLE_AutonomousProxy，没有就是ROLE_SimulatedProxy。</li><li><strong>服务器上生成的同步Actor在客户端上的对象</strong><br>有操控权的，Role &#x3D;&#x3D; ROLE_AutonomousProxy，RemoteRole &#x3D;&#x3D; ROLE_Authority<br>没有操控权，Role &#x3D;&#x3D; ROLE_SimulatedProxy &#x3D;&#x3D; ROLE_Authority</li><li><strong>服务器上生成的非同步Actor</strong><br>Role &#x3D;&#x3D; ROLE_Authority，RemoteRole &#x3D;&#x3D; ROLE_None</li><li><strong>客户端上生成的Actor</strong><br>Role &#x3D;&#x3D; ROLE_Authority，RemoteRole &#x3D;&#x3D; ROLE_None</li></ul><p><code>HasAuthority</code>接口判断了Role是否是ROLE_Authority，实际上不能准确判断是不是服务器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">AActor::HasAuthority</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">GetLocalRole</span>() == ROLE_Authority);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="NetMode"><a href="#NetMode" class="headerlink" title="NetMode"></a>NetMode</h3><p>可以通过调用 <code>ENetMode GetNetMode()</code>来判断当前Actor所处的网络模式，就是说通过该接口，可以准确判断是不是服务器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Actor.h</span><br><span class="hljs-function">ENetMode <span class="hljs-title">AActor::GetNetMode</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// IsRunningDedicatedServer() is a compile-time check in optimized non-editor builds.</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsRunningDedicatedServer</span>()<br>   &amp;&amp; (NetDriverName == NAME_None || NetDriverName == NAME_GameNetDriver))<br>&#123;<br><span class="hljs-comment">// Only normal net driver actors can have this optimization</span><br><span class="hljs-keyword">return</span> NM_DedicatedServer;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">InternalGetNetMode</span>();<br>&#125;<br><span class="hljs-comment">// EngineBaseTypes.h</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">ENetMode</span><br>&#123;<br>    NM_Standalone,<br>    NM_DedicatedServer,<br>    NM_ListenServer,<br>    NM_Client,<br>    NM_MAX,<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>NM_Standalone</strong><br>单机模式（无联网游戏），跑客户端和服务器的所有逻辑，不接受其他客户端连接</li><li><strong>NM_DedicatedServer</strong><br>专用服务器，只跑服务器逻辑，可以接受其他客户端的连接</li><li><strong>NM_ListenServer</strong><br>监听服务器，跑客户端和服务器的所有逻辑，可以接受其他客户端的连接</li><li><strong>NM_Client</strong><br>客户端模式，只跑客户端逻辑，连接其他服务器</li></ul><p><code>AController::IsLocalController()</code>接口结合NetMode、Role和RemoteRole来判断是否是本地控制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">AController::IsLocalController</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> ENetMode NetMode = <span class="hljs-built_in">GetNetMode</span>();<br><span class="hljs-keyword">if</span> (NetMode == NM_Standalone)<br>&#123;<br><span class="hljs-comment">// 单机</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (NetMode == NM_Client &amp;&amp; <span class="hljs-built_in">GetLocalRole</span>() == ROLE_AutonomousProxy)<br>&#123;<br><span class="hljs-comment">// 客户端模式，并且连接了服务器，同时角色时有自治权的</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetRemoteRole</span>() != ROLE_AutonomousProxy &amp;&amp; <span class="hljs-built_in">GetLocalRole</span>() == ROLE_Authority)<br>&#123;<br><span class="hljs-comment">// 服务器上的Actor</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Pawn中也有 <code>APawn::IsLocallyControlled</code>的封装：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">APawn::IsLocallyControlled</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> ( Controller &amp;&amp; Controller-&gt;<span class="hljs-built_in">IsLocalController</span>() );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="复制模式"><a href="#复制模式" class="headerlink" title="复制模式"></a>复制模式</h2><p>服务器不会在每次更新时复制Actor（实际上，服务器会按照 <code>AActor::NetUpdateFrequency</code>属性指定的频率来复制Actor。<br><em><strong>注：只有服务器复制到客户端，没有客户端复制到服务器！</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/** How often (per second) this actor will be considered for replication, used to determine NetUpdateTime */</span><br><span class="hljs-built_in">UPROPERTY</span>(Category=Replication)<br><span class="hljs-type">float</span> NetUpdateFrequency;<br><br><span class="hljs-comment">/** Used to determine what rate to throttle down to when replicated properties are changing infrequently */</span><br><span class="hljs-built_in">UPROPERTY</span>(Category=Replication)<br><span class="hljs-type">float</span> MinNetUpdateFrequency;<br></code></pre></td></tr></table></figure><p>客户端将在更新间歇中模拟actor，目前共有两种类型的模拟：</p><ul><li>ROLE_SimulatedProxy<br>通常是根据上次获得的速率对移动进行推算，当服务器更新时，客户端将向着新的方向调整其位置。</li><li>ROLE_AutonomousProxy<br>这种模拟通常只用于PlayerController所拥有的actor，此actor拥有更多的信息用于推送。如使用真人输入的速度来进行推算，而不是根据上次获得的速率。</li></ul><h2 id="网络休眠"><a href="#网络休眠" class="headerlink" title="网络休眠"></a>网络休眠</h2><p>服务器在收集网络同步时，会遍历大量的Actor及其属性，实际上一些Actor不会很频繁参与复制，UE提供了Actor网络休眠机制，可以减少不必要的遍历，优化性能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// EngineTypes.h</span><br><span class="hljs-built_in">UENUM</span>(BlueprintType)<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">ENetDormancy</span> : <span class="hljs-type">int</span><br>&#123;<br><span class="hljs-comment">/** 网络休眠，不参与复制 */</span><br><span class="hljs-function">DORM_Never <span class="hljs-title">UMETA</span><span class="hljs-params">(DisplayName = <span class="hljs-string">&quot;Never&quot;</span>)</span>,</span><br><span class="hljs-function"><span class="hljs-comment">/** 不会休眠，参与复制 */</span></span><br><span class="hljs-function">DORM_Awake <span class="hljs-title">UMETA</span><span class="hljs-params">(DisplayName = <span class="hljs-string">&quot;Awake&quot;</span>)</span>,</span><br><span class="hljs-function"><span class="hljs-comment">/** 对所有连接休眠 */</span></span><br><span class="hljs-function">DORM_DormantAll <span class="hljs-title">UMETA</span><span class="hljs-params">(DisplayName = <span class="hljs-string">&quot;Dormant All&quot;</span>)</span>,</span><br><span class="hljs-function"><span class="hljs-comment">/** 对一些连接休眠，可以通过GetNetDormancy()来判断，这个选项将要废弃 */</span></span><br><span class="hljs-function">DORM_DormantPartial <span class="hljs-title">UMETA</span><span class="hljs-params">(DisplayName = <span class="hljs-string">&quot;Dormant Partial&quot;</span>)</span>,</span><br><span class="hljs-function"><span class="hljs-comment">/** 在场景中的物体，默认参与复制 */</span></span><br><span class="hljs-function">DORM_Initial <span class="hljs-title">UMETA</span><span class="hljs-params">(DisplayName = <span class="hljs-string">&quot;Initial&quot;</span>)</span>,</span><br><span class="hljs-function">DORM_MAX <span class="hljs-title">UMETA</span><span class="hljs-params">(Hidden)</span>,</span><br><span class="hljs-function">&#125;</span>;<br><span class="hljs-comment">// Actor.h</span><br><span class="hljs-built_in">UPROPERTY</span>(BlueprintReadOnly, EditDefaultsOnly, Category=Replication)<br>TEnumAsByte&lt;<span class="hljs-keyword">enum</span> <span class="hljs-title class_">ENetDormancy</span>&gt; NetDormancy;<br><span class="hljs-comment">/** 强制复制一次，不改变休眠状态*/</span><br><span class="hljs-built_in">UFUNCTION</span>(BlueprintAuthorityOnly, BlueprintCallable, Category=<span class="hljs-string">&quot;Networking&quot;</span>)<br><span class="hljs-function">ENGINE_API <span class="hljs-type">void</span> <span class="hljs-title">FlushNetDormancy</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">/** 强制更新NetDriver */</span><br><span class="hljs-built_in">UFUNCTION</span>( BlueprintCallable, Category=<span class="hljs-string">&quot;Networking&quot;</span>)<br><span class="hljs-function">ENGINE_API <span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ForceNetUpdate</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><h2 id="Actor相关性"><a href="#Actor相关性" class="headerlink" title="Actor相关性"></a>Actor相关性</h2><p>被服务器认为能够对客户端产生重大影响的Actor组会被视为与客户端的<strong>相关</strong>。一般默认为基于距离的相关性。可以通过 <code>AActor::ForceNetRelevant</code>强制指定相关性。</p><p>详情可参见：<a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/actor-relevancy-in-unreal-engine?application_version=5.5">虚幻引擎中的Actor相关性 | 虚幻引擎 5.5 文档 | Epic Developer Community</a></p><h2 id="Actor优先级"><a href="#Actor优先级" class="headerlink" title="Actor优先级"></a>Actor优先级</h2><p>在网络复制的过程中，当网络连接进入饱满状态，UE的复制系统会使用一种负载均衡技术，为所有Actor分配一个数字优先级 <code>AActor::NetPriority</code>。Actor的相对优先级越高，会获得更多的带宽进行复制（这里可以理解复制频率更高一些）。以下是常见类使用的初始值：</p><ul><li>AActor:1.0</li><li>APawn:2.0</li><li>APlayerController:3.0</li></ul><blockquote><p>可以重载 <code>AActor::GetNetPriority</code>来自定义Actor优先级。<br>这个方法默认是为了基于与观看者间的距离、观看者的视线以及自上次复制当前Actor以来的时间，计算 <code>AActor::NetPriority</code>的乘法因子。</p></blockquote><h2 id="RPC及使用"><a href="#RPC及使用" class="headerlink" title="RPC及使用"></a>RPC及使用</h2><p>RPC（远程过程调用）是在本地调用但在其他及其上远程执行的函数。</p><p>要将一个函数声明为RPC，需要将 <code>Server</code>、<code>Client</code>或 <code>NetMulticast</code>关键字添加到UFUNCTION声明中。RPC函数默认是不可靠的，可以指定 <code>Reliable</code>关键字使其必然会被执行。</p><p>三种RPC的声明方式根据Actor的所有权不同，决定了RPC将在哪里执行，如下表：</p><img src="/2024/12/29/link/UE/DS/2_%E7%BC%96%E5%86%99%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/2_%E7%BC%96%E5%86%99%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/1734881609543.png" class="" width="1734881609543"><blockquote><p>以下例子是基于第一篇文章的Demo(<a href="https://gitee.com/lixiang2202/uedemo_ds">lixiang2202&#x2F;UEDemo_DS</a>)进行扩展<br>下述代码在 <code>AUEDemo_DSCharacter</code>类中实现了三个RPC接口，其实现是打印了参数Tag：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// UEDemo_DSCharacter.h</span><br><span class="hljs-built_in">UFUNCTION</span>(Server, Reliable)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ServerTestRPC</span><span class="hljs-params">(<span class="hljs-type">const</span> FName&amp; Tag)</span></span>;<br><span class="hljs-built_in">UFUNCTION</span>(Client, Reliable)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientTestRPC</span><span class="hljs-params">(<span class="hljs-type">const</span> FName&amp; Tag)</span></span>;<br><span class="hljs-built_in">UFUNCTION</span>(NetMulticast, Reliable)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MulticastTestRPC</span><span class="hljs-params">(<span class="hljs-type">const</span> FName&amp; Tag)</span></span>;<br><span class="hljs-comment">// UEDemo_DSCharacter.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AUEDemo_DSCharacter::ServerTestRPC_Implementation</span><span class="hljs-params">(<span class="hljs-type">const</span> FName&amp; Tag)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">LOG_BLUE</span>(<span class="hljs-string">&quot;ServerTestRPC called on %s. Tag: %s&quot;</span>, *<span class="hljs-built_in">GetName</span>(), *Tag.<span class="hljs-built_in">ToString</span>());<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AUEDemo_DSCharacter::ClientTestRPC_Implementation</span><span class="hljs-params">(<span class="hljs-type">const</span> FName&amp; Tag)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">LOG_BLUE</span>(<span class="hljs-string">&quot;ClientTestRPC called on %s. Tag: %s&quot;</span>, *<span class="hljs-built_in">GetName</span>(), *Tag.<span class="hljs-built_in">ToString</span>());<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AUEDemo_DSCharacter::MulticastTestRPC_Implementation</span><span class="hljs-params">(<span class="hljs-type">const</span> FName&amp; Tag)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">LOG_BLUE</span>(<span class="hljs-string">&quot;MulticastTestRPC called on %s. Tag: %s&quot;</span>, *<span class="hljs-built_in">GetName</span>(), *Tag.<span class="hljs-built_in">ToString</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>RPC函数的实现与普通函数不同，其实现的函数签名必须要有 <code>_Implementation</code>后缀才行，这是因为区别于c++的函数调用，在UHT生成自定义代码时，会自动生成RPC函数调用的实现，其内部封装了网络传输细节，最终在RPC执行的进程上调用了 <code>_Implementation</code>后缀的方法。<br>可在 <code>UEDemo_DSCharacter.gen.cpp</code>中观察到细节。下述代码为 <code>ServerTestRPC</code>方法的不分自定义代码的生成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 函数参数将封装成结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UEDemo_DSCharacter_eventServerTestRPC_Parms</span> <br>&#123;<br>FName Tag;<br>&#125;;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> FName NAME_AUEDemo_DSCharacter_ServerTestRPC = <span class="hljs-built_in">FName</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;ServerTestRPC&quot;</span>));<br><span class="hljs-comment">// 这里实现了ServerTestRPC的普通函数调用实现，其中将参数封装，并调用ProcessEvent，将请求发出去</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AUEDemo_DSCharacter::ServerTestRPC</span><span class="hljs-params">(FName <span class="hljs-type">const</span>&amp; Tag)</span> </span><br><span class="hljs-function"></span>&#123;<br>UEDemo_DSCharacter_eventServerTestRPC_Parms Parms;<br>Parms.Tag=Tag;<br>UFunction* Func = <span class="hljs-built_in">FindFunctionChecked</span>(NAME_AUEDemo_DSCharacter_ServerTestRPC);<br><span class="hljs-built_in">ProcessEvent</span>(Func,&amp;Parms);<br>&#125;<br><span class="hljs-comment">// 实现了exeServerTestRPC函数，在执行RPC的进程上会被调用到。可以看到，这里调用了ServerTestRPC_Implementation.</span><br><span class="hljs-built_in">DEFINE_FUNCTION</span>(AUEDemo_DSCharacter::execServerTestRPC)<br>&#123;<br><span class="hljs-built_in">P_GET_PROPERTY</span>(FNameProperty,Z_Param_Tag);<br>P_FINISH;<br>P_NATIVE_BEGIN;<br>P_THIS-&gt;<span class="hljs-built_in">ServerTestRPC_Implementation</span>(Z_Param_Tag);<br>P_NATIVE_END;<br>&#125;<br><span class="hljs-comment">// 更多的细节可以阅读UEDemo_DSCharacter.gen.cpp和UEDemo_DSCharacter.gen.h</span><br></code></pre></td></tr></table></figure><p>在Demo工程中，<code>AUEDemo_DSCharacter::StartFire</code>是客户端本地响应鼠标左键的接口，可以理解为客户端本地调用的接口，在这里分别调用三个RPC函数(注意在 <code>HandleFire()</code>前执行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AUEDemo_DSCharacter::StartFire</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!bIsFiringWeapon)<br>&#123;<br>bIsFiringWeapon = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">GetWorld</span>()-&gt;<span class="hljs-built_in">GetTimerManager</span>().<span class="hljs-built_in">SetTimer</span>(FiringTimer, <span class="hljs-keyword">this</span>, &amp;AUEDemo_DSCharacter::StopFire, FireRate, <span class="hljs-literal">true</span>);<br><br><span class="hljs-built_in">ServerTestRPC</span>(<span class="hljs-string">&quot;StartFire&quot;</span>);<br><span class="hljs-built_in">ClientTestRPC</span>(<span class="hljs-string">&quot;StartFire&quot;</span>);<br><span class="hljs-built_in">MulticastTestRPC</span>(<span class="hljs-string">&quot;StartFire&quot;</span>);<br><br><span class="hljs-built_in">HandleFire</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而 <code>HandleFire</code>方法是一个声明为Server的RPC方法，他将会在服务器执行，在这个方法中做如下调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AUEDemo_DSCharacter::HandleFire_Implementation</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// .... 忽略其他逻辑</span><br><span class="hljs-built_in">ServerTestRPC</span>(<span class="hljs-string">&quot;HandleFire_Implementation&quot;</span>);<br><span class="hljs-built_in">ClientTestRPC</span>(<span class="hljs-string">&quot;HandleFire_Implementation&quot;</span>);<br><span class="hljs-built_in">MulticastTestRPC</span>(<span class="hljs-string">&quot;HandleFire_Implementation&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译后启动两个客户端和一个服务器，客户端1输入鼠标左键，效果如下（<em>客户端日志从下往上，服务器日志从上往下</em>）：</p><ul><li>客户端1首先执行StartFire方法<ul><li>客户端1首先执行了ClientTestRPC(Tag:StartFire)方法</li><li>同时在服务器端，执行了ServerTestRPC(Tag:StartFire)方法</li><li>MulticastTestRPC(Tag:StartFire)方法仅在客户端1执行</li></ul></li><li>服务器端执行HandleFire方法<ul><li>在服务器端执行了ServerTestRPC(Tag:StartFire_Implementation)方法</li><li>在客户端1上执行了ClientTestRPC(Tag:StartFire_Implementation)方法</li><li>在客户端1和客户端2都执行了MulticastTestRPC(Tag:StartFire_Implementation)方法</li></ul></li></ul><img src="/2024/12/29/link/UE/DS/2_%E7%BC%96%E5%86%99%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/2_%E7%BC%96%E5%86%99%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/1734883151880.png" class="" width="1734883151880"><blockquote><p>注意：不要在BeginPlay里调用RPC，在同步时，RPC要早于Actor的同步，如果在BeginPlay中调用RPC，当RPC请求到达客户端时Actor还未生成。</p></blockquote><h2 id="属性同步及使用"><a href="#属性同步及使用" class="headerlink" title="属性同步及使用"></a>属性同步及使用</h2><p>Actor的属性复制是在多人游戏开发中最重要的部分。当Actor类成员属性中带有 <code>Replicated</code>和 <code>ReplicatedUsing</code>元数据说明符标记时，服务器会在每次更改其值时向每个连接的客户端发送更新，每个客户端会将更新的值应用到其本地版本的Actor。</p><blockquote><p>Demo(<a href="https://gitee.com/lixiang2202/uedemo_ds">lixiang2202&#x2F;UEDemo_DS</a>)中对属性复制的各种方式做了详细的测试用例，可参见 <code>Source\UEDemo_DS\ADerivedActor.h</code>。本例中摘取部分重点代码进行介绍。建议下载Demo，尝试修改 <code>ADerivedActor::DoFunc()</code>中对各种同步属性的修改，观察属性复制的结果。</p></blockquote><p>属性同步是<strong>单向的</strong>。只能从服务器同步到客户端，不能从客户端同步到服务器。</p><h3 id="Replicated"><a href="#Replicated" class="headerlink" title="Replicated"></a>Replicated</h3><p><code>Replicated</code>属性标记属性需要复制，并在 <code>GetLifetimeReplicatedProps</code>方法中通过宏 <code>DOREPLIFETIME(ADerivedActor, TestReplicated)</code>来进行注册。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ADerivedActor.h</span><br><span class="hljs-built_in">UPROPERTY</span>(Replicated) <span class="hljs-comment">// 定义该属性需要复制</span><br><span class="hljs-type">int</span> TestReplicated = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// ADerivedActor.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ADerivedActor::GetLifetimeReplicatedProps</span><span class="hljs-params">(TArray&lt;<span class="hljs-keyword">class</span> FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 注册需要同步的属性,该方法重写了Actor的方法</span><br>Super::<span class="hljs-built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);<br><span class="hljs-built_in">DOREPLIFETIME</span>(ADerivedActor, TestReplicated); <span class="hljs-comment">// 注册同步变量</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Demo中 <code>ADerivedActor::Tick</code>控制了每2秒打印一次属性 <code>TestReplicated</code>的值，以便观察数据变化。</p></blockquote><h3 id="ReplicatedUsing"><a href="#ReplicatedUsing" class="headerlink" title="ReplicatedUsing"></a>ReplicatedUsing</h3><p><code>ReplicatedUsing</code>属性需要自定义 <code>RepNotify</code>函数，当<em>属性被复制时，客户端就会调用该函数</em>。<code>RepNotify</code>支持参数，可以是<strong>值类型</strong>参数，也可以是<strong>常引用类型</strong>参数。参数的含义是属性复制前的值。也可以没有参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ADerivedActor.h</span><br><span class="hljs-comment">// 测试ReplicatedUsing属性,调用无参数的RepNotify方法</span><br><span class="hljs-built_in">UPROPERTY</span>(ReplicatedUsing=OnRep_TestReplicatedUsing)<br><span class="hljs-type">int</span> TestReplicatedUsing = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 测试ReplicatedUsing属性,调用参数为值类型的RepNotify方法</span><br><span class="hljs-built_in">UPROPERTY</span>(ReplicatedUsing=OnRep_TestReplicatedUsing_Value)<br><span class="hljs-type">int</span> TestReplicatedUsing_Value = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 测试ReplicatedUsing属性,调用参数为常引用的RepNotify方法</span><br><span class="hljs-built_in">UPROPERTY</span>(ReplicatedUsing=OnRep_TestReplicatedUsing_ConstRef)<br><span class="hljs-type">int</span> TestReplicatedUsing_ConstRef = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 分别定义三个RepNotify方法</span><br><span class="hljs-built_in">UFUNCTION</span>()<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OnRep_TestReplicatedUsing</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">LOG_RED</span>(<span class="hljs-string">&quot;ADerivedActor::OnRep_TestReplicatedUsing Value:%d&quot;</span>, TestReplicatedUsing);<br>&#125;<br><span class="hljs-built_in">UFUNCTION</span>()<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OnRep_TestReplicatedUsing_Value</span><span class="hljs-params">(<span class="hljs-type">int</span> LastValue)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// 参数为修改前的值</span><br><span class="hljs-built_in">LOG_RED</span>(<span class="hljs-string">&quot;ADerivedActor::OnRep_TestReplicatedUsing_Value Value:%d LastValue:%d&quot;</span>, TestReplicatedUsing_Value, LastValue);<br>&#125;<br><span class="hljs-built_in">UFUNCTION</span>()<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OnRep_TestReplicatedUsing_ConstRef</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; LastValue)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// 参数为修改前的值</span><br><span class="hljs-built_in">LOG_RED</span>(<span class="hljs-string">&quot;ADerivedActor::OnRep_TestReplicatedUsing_ConstRef Value:%d LastValue:%d&quot;</span>, TestReplicatedUsing_ConstRef, LastValue);<br>&#125;<br><br><span class="hljs-comment">// ADerivedActor.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ADerivedActor::GetLifetimeReplicatedProps</span><span class="hljs-params">(TArray&lt;<span class="hljs-keyword">class</span> FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 注册需要同步的属性,该方法重写了Actor的方法</span><br>Super::<span class="hljs-built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);<br><span class="hljs-built_in">DOREPLIFETIME</span>(ADerivedActor, TestReplicatedUsing);<br><span class="hljs-built_in">DOREPLIFETIME</span>(ADerivedActor, TestReplicatedUsing_Value);<br><span class="hljs-built_in">DOREPLIFETIME</span>(ADerivedActor, TestReplicatedUsing_ConstRef);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以为是否调用 <code>RepNotify</code>方法指定条件。在 <code>GetLifetimeReplicatedProps</code>方法中通过宏 <code>DOREPLIFETIME_CONDITION_NOTIFY</code>来指定 <code>RepNotify</code>的执行条件。UE内置了两个条件：</p><ul><li>ELifetimeRepNotifyCondition::REPNOTIFY_OnChanged<br>当客户端本地和服务器复制过来的属性值不一致时，会调用 <code>RepNotify</code></li><li>ELifetimeRepNotifyCondition::REPNOTIFY_Always<br>始终会调用 <code>RepNotify</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">DOREPLIFETIME_CONDITION_NOTIFY</span>(ADerivedActor, TestReplicatedUsing_Always_RepNotify, COND_None, REPNOTIFY_Always);<br></code></pre></td></tr></table></figure><blockquote><p>Demo中提供了 <code>ADerivedActor::IncTestReplicatedUsing_Always_RepNotify</code>方法使属性 <code>TestReplicatedUsing_Always_RepNotify</code>自增，控制该方法与服务器修改该值的执行一致可构造出 <code>REPNOTIFY_OnChanged</code>的测试条件</p></blockquote><p>还可以指定条件复制，在 <code>GetLifetimeReplicatedProps</code>方法中通过宏 <code>DOREPLIFETIME_CONDITION(ADerivedActor, TestReplicatedUsing_CondOwnerOnly, COND_OwnerOnly);</code>来指定复制条件。其中第三个参数为条件，UE预定义了若干条件选项：</p><ul><li>COND_None: 没有条件，一旦更改即复制。</li><li>COND_OwnerOnly: 仅复制到Actor的所有者。</li><li>COND_SkipOwner: 复制到除Actor的所有者之外的每个连接。</li><li>COND_SimulatedOnly: 复制到模拟的Actor。</li><li>COND_AutonomousOnly: 仅复制到自主Actor。</li><li>COND_Custom: 没有特定条件，但能够打开或关闭。</li><li>更多可参见枚举 <code>ELifetimeCondition</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ADerivedActor.h</span><br><span class="hljs-comment">// 测试条件复制,COND_OwnerOnly</span><br><span class="hljs-built_in">UPROPERTY</span>(ReplicatedUsing=OnRep_TestReplicatedUsing_CondOwnerOnly)<br><span class="hljs-type">int</span> TestReplicatedUsing_CondOwnerOnly = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 测试条件复制,COND_SkipOwner</span><br><span class="hljs-built_in">UPROPERTY</span>(ReplicatedUsing=OnRep_TestReplicatedUsing_CondSkipOwner)<br><span class="hljs-type">int</span> TestReplicatedUsing_CondSkipOwner = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 分别定义RepNotify方法</span><br><span class="hljs-built_in">UFUNCTION</span>()<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OnRep_TestReplicatedUsing_CondOwnerOnly</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-built_in">UFUNCTION</span>()<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OnRep_TestReplicatedUsing_CondSkipOwner</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-comment">// ADerivedActor.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ADerivedActor::GetLifetimeReplicatedProps</span><span class="hljs-params">(TArray&lt;<span class="hljs-keyword">class</span> FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 注册需要同步的属性,该方法重写了Actor的方法</span><br>Super::<span class="hljs-built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);<br><span class="hljs-built_in">DOREPLIFETIME_CONDITION</span>(ADerivedActor, TestReplicatedUsing_CondOwnerOnly, COND_OwnerOnly); <span class="hljs-comment">// 在Actor的所有者中进行复制</span><br><span class="hljs-built_in">DOREPLIFETIME_CONDITION</span>(ADerivedActor, TestReplicatedUsing_CondSkipOwner, COND_SkipOwner); <span class="hljs-comment">// 除Actor所有者以外的客户端进行复制</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>COND_Custom</strong>可以更加精细的控制Actor属性何时复制。在 <code>GetLifetimeReplicatedProps</code>方法中通过宏 <code>DOREPLIFETIME_CONDITION</code>将属性复制条件定义为 <code>COND_Custom</code>。然后在 <code>PreReplication</code>方法中使用宏 <code>DOREPLIFETIME_ACTIVE_OVERRIDE</code>来自定义复制条件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ADerivedActor.h</span><br><span class="hljs-comment">// 测试自定义复制条件</span><br><span class="hljs-built_in">UPROPERTY</span>(ReplicatedUsing=OnRep_TestReplicatedUsing_CondCustom)<br><span class="hljs-type">int</span> TestReplicatedUsing_CondCustom = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 定义RepNotify方法</span><br><span class="hljs-built_in">UFUNCTION</span>()<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OnRep_TestReplicatedUsing_CondCustom</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-comment">// ADerivedActor.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ADerivedActor::GetLifetimeReplicatedProps</span><span class="hljs-params">(TArray&lt;<span class="hljs-keyword">class</span> FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 注册需要同步的属性,该方法重写了Actor的方法</span><br>Super::<span class="hljs-built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);<br><span class="hljs-built_in">DOREPLIFETIME_CONDITION</span>(ADerivedActor, TestReplicatedUsing_CondCustom, COND_Custom); <span class="hljs-comment">// 自定义条件</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ADerivedActor::PreReplication</span><span class="hljs-params">(IRepChangedPropertyTracker&amp; ChangedPropertyTracker)</span></span><br><span class="hljs-function"></span>&#123;<br>Super::<span class="hljs-built_in">PreReplication</span>(ChangedPropertyTracker);<br><span class="hljs-comment">// 第三个参数为true时，进行复制</span><br><span class="hljs-built_in">DOREPLIFETIME_ACTIVE_OVERRIDE</span>(ADerivedActor, TestReplicatedUsing_CondCustom, <span class="hljs-built_in">TestReplicatedUsingNeedSync</span>());<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ADerivedActor::TestReplicatedUsingNeedSync</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> TestReplicatedUsing_CondCustom % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>可见自定义复制条件不仅可以执行预定义复制条件所能执行的所有才做，还能执行更多操作，但要注意：</p><ul><li>自定义复制条件会消耗更多的资源和更多的时间</li><li>自定义复制条件不能根据连接而更改</li></ul></blockquote><h3 id="NotReplicated"><a href="#NotReplicated" class="headerlink" title="NotReplicated"></a>NotReplicated</h3><p>指定不复制的属性，在复制结构体中排除某个属性时很有用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ADerivedActor.h</span><br><span class="hljs-built_in">USTRUCT</span>()<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FMyStruct</span><br>&#123;<br><span class="hljs-built_in">GENERATED_BODY</span>()<br><br><span class="hljs-built_in">UPROPERTY</span>()<br><span class="hljs-type">int</span> Param1 = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">UPROPERTY</span>(NotReplicated) <span class="hljs-comment">// 指明Param2不复制</span><br><span class="hljs-type">int</span> Param2 = <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-comment">// 测试ReplicatedUsing属性,复制结构体,调用参数为常引用的RepNotify方法.结构体中的一个属性为NotReplicated</span><br><span class="hljs-built_in">UPROPERTY</span>(ReplicatedUsing=OnRep_TestStruct_ConstRef)<br>FMyStruct TestStruct; <span class="hljs-comment">// 虽然指定了FMyStruct结构需要复制，但其内部成员Param2不会被复制</span><br></code></pre></td></tr></table></figure><h3 id="PushModel"><a href="#PushModel" class="headerlink" title="PushModel"></a>PushModel</h3><p>上述所讲的属性同步，服务器在特定的时间去判断每个需要复制的属性是否变化。使用 <code>PushModel</code>可以避免这种比较，在属性修改的地方，调用 <code>MARK_PROPERTY_DIRTY_FROM_NAME</code>标记该属性需要同步，则省略了属性是否变化的判断过程。</p><p>要使用 <code>PushModel</code>，需要在 <code>GetLifetimeReplicatedProps</code>方法中使用宏 <code>DOREPLIFETIME_WITH_PARAMS_FAST</code>进行注册，宏的第三个参数为 <code>FDoRepLifetimeParams</code>结构对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FDoRepLifetimeParams</span><br>&#123;<br><span class="hljs-comment">/** Replication Condition.  */</span><br>ELifetimeCondition Condition = COND_None;<br><span class="hljs-comment">/** RepNotify Condition. */</span><br>ELifetimeRepNotifyCondition RepNotifyCondition = REPNOTIFY_OnChanged;<br><span class="hljs-comment">/** Whether or not this property uses Push Model. See PushModel.h */</span><br><span class="hljs-type">bool</span> bIsPushBased = <span class="hljs-literal">false</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>Condition：属性同步条件</li><li>RepNotifyCondition：RepNotify的执行规则</li><li>bIsPushBased：是否启用PushModel</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ADerivedActor.h</span><br><span class="hljs-comment">// 测试PushModel</span><br><span class="hljs-built_in">UPROPERTY</span>(ReplicatedUsing=OnRep_TestReplicatedUsingPushModel)<br><span class="hljs-type">int</span> TestReplicatedUsingPushModel = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">UFUNCTION</span>()<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OnRep_TestReplicatedUsingPushModel</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-comment">// ADerivedActor.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ADerivedActor::DoFunc</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>++TestReplicatedUsingPushModel; <span class="hljs-comment">// 测试PushModel</span><br><span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == TestReplicatedUsingPushModel % <span class="hljs-number">2</span>)<br>&#123; <span class="hljs-comment">// 偶数时，标记属性同步</span><br><span class="hljs-built_in">MARK_PROPERTY_DIRTY_FROM_NAME</span>(ADerivedActor, TestReplicatedUsingPushModel, <span class="hljs-keyword">this</span>);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ADerivedActor::GetLifetimeReplicatedProps</span><span class="hljs-params">(TArray&lt;<span class="hljs-keyword">class</span> FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 注册需要同步的属性</span><br>Super::<span class="hljs-built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);<br><span class="hljs-comment">// 使用Push Model</span><br>FDoRepLifetimeParams SharedParams;<br>SharedParams.bIsPushBased = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">DOREPLIFETIME_WITH_PARAMS_FAST</span>(ADerivedActor, TestReplicatedUsingPushModel, SharedParams);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：对于一个Actor，如果采用了 <code>PushModel</code>，那么所有的属性都需要以 <code>PushModel</code>的方式进行同步，否则会退化会常规情况。</p></blockquote><h3 id="数组同步"><a href="#数组同步" class="headerlink" title="数组同步"></a>数组同步</h3><blockquote><p>只有 <code>TArray</code>支持同步，<code>TMap</code>和 <code>TSet</code>均不支持网络同步。</p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/640632055">UE4 网络同步框架介绍及使用 - 知乎</a></p><h3 id="复制对象引用"><a href="#复制对象引用" class="headerlink" title="复制对象引用"></a>复制对象引用</h3><p>对象引用的复制由虚幻引擎的复制系统自动处理。如果你有复制的 UObject 属性，对该对象的引用会作为权威服务器分配的 FNetworkGUID 通过网络连接发送。服务器接着会向所有连接的客户端通知此分配。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// UEDemo_DSCharacter.h</span><br><span class="hljs-built_in">UPROPERTY</span>(Replicated)<br>ADerivedActor* DerivedActor; <span class="hljs-comment">// ADerivedActor为可复制，该引用标记为Replicated后，会自动复制该引用</span><br></code></pre></td></tr></table></figure><h3 id="属性复制宏汇总"><a href="#属性复制宏汇总" class="headerlink" title="属性复制宏汇总"></a>属性复制宏汇总</h3><p>下面介绍了UE中可用的<strong>属性复制宏</strong>，以及在什么方法中调用宏，关联的 <code>FRepPropertyDescriptor</code>是在编译时还是运行时构造，是否适用于数组。</p><img src="/2024/12/29/link/UE/DS/2_%E7%BC%96%E5%86%99%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/2_%E7%BC%96%E5%86%99%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/1734971853597.png" class="" width="1734971853597"><h2 id="Actor组件复制"><a href="#Actor组件复制" class="headerlink" title="Actor组件复制"></a>Actor组件复制</h2><p><a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/replicating-actor-components-in-unreal-engine">Replicating Actor Components in Unreal Engine | Unreal Engine 5.5 Documentation | Epic Developer Community</a></p><p><a href="https://zhuanlan.zhihu.com/p/533390170">UE4网络同步-Actor Component Object同步 - 知乎</a></p><h2 id="复制子对象"><a href="#复制子对象" class="headerlink" title="复制子对象"></a>复制子对象</h2><p><a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/replicating-uobjects-in-unreal-engine">虚幻引擎中的复制子对象 | 虚幻引擎 5.5 文档 | Epic Developer Community</a></p><p><a href="https://zhuanlan.zhihu.com/p/533390170">UE4网络同步-Actor Component Object同步 - 知乎</a></p><h2 id="Online-Beacons"><a href="#Online-Beacons" class="headerlink" title="Online Beacons"></a>Online Beacons</h2><p><a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/using-online-beacons-in-unreal-engine">使用虚幻引擎中的Online Beacons系统 | 虚幻引擎 5.5 文档 | Epic Developer Community</a></p><h2 id="复制对象的执行顺序"><a href="#复制对象的执行顺序" class="headerlink" title="复制对象的执行顺序"></a>复制对象的执行顺序</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/programming-network-multiplayer-games-for-unreal-engine">在虚幻引擎中制作在线多人游戏 | 虚幻引擎 5.5 文档 | Epic Developer Community</a></p><p><a href="https://zhuanlan.zhihu.com/p/532869518">UE4网络同步-NetMode和NetRole - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/640632055">UE4 网络同步框架介绍及使用 - 知乎</a></p><p><a href="https://www.bearchild.top/2022/04/10/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E7%BD%91%E7%BB%9C/%5BUE%5DPushModel%E5%B1%9E%E6%80%A7%E5%90%8C%E6%AD%A5/">[UE] PushModel 属性同步 | BearChild&#39;s Blog</a></p>]]></content>
    
    
    <categories>
      
      <category>UE</category>
      
      <category>UE多人游戏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE</tag>
      
      <tag>Dedicated Server</tag>
      
      <tag>网络开发</tag>
      
      <tag>网络同步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE-DS】初识DS</title>
    <link href="/2024/12/16/link/UE/DS/1_%E5%88%9D%E8%AF%86DS/1_%E5%88%9D%E8%AF%86DS/"/>
    <url>/2024/12/16/link/UE/DS/1_%E5%88%9D%E8%AF%86DS/1_%E5%88%9D%E8%AF%86DS/</url>
    
    <content type="html"><![CDATA[<h1 id="初识DS"><a href="#初识DS" class="headerlink" title="初识DS"></a>初识DS</h1><p>本篇作为DS入门文档，讲述了DS的构建过程，通过登录、射击游戏的例子对DS开发有一个初步的了解。<br>Demo链接：<a href="https://gitee.com/lixiang2202/uedemo_ds">https://gitee.com/lixiang2202/uedemo_ds</a><br>文档理论性偏弱，操作性较强，建议跟随文档进行操作，收获更多。</p><h2 id="Dedicated-Server-–-专用服务器"><a href="#Dedicated-Server-–-专用服务器" class="headerlink" title="Dedicated Server – 专用服务器"></a>Dedicated Server – 专用服务器</h2><p>来自官方文档的介绍：<a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/setting-up-dedicated-servers-in-unreal-engine">在虚幻引擎中设置专用服务器 | 虚幻引擎 5.5 文档 | Epic Developer Community</a></p><img src="/2024/12/16/link/UE/DS/1_%E5%88%9D%E8%AF%86DS/1_%E5%88%9D%E8%AF%86DS/1733758314967.png" class="" width="1733758314967"><p>在UE5中，客户端代码和服务器代码是一体的，一般通过 <code>AActor</code>中所维护的 <code>TEnumAsByte&lt;enum ENetRole&gt; Role</code>来区分代码在哪里运行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/** The network role of an actor on a local/remote network context */</span><br><span class="hljs-built_in">UENUM</span>(BlueprintType)<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">ENetRole</span> : <span class="hljs-type">int</span><br>&#123;<br><span class="hljs-comment">/** No role at all. */</span><br><span class="hljs-function">ROLE_None <span class="hljs-title">UMETA</span><span class="hljs-params">(DisplayName = <span class="hljs-string">&quot;None&quot;</span>)</span>,</span><br><span class="hljs-function"><span class="hljs-comment">/** Locally simulated proxy of this actor.  本地模拟的其他客户端的Actor*/</span></span><br><span class="hljs-function">ROLE_SimulatedProxy <span class="hljs-title">UMETA</span><span class="hljs-params">(DisplayName = <span class="hljs-string">&quot;Simulated Proxy&quot;</span>)</span>,</span><br><span class="hljs-function"><span class="hljs-comment">/** Locally autonomous proxy of this actor. 本机客户端控制的Actor*/</span></span><br><span class="hljs-function">ROLE_AutonomousProxy <span class="hljs-title">UMETA</span><span class="hljs-params">(DisplayName = <span class="hljs-string">&quot;Autonomous Proxy&quot;</span>)</span>,</span><br><span class="hljs-function"><span class="hljs-comment">/** Authoritative control over the actor. 服务器上的Actor*/</span></span><br><span class="hljs-function">ROLE_Authority <span class="hljs-title">UMETA</span><span class="hljs-params">(DisplayName = <span class="hljs-string">&quot;Authority&quot;</span>)</span>,</span><br><span class="hljs-function">ROLE_MAX <span class="hljs-title">UMETA</span><span class="hljs-params">(Hidden)</span>,</span><br><span class="hljs-function">&#125;</span>;<br></code></pre></td></tr></table></figure><p>Actor提供了 <code>AActor::HasAuthority()</code>方法来判断是否在服务器上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">AActor::HasAuthority</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">GetLocalRole</span>() == ROLE_Authority);<br>&#125;<br><span class="hljs-function">ENetRole <span class="hljs-title">GetLocalRole</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> Role; &#125;<br></code></pre></td></tr></table></figure><h2 id="启用专用服务器"><a href="#启用专用服务器" class="headerlink" title="启用专用服务器"></a>启用专用服务器</h2><h3 id="使用源码引擎"><a href="#使用源码引擎" class="headerlink" title="使用源码引擎"></a>使用源码引擎</h3><p>DS需要使用 <code>Development Server</code>编译模式，这个模式只有使用源码编译的UE5所创建的工程才有这个模式。<br>编译教程可以在网上搜，建议clone时使用ssh协议(<a href="mailto:&#x67;&#105;&#x74;&#x40;&#x67;&#x69;&#x74;&#104;&#x75;&#98;&#46;&#x63;&#111;&#x6d;">&#x67;&#105;&#x74;&#x40;&#x67;&#x69;&#x74;&#104;&#x75;&#98;&#46;&#x63;&#111;&#x6d;</a>:EpicGames&#x2F;UnrealEngine.git)，比https协议更加稳定。</p><img src="/2024/12/16/link/UE/DS/1_%E5%88%9D%E8%AF%86DS/1_%E5%88%9D%E8%AF%86DS/1733759516965.png" class="" width="1733759516965"><blockquote><p>如仅需要测试DS，可以不使用源码编译的二进制引擎，可以跳转到文档最后射击小游戏的测试章节。<br>不过还是建议使用源码引擎体验一次发布流程。</p></blockquote><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>使用源码编译的引擎创建项目。本系列Demo采用第三人称模板C++项目（可以勾选StarterContent，后文例子中使用到了这里的特效资源）。</p><blockquote><p>大多数模板中的Pawn和角色默认启用了复制。第三人称模板已拥有会自动复制移动的<strong>角色移动组件</strong> 。</p></blockquote><img src="/2024/12/16/link/UE/DS/1_%E5%88%9D%E8%AF%86DS/1_%E5%88%9D%E8%AF%86DS/1733759762445.png" class="" width="1733759762445"><h3 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h3><p>创建完成后，在Source目录下，新建 <code>xxxServer.Target.cs</code>和 <code>xxxClient.Target.cs</code></p><blockquote><p>复制自动创建的 <code>xxxEditor.Target.cs</code>，然后将脚本内容中的 <code>Editor</code>字符串替换为 <code>Server </code>或 <code>Client</code>。</p></blockquote><p><code>Target.cs</code>为UBT提供了对应构建目标类型的各种设置，可详见：<a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/unreal-engine-build-tool-target-reference">虚幻引擎构建工具目标参考 | 虚幻引擎 5.5 文档 | Epic Developer Community</a></p><img src="/2024/12/16/link/UE/DS/1_%E5%88%9D%E8%AF%86DS/1_%E5%88%9D%E8%AF%86DS/1733760279284.png" class="" width="1733760279284"><p>创建完成后，在IDE中（文档中使用的是rider）选择构建类型为Development Server，然后进行构建。构建完成后，选择类型为Development Client，进行构建。构建这两个目标耗时较久。</p><img src="/2024/12/16/link/UE/DS/1_%E5%88%9D%E8%AF%86DS/1_%E5%88%9D%E8%AF%86DS/1733760341857.png" class="" width="1733760341857"><p>可以看到，在.&#x2F;UEDemo_DS&#x2F;Binaries&#x2F;Win64下生成了 <code>UEDemo_DSServer.exe</code>和 <code>UEDemo_DSClient.exe</code>。但此时还无法运行。</p><h3 id="设置项目"><a href="#设置项目" class="headerlink" title="设置项目"></a>设置项目</h3><p>构建完成后，选择构建模式为Development Editor，编译启动该项目编辑器。</p><p>因为项目创建时，选择了第三人称模板，所以在Content中可以看到一些资产。编辑器默认选择的level为 <code>ThirdPersonMap</code>，点击模拟播放后，可以运行第三人称模板的内容。</p><p>新建一个空level：TransitionMap，作为切换地图时的过渡level。</p><p>在 <code>Project Settings -&gt; Project -&gt; Maps &amp; Modes</code>中，设置 <code>Transition Map</code>和 <code>Server Default Map</code>，如下图所示：</p><img src="/2024/12/16/link/UE/DS/1_%E5%88%9D%E8%AF%86DS/1_%E5%88%9D%E8%AF%86DS/1733760901493.png" class="" width="1733760901493"><h3 id="COOK资源"><a href="#COOK资源" class="headerlink" title="COOK资源"></a>COOK资源</h3><p>无论是client程序还是server程序，都需要cook资源才能够正确运行。在 <code>Platforms</code>中 <code>BUILD TARGET</code>设置为 <code>UEDemo_DSServer </code>，然后点击 <code>Cook Content</code>。成功后同理设置 <code>BUILD TARGET</code>为 <code>UEDemo_DSClient</code>。</p><img src="/2024/12/16/link/UE/DS/1_%E5%88%9D%E8%AF%86DS/1_%E5%88%9D%E8%AF%86DS/1733761188553.png" class="" width="1733761188553"><p>可以在 <code>UEDemo_DS\Saved\Cooked</code>目录下看到生成了Server和Client的cooked目录，两者的大小是不一样的，Server端cooked要小于Client端cooked。</p><img src="/2024/12/16/link/UE/DS/1_%E5%88%9D%E8%AF%86DS/1_%E5%88%9D%E8%AF%86DS/1733761434228.png" class="" width="1733761434228"><h3 id="运行专用服务器"><a href="#运行专用服务器" class="headerlink" title="运行专用服务器"></a>运行专用服务器</h3><p>此时可以运行专用服务器了。如果直接双击运行，会在后台运行Server，为了调试方便，建议为UEDemo_DSServer新建快捷方式，在快捷方式的目标栏中，添加-log参数（注意参数前要有空格）</p><img src="/2024/12/16/link/UE/DS/1_%E5%88%9D%E8%AF%86DS/1_%E5%88%9D%E8%AF%86DS/1733761597251.png" class="" width="1733761597251"><p>双击快捷方式，可以看到打开一个控制台，这个就是DS服务器了。</p><p>打开UE客户端（编辑器模拟启动或者双击打开UEDemo_DSClient.exe），按下键盘’~’键，输入 <code>open 127.0.0.1</code>，登录到DS服务器上。</p><img src="/2024/12/16/link/UE/DS/1_%E5%88%9D%E8%AF%86DS/1_%E5%88%9D%E8%AF%86DS/1733761766851.png" class="" width="1733761766851"><p>观察DS控制台，可以看到服务器接受了一个客户端的连接，并且使用的是服务器的地图。（注：可以复制一份ThirdPersonMap做以下修改，并在项目配置中的Server Default Map中修改服务器地图，观察登录DS服务器后客户端加载的地图变为了服务器地图）</p><img src="/2024/12/16/link/UE/DS/1_%E5%88%9D%E8%AF%86DS/1_%E5%88%9D%E8%AF%86DS/1733762004906.png" class="" width="1733762004906"><p>此时再次启动一个客户端，登录DS服务器，可以在客户端上看到两个角色。下图分别使用了编辑器模拟和UEDemo_DSClient.exe打开了两个客户端，并通过open命令登录至服务器中。操作一个客户端的角色，在另一个客户端可以看到同步效果。</p><blockquote><p>在 <code>项目设置-&gt;引擎-&gt;一般设置-&gt;帧率，设置平滑帧率，限制最小帧率为30</code>，可以解决失焦的客户端卡顿问题</p><img src="/2024/12/16/link/UE/DS/1_%E5%88%9D%E8%AF%86DS/1_%E5%88%9D%E8%AF%86DS/1734359068906.png" class="" width="1734359068906"></blockquote><img src="/2024/12/16/link/UE/DS/1_%E5%88%9D%E8%AF%86DS/1_%E5%88%9D%E8%AF%86DS/1733762101357.png" class="" width="1733762101357"><h2 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h2><h3 id="登录服务器"><a href="#登录服务器" class="headerlink" title="登录服务器"></a>登录服务器</h3><p>可以使用 <code>APlayerController::ClientTravel</code>接口登录服务器。新建 <code>UUEDemo_DSGameInstance</code>，继承自 <code>UGameInstance</code>，并在项目设置中指定。</p><img src="/2024/12/16/link/UE/DS/1_%E5%88%9D%E8%AF%86DS/1_%E5%88%9D%E8%AF%86DS/1733846527722.png" class="" width="1733846527722"><p>新增连接DS服务器的方法，供蓝图使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 声明</span><br><span class="hljs-built_in">UFUNCTION</span>(BlueprintCallable)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ConnectDedicatedServer</span><span class="hljs-params">(<span class="hljs-type">const</span> FString&amp; ServerIP)</span></span>;<br><span class="hljs-comment">// 实现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UUEDemo_DSGameInstance::ConnectDedicatedServer</span><span class="hljs-params">(<span class="hljs-type">const</span> FString&amp; ServerIP)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">GetWorld</span>()-&gt;<span class="hljs-built_in">GetFirstPlayerController</span>()-&gt;<span class="hljs-built_in">ClientTravel</span>(ServerIP, ETravelType::TRAVEL_Absolute);<br>&#125;<br></code></pre></td></tr></table></figure><p>打开编辑器，新建一个登录界面 <code>UMG_Login</code>，布局如下：</p><img src="/2024/12/16/link/UE/DS/1_%E5%88%9D%E8%AF%86DS/1_%E5%88%9D%E8%AF%86DS/1733847260352.png" class="" width="1733847260352"><p>在蓝图中实现点击按钮调用 <code>UUEDemo_DSGameInstance::ConnectDedicatedServer</code></p><img src="/2024/12/16/link/UE/DS/1_%E5%88%9D%E8%AF%86DS/1_%E5%88%9D%E8%AF%86DS/1733847342156.png" class="" width="1733847342156"><p>新建一个Level文件 <code>ClientLevel</code>，设置为客户端默认关卡：</p><img src="/2024/12/16/link/UE/DS/1_%E5%88%9D%E8%AF%86DS/1_%E5%88%9D%E8%AF%86DS/1733847414585.png" class="" width="1733847414585"><p>在关卡蓝图中创建界面，并设置鼠标：</p><img src="/2024/12/16/link/UE/DS/1_%E5%88%9D%E8%AF%86DS/1_%E5%88%9D%E8%AF%86DS/1733847468656.png" class="" width="1733847468656"><p>重新cook客户端和服务器资源后，启动服务器，客户端，可以看到登录界面，点击登录界面后登录到DS服务器中，客户端此时使用的是服务器的地图。</p><img src="/2024/12/16/link/UE/DS/1_%E5%88%9D%E8%AF%86DS/1_%E5%88%9D%E8%AF%86DS/1733847619096.png" class="" width="1733847619096"><h3 id="射击小游戏"><a href="#射击小游戏" class="headerlink" title="射击小游戏"></a>射击小游戏</h3><blockquote><p>使用UE的同步架构，实现一个简单的射击游戏，AB两个角色可以互相发射子弹，被击中后会掉血。这里血量就简单用屏幕日志来输出。<br>这个小游戏参考了官方文档（<a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/multiplayer-programming-quick-start-for-unreal-engine">虚幻引擎多人游戏编程快速入门指南 | 虚幻引擎 5.5 文档 | Epic Developer Community</a>），借此来简单熟悉UE的网络开发。</p></blockquote><h4 id="血量属性维护"><a href="#血量属性维护" class="headerlink" title="血量属性维护"></a>血量属性维护</h4><p>在 <code>AUEDemo_DSCharacter</code>中新增血量属性，并在构造方法中进行初始化。</p><blockquote><p>关于Actor的属性复制可详见：<a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/replicate-actor-properties-in-unreal-engine">在虚幻引擎中复制Actor属性</a> 本篇文档仅使用部分复制方式</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 玩家最大生命值，不复制</span><br><span class="hljs-built_in">UPROPERTY</span>(EditDefaultsOnly, Category=<span class="hljs-string">&quot;Health&quot;</span>)<br><span class="hljs-type">float</span> MaxHealth;<br><br><span class="hljs-comment">// 玩家当前生命值，复制</span><br><span class="hljs-built_in">UPROPERTY</span>(ReplicatedUsing=OnRep_CurrentHealth)<br><span class="hljs-type">float</span> CurrentHealth;<br><br><span class="hljs-comment">// RepNotify, 同步CurrentHealth时调用</span><br><span class="hljs-built_in">UFUNCTION</span>()<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OnRep_CurrentHealth</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// 构造方法的实现</span><br>AUEDemo_DSCharacter::<span class="hljs-built_in">AUEDemo_DSCharacter</span>()<br>&#123;<br><span class="hljs-comment">//...</span><br><span class="hljs-comment">// 初始化角色的最大生命值和当前生命值</span><br>MaxHealth = <span class="hljs-number">100.f</span>;<br>CurrentHealth = MaxHealth;<br>&#125;<br></code></pre></td></tr></table></figure><p>重写 <code>GetLifetimeReplicatedProps</code>，注册配置 <code>CurrentHealth</code>的复制方式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AUEDemo_DSCharacter::GetLifetimeReplicatedProps</span><span class="hljs-params">(TArray&lt;<span class="hljs-keyword">class</span> FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>Super::<span class="hljs-built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);<br><span class="hljs-comment">// 复制当前生命值</span><br><span class="hljs-built_in">DOREPLIFETIME</span>(AUEDemo_DSCharacter, CurrentHealth);<br>&#125;<br></code></pre></td></tr></table></figure><p>声明并实现方法 <code>void OnHealthUpdate()</code>，响应要更新的声明值。修改属性后，在服务器立即调用，在客户端响应 <code>OnRep_CurrentHealth</code>方法，并在其中调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AUEDemo_DSCharacter::OnHealthUpdate</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 客户端功能</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsLocallyControlled</span>())<br>&#123;<br><span class="hljs-built_in">LOG_BLUE</span>(<span class="hljs-string">&quot;Health changed to: %f&quot;</span>, CurrentHealth);<br><span class="hljs-keyword">if</span> (CurrentHealth &lt;= <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">LOG_RED</span>(<span class="hljs-string">&quot;you have been killed!&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 服务器功能</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">HasAuthority</span>())<br>&#123; <br><span class="hljs-built_in">LOG_BLUE</span>(<span class="hljs-string">&quot;%s now has %f health remaining&quot;</span>, *<span class="hljs-built_in">GetName</span>(), CurrentHealth);<br>&#125;<br><span class="hljs-comment">// 在所有机器上都执行的功能</span><br><span class="hljs-built_in">LOG_GREEN</span>(<span class="hljs-string">&quot;OnHealthUpdate called on %s, %f&quot;</span>, *<span class="hljs-built_in">GetName</span>(), CurrentHealth);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>LOG_XXX方法实际是用宏封装了 <code>GEngine-&gt;AddOnScreenDebugMessage()</code>和 <code>UE_LOG</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-built_in">DECLARE_LOG_CATEGORY_EXTERN</span>(LogUEDemoDS, Log, All);<br><span class="hljs-built_in">DEFINE_LOG_CATEGORY</span>(LogUEDemoDS);<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_PRINT(Color, Format, ...) \</span><br><span class="hljs-meta">&#123; \</span><br><span class="hljs-meta"><span class="hljs-keyword">if</span> (GEngine)&#123; GEngine-&gt;AddOnScreenDebugMessage(-1, 5.f, Color, FString::Printf(TEXT(Format), ##__VA_ARGS__));&#125; \</span><br><span class="hljs-meta">UE_LOG(LogUEDemoDS, Error, TEXT(Format), ##__VA_ARGS__); \</span><br><span class="hljs-meta">&#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_RED(Format, ...) LOG_PRINT(FColor::Red, Format, ##__VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_GREEN(Format, ...) LOG_PRINT(FColor::Green, Format, ##__VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_BLUE(Format, ...) LOG_PRINT(FColor::Blue, Format, ##__VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_YELLOW(Format, ...) LOG_PRINT(FColor::Yellow, Format, ##__VA_ARGS__)</span><br><br></code></pre></td></tr></table></figure></blockquote><p>在 <code>OnRep_CurrentHealth()</code>中调用 <code>OnHealthUpdate()</code>方法</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">void AUEDemo_DSCharacter::<span class="hljs-built_in">OnRep_CurrentHealth</span>()<br>&#123;<br><span class="hljs-built_in">LOG_YELLOW</span>(&quot;OnRep_CurrentHealth called on %s&quot;, *GetName());<br><span class="hljs-built_in">OnHealthUpdate</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>实现 <code>SetCurrentHealth</code>和 <code>TakeDamage</code>方法，用于响应伤害。<br><code>SetCurrentHealth()</code>提供了一个可控的办法从外部修改玩家 <code>CurrentHealth</code>，通过判断 <code>HasAuthority()</code>来限定仅在服务器上执行此函数，同时调用了 <code>OnHealUpdate()</code>以确保客户端和服务器对其都有调用。<br>而 <code>TakeDamage()</code>方法重写自 <code>APawn</code>，作为外部Actor对其造成伤害后的逻辑触发。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AUEDemo_DSCharacter::SetCurrentHealth</span><span class="hljs-params">(<span class="hljs-type">float</span> healthValue)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">HasAuthority</span>())<br>&#123;<br><span class="hljs-built_in">LOG_YELLOW</span>(<span class="hljs-string">&quot;SetCurrentHealth called on %s&quot;</span>, *<span class="hljs-built_in">GetName</span>());<br>CurrentHealth = FMath::<span class="hljs-built_in">Clamp</span>(healthValue, <span class="hljs-number">0.f</span>, MaxHealth);<br><span class="hljs-built_in">OnHealthUpdate</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">AUEDemo_DSCharacter::TakeDamage</span><span class="hljs-params">(<span class="hljs-type">float</span> DamageTaken, <span class="hljs-keyword">struct</span> FDamageEvent <span class="hljs-type">const</span>&amp; DamageEvent, AController* EventInstigator, AActor* DamageCauser)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">float</span> damageApplied = CurrentHealth - DamageTaken;<br><span class="hljs-built_in">SetCurrentHealth</span>(damageApplied);<br><span class="hljs-keyword">return</span> damageApplied;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="测试属性同步"><a href="#测试属性同步" class="headerlink" title="测试属性同步"></a>测试属性同步</h4><p>临时在 <code>Jump</code>方法中模拟造成伤害，主动调用 <code>TakeDamage()</code>，对属性同步进行测试。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AUEDemo_DSCharacter::Jump</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Super::<span class="hljs-built_in">Jump</span>();<br><span class="hljs-function">FDamageEvent <span class="hljs-title">damageEvent</span><span class="hljs-params">(UDamageType::StaticClass())</span></span>;<br><span class="hljs-built_in">TakeDamage</span>(<span class="hljs-number">10.f</span>, damageEvent, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>); <span class="hljs-comment">// 造成10点伤害</span><br>&#125;<br></code></pre></td></tr></table></figure><p>重新编译 <code>Server</code>和 <code>Client</code>，启动2个客户端并登录至服务器，一个客户端角色跳跃，观察另外客户端日志和服务器日志，可以看到属性同步的结果。</p><img src="/2024/12/16/link/UE/DS/1_%E5%88%9D%E8%AF%86DS/1_%E5%88%9D%E8%AF%86DS/1733932027592.png" class="" width="1733932027592"><p>如图所示，1号客户端、2号客户端登录在同一个服务器上，1号客户端跳跃：</p><ul><li>服务器执行方法 <code>SetCurrentHealth</code>响应处理了伤害，并同步给1、2号客户端</li><li>1号客户端响应 <code>OnRep_CurrentHealth</code>并执行 <code>OnHealthUpdate</code>方法。因为是本地客户端 <code>IsLocallyControlled</code>，所以输出了蓝色日志和绿色日志</li><li>2号客户端响应 <code>OnRep_CurrentHealth</code>并执行 <code>OnHealthUpdate</code>方法。仅输出了通用的绿色日志</li></ul><h4 id="使用复制创建抛射物"><a href="#使用复制创建抛射物" class="headerlink" title="使用复制创建抛射物"></a>使用复制创建抛射物</h4><p>接下来，为角色创建一个发射抛射物的功能。</p><ul><li><p>首先新建一个抛射物Actor：<code>AUEDemo_DSProjectile</code><br>在构造方法中设置 <code>bReplicates = true</code>，表示这个Actor需要被复制。<br>在头文件中做如下定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 用于测试碰撞的球体组件。</span><br><span class="hljs-built_in">UPROPERTY</span>(VisibleAnywhere, BlueprintReadOnly, Category=<span class="hljs-string">&quot;Components&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">USphereComponent</span>* SphereComponent;<br><br><span class="hljs-comment">// 用于提供对象视觉呈现效果的静态网格体。</span><br><span class="hljs-built_in">UPROPERTY</span>(VisibleAnywhere, BlueprintReadOnly, Category=<span class="hljs-string">&quot;Components&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UStaticMeshComponent</span>* StaticMesh;<br><br><span class="hljs-comment">// 用于处理投射物移动的移动组件。</span><br><span class="hljs-built_in">UPROPERTY</span>(VisibleAnywhere, BlueprintReadOnly, Category=<span class="hljs-string">&quot;Components&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UProjectileMovementComponent</span>* ProjectileMovementComponent;<br><br><span class="hljs-comment">// 在投射物撞击其他对象并爆炸时使用的粒子。</span><br><span class="hljs-built_in">UPROPERTY</span>(EditAnywhere, Category = <span class="hljs-string">&quot;Effects&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UParticleSystem</span>* ExplosionEffect;<br><br><span class="hljs-comment">//此投射物将造成的伤害类型和伤害。</span><br><span class="hljs-built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = <span class="hljs-string">&quot;Damage&quot;</span>)<br>TSubclassOf&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">UDamageType</span>&gt; DamageType;<br><br><span class="hljs-comment">//此投射物造成的伤害。</span><br><span class="hljs-built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category=<span class="hljs-string">&quot;Damage&quot;</span>)<br><span class="hljs-type">float</span> Damage;<br></code></pre></td></tr></table></figure></li><li><p>在构造方法中做如下初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//定义根节点及碰撞信息</span><br>SphereComponent = <span class="hljs-built_in">CreateDefaultSubobject</span>&lt;USphereComponent&gt;(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;SphereComponent&quot;</span>));<br>SphereComponent-&gt;<span class="hljs-built_in">InitSphereRadius</span>(<span class="hljs-number">37.5f</span>);<br>SphereComponent-&gt;<span class="hljs-built_in">SetCollisionProfileName</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;BlockAllDynamic&quot;</span>));<br>RootComponent = SphereComponent;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">HasAuthority</span>())<br>&#123; <span class="hljs-comment">// 仅在服务器端添加碰撞回调</span><br>SphereComponent-&gt;OnComponentHit.<span class="hljs-built_in">AddDynamic</span>(<span class="hljs-keyword">this</span>, &amp;AUEDemo_DSProjectile::OnProjectileImpact);<br>&#125;<br><span class="hljs-comment">// 定义静态网格体</span><br><span class="hljs-function"><span class="hljs-type">static</span> ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; <span class="hljs-title">DefaultMesh</span><span class="hljs-params">(TEXT(<span class="hljs-string">&quot;/Game/StarterContent/Shapes/Shape_Sphere.Shape_Sphere&quot;</span>))</span></span>;<br>StaticMesh = <span class="hljs-built_in">CreateDefaultSubobject</span>&lt;UStaticMeshComponent&gt;(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;StaticMesh&quot;</span>));<br>StaticMesh-&gt;<span class="hljs-built_in">SetupAttachment</span>(RootComponent);<br><span class="hljs-keyword">if</span> (DefaultMesh.<span class="hljs-built_in">Succeeded</span>())<br>&#123;<br>StaticMesh-&gt;<span class="hljs-built_in">SetStaticMesh</span>(DefaultMesh.Object);<br>StaticMesh-&gt;<span class="hljs-built_in">SetRelativeLocation</span>(<span class="hljs-built_in">FVector</span>(<span class="hljs-number">0.f</span>, <span class="hljs-number">0.f</span>, <span class="hljs-number">-37.5f</span>));<br>StaticMesh-&gt;<span class="hljs-built_in">SetRelativeScale3D</span>(<span class="hljs-built_in">FVector</span>(<span class="hljs-number">0.75f</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-number">0.75f</span>));<br>&#125;<br><span class="hljs-comment">// 定义特效</span><br><span class="hljs-function"><span class="hljs-type">static</span> ConstructorHelpers::FObjectFinder&lt;UParticleSystem&gt; <span class="hljs-title">DefaultExplosionEffect</span><span class="hljs-params">(TEXT(<span class="hljs-string">&quot;/Game/StarterContent/Particles/P_Explosion.P_Explosion&quot;</span>))</span></span>;<br><span class="hljs-keyword">if</span> (DefaultExplosionEffect.<span class="hljs-built_in">Succeeded</span>())<br>&#123;<br>ExplosionEffect = DefaultExplosionEffect.Object;<br>&#125;<br><span class="hljs-comment">// 定义移动组件</span><br>ProjectileMovementComponent = <span class="hljs-built_in">CreateDefaultSubobject</span>&lt;UProjectileMovementComponent&gt;(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;ProjectileMovement&quot;</span>));<br>ProjectileMovementComponent-&gt;<span class="hljs-built_in">SetUpdatedComponent</span>(SphereComponent);<br>ProjectileMovementComponent-&gt;InitialSpeed = <span class="hljs-number">1500.f</span>;<br>ProjectileMovementComponent-&gt;MaxSpeed = <span class="hljs-number">1500.f</span>;<br>ProjectileMovementComponent-&gt;bRotationFollowsVelocity = <span class="hljs-literal">true</span>;<br>ProjectileMovementComponent-&gt;ProjectileGravityScale = <span class="hljs-number">0.f</span>;<br><span class="hljs-comment">// 定义伤害类型和伤害</span><br>DamageType = UDamageType::<span class="hljs-built_in">StaticClass</span>();<br>Damage = <span class="hljs-number">10.f</span>; <span class="hljs-comment">// 伤害数值</span><br></code></pre></td></tr></table></figure></li><li><p>伤害反馈<br>我们希望抛射物在命中时立即销毁并播放一个爆炸特效。重写 <code>Destoryed</code>方法，该方法在Actor销毁时调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Destroyed</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AUEDemo_DSProjectile::Destroyed</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  Super::<span class="hljs-built_in">Destroyed</span>();<br>  <span class="hljs-comment">// 销毁时播放爆炸特效</span><br>  FVector spawnLocation = <span class="hljs-built_in">GetActorLocation</span>();<br>  UGameplayStatics::<span class="hljs-built_in">SpawnEmitterAtLocation</span>(<span class="hljs-keyword">this</span>, ExplosionEffect, spawnLocation, FRotator::ZeroRotator, <span class="hljs-literal">true</span>, EPSCPoolMethod::AutoRelease);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>碰撞回调<br>声明并实现碰撞回调方法，并绑定碰撞回调，注意仅在服务器端绑定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 在头文件中做如下定义</span><br><span class="hljs-built_in">UFUNCTION</span>(Category=Projectile)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OnProjectileImpact</span><span class="hljs-params">(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComponent, FVector NormalImpulse, <span class="hljs-type">const</span> FHitResult&amp; Hit)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AUEDemo_DSProjectile::OnProjectileImpact</span><span class="hljs-params">(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComponent, FVector NormalImpulse, <span class="hljs-type">const</span> FHitResult&amp; Hit)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 碰撞回调</span><br>  <span class="hljs-keyword">if</span> (OtherActor)<br>  &#123;<br>  <span class="hljs-comment">// 应用伤害，最终会调用到TakeDamage函数</span><br>  UGameplayStatics::<span class="hljs-built_in">ApplyPointDamage</span>(OtherActor, Damage, NormalImpulse, Hit, <span class="hljs-built_in">GetInstigator</span>()-&gt;Controller, <span class="hljs-keyword">this</span>, DamageType);<br>  &#125;<br>  <span class="hljs-comment">// 销毁自身</span><br>  <span class="hljs-built_in">Destroy</span>();<br>&#125;<br><span class="hljs-comment">// 在构造方法中为SphereComponent绑定碰撞回调</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">HasAuthority</span>())<br>&#123; <span class="hljs-comment">// 仅在服务器端添加碰撞回调</span><br>  SphereComponent-&gt;OnComponentHit.<span class="hljs-built_in">AddDynamic</span>(<span class="hljs-keyword">this</span>, &amp;AUEDemo_DSProjectile::OnProjectileImpact);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建抛射物<br>在角色类 <code>AUEDemo_DSCharacter</code>中创建抛射物对象。<br>每一次设计，都会通过RPC调用到服务器的创建抛射物接口，为防止消息过于频繁，做了每个抛射物生成的延时机制，下面是关键代码：<br>在头文件中做如下声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">UPROPERTY</span>(EditDefaultsOnly, Category=<span class="hljs-string">&quot;Gameplay|Projectile&quot;</span>)<br>TSubclassOf&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">AUEDemo_DSProjectile</span>&gt; ProjectileClass;<br><br><span class="hljs-comment">/** 射击之间的延迟，单位为秒。用于控制测试发射物的射击速度，还可防止服务器函数的溢出导致将SpawnProjectile直接绑定至输入。*/</span><br><span class="hljs-built_in">UPROPERTY</span>(EditDefaultsOnly, Category=<span class="hljs-string">&quot;Gameplay&quot;</span>)<br><span class="hljs-type">float</span> FireRate;<br><br><span class="hljs-comment">/** 若为true，则正在发射投射物。*/</span><br><span class="hljs-type">bool</span> bIsFiringWeapon;<br><br><span class="hljs-comment">/** 用于启动武器射击的函数。*/</span><br><span class="hljs-built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="hljs-string">&quot;Gameplay&quot;</span>)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StartFire</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/** 用于结束武器射击的函数。一旦调用这段代码，玩家可再次使用StartFire。*/</span><br><span class="hljs-built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="hljs-string">&quot;Gameplay&quot;</span>)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StopFire</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/** 用于生成投射物的服务器函数。注意该方法声明为服务器RPC，需要实现名为HandleFire_Implementation的方法，客户端调用该方法实际是在服务器端运行。</span><br><span class="hljs-comment">本篇不对RPC做深入研究，只做了解。*/</span><br><span class="hljs-built_in">UFUNCTION</span>(Server, Reliable)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HandleFire</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/** 定时器句柄，用于提供生成间隔时间内的射速延迟。*/</span><br>FTimerHandle FiringTimer;<br></code></pre></td></tr></table></figure><p>在cpp中实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AUEDemo_DSCharacter::StartFire</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 按键绑定鼠标左键，这里忽略了绑定过程，可查看demo了解完整过程</span><br>  <span class="hljs-keyword">if</span> (!bIsFiringWeapon) <span class="hljs-comment">// 用该标记做防重入检测</span><br>  &#123;<br>    bIsFiringWeapon = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">GetWorld</span>()-&gt;<span class="hljs-built_in">GetTimerManager</span>().<span class="hljs-built_in">SetTimer</span>(FiringTimer, <span class="hljs-keyword">this</span>, &amp;AUEDemo_DSCharacter::StopFire, FireRate, <span class="hljs-literal">true</span>);<br>    <span class="hljs-built_in">HandleFire</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AUEDemo_DSCharacter::StopFire</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  bIsFiringWeapon = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AUEDemo_DSCharacter::HandleFire_Implementation</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 生成位置、旋转</span><br>  FVector spawnLocation = <span class="hljs-built_in">GetActorLocation</span>() + ( <span class="hljs-built_in">GetActorRotation</span>()  <span class="hljs-built_in">Vector</span>()  * <span class="hljs-number">100.0f</span> ) + (<span class="hljs-built_in">GetActorUpVector</span>() * <span class="hljs-number">50.0f</span>);<br>  FRotator spawnRotation = <span class="hljs-built_in">GetActorRotation</span>();<br>  <span class="hljs-comment">// 生成参数</span><br>  FActorSpawnParameters spawnParameters;<br>  spawnParameters.Instigator = <span class="hljs-built_in">GetInstigator</span>();<br>  spawnParameters.Owner = <span class="hljs-keyword">this</span>;<br>  <span class="hljs-comment">// 调用SpawnActor生成投射物</span><br>  AUEDemo_DSProjectile* spawnedProjectile = <span class="hljs-built_in">GetWorld</span>(  -&gt;<span class="hljs-built_in">SpawnActor</span>&lt;AUEDemo_DSProjectile&gt;(spawnLocation, spawnRotation,  spawnParameters);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>编译完成后，启动服务器和两个客户端，在客户端中，按下鼠标左键，可以看到生成一个抛射物并向前运动，直到发生了碰撞，销毁自身并播放了一个爆炸特效。<br>当碰撞到另外一个角色时，执行了 <code>UGameplayStatics::ApplyPointDamage()</code>,并传递至对方角色的 <code>AUEDemo_DSCharacter::TakeDamage()</code>方法，造成伤害后打印了伤害日志。</p><p>更加方便的启动测试方式（注：此种方式无需使用源码引擎，但默认会自动连接DS服务器，所以启动后无法看到登录界面）：</p><blockquote><p><a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/play-in-editor-multiplayer-options-in-unreal-engine">虚幻引擎中的在编辑器中运行多玩家选项 | 虚幻引擎 5.5 文档 | Epic Developer Community</a></p></blockquote><p>在模拟选项中，选择玩家数量为 <code>2</code>，网络模式为 <code>客户端模式</code>。</p><img src="/2024/12/16/link/UE/DS/1_%E5%88%9D%E8%AF%86DS/1_%E5%88%9D%E8%AF%86DS/1734358094230.png" class="" width="1734358094230"><p>打开高级设置，或 <code>编辑器偏好设置-&gt;多玩家选项</code>中做如下设置：</p><blockquote><p>注意要设置服务器地图命名重载为 <code>ThirdPersonMap</code>，启动参数为 <code>-server -log</code>。</p></blockquote><img src="/2024/12/16/link/UE/DS/1_%E5%88%9D%E8%AF%86DS/1_%E5%88%9D%E8%AF%86DS/1734358887796.png" class="" width="1734358887796"><p>设置完毕后，点击模拟播放：</p><img src="/2024/12/16/link/UE/DS/1_%E5%88%9D%E8%AF%86DS/1_%E5%88%9D%E8%AF%86DS/1734359143666.png" class="" width="1734359143666"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本篇文档，可以对DS做一个初步的入门了解（建议参照文档实操一下），因为只是入门文档，所以没有做深入的技术研究。</p><p>后续将会以网络开发为主题，对Actor复制和RPC、GamePlay、UE网络模块、DS优化、完整的服务器拓扑结构等进行较为深入的学习。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/yangxuan0261/article/details/54766957">ue4-Network相关-Client和Server的区分_ue4 client server-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_39108291/article/details/119619482">【UE5】UE5 Dedicated Server专用服务器与网络同步-CSDN博客</a></p><p><a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/play-in-editor-multiplayer-options-in-unreal-engine">虚幻引擎中的在编辑器中运行多玩家选项 | 虚幻引擎 5.5 文档 | Epic Developer Community</a></p>]]></content>
    
    
    <categories>
      
      <category>UE</category>
      
      <category>UE多人游戏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE</tag>
      
      <tag>Dedicated Server</tag>
      
      <tag>网络开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【UE-C++】类型系统</title>
    <link href="/2023/05/16/link/UE/UE-C++/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/05/16/link/UE/UE-C++/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="UE的类型系统-UObject"><a href="#UE的类型系统-UObject" class="headerlink" title="UE的类型系统-UObject"></a>UE的类型系统-UObject</h1><p><em><strong>本篇为<a href="https://zhuanlan.zhihu.com/insideue4">InsideUE5</a>系列UObject相关博文的个人学习整理笔记，原作者为：<a href="https://www.zhihu.com/people/fjz13">大钊 - 知乎 (zhihu.com)</a></strong></em></p><p>作者为虚幻引擎大中华区社区经理，这篇UObject系列从源码层面深度解析了UnrealEngine的类型系统。</p><p>原文中的源码分析基于4.14.2版本，当前最新版本为5.1，文中描述的一些实现已经过时，本篇在学习系列文章的同时，针对5.1版本的实现进行调整及补充。</p><p>类型系统构建的阶段分为：</p><ul><li>生成：UHT分析源码的宏标记生成了包含程序原信息的代码，继而编译进程序</li><li>收集：在程序启动的时候，类型系统进行类型信息的收集</li><li>注册：利用收集的信息进行注册</li><li>构造：往对象里填充属性、函数、接口和元数据的信息。</li><li>绑定链接：优化一下存储结构，为以后的使用提供更高性能和便利。</li><li>CDO创建：每个UClass都有一个CDO（Class Default Object），有了CDO，相当于有了一个存档备份和参照。</li><li>引用记号流构建：一个Class是怎么样有可能引用其他别的对象的，这棵引用树怎么样构建的高效，也是GC中一个非常重要的话题。有了引用记号流，就可以对一个对象高效的分析它引用了其他多少对象。</li></ul><h2 id="UObject（一）开篇"><a href="#UObject（一）开篇" class="headerlink" title="UObject（一）开篇"></a><a href="https://zhuanlan.zhihu.com/p/24319968">UObject（一）开篇</a></h2><p>引入Object的根基类设计的优缺点：</p><ul><li>优点<ul><li>万物可追踪<br>有了一个统一的基类Object，就可以根据一个Object类型指针追踪到所有的派生对象。</li><li>通用的属性和接口（继承机制）</li><li>统一的内存分配释放<br>引用计数的方案，可以在Object上添加Retain+1&#x2F;Release-1的接口；用GC的方案，有统一的Object可以引用。</li><li>统一的序列化模型<br>结合良好的反射机制，在Object上实现统一的序列化代码。</li><li>调试的便利<br>将任意对象转换为Object，就可以查看对象属性了。</li><li>为反射提供便利<br>统一的Object，方便实现GetType接口</li><li>UI编辑的便利</li></ul></li><li>缺点<ul><li>臃肿的Object</li><li>不必要的内存负担</li><li>多重继承的限制<br>一般有Object基类的编程语言，都是直接限制多重继承，改为多重实现接口。因为基类都是Object，会继承多份。</li><li>类型系统的割裂<br>原生C++类型和Object类型交叉引用、互相加载释放、消息通信、内存分配等机制和规则不一样。</li></ul></li><li>设计上的权衡<ul><li>针对太过复杂的Object基类，暂没有优化</li><li>sizeof(UObject)&#x3D;&#x3D;56</li><li>规避多重继承</li><li>需要开发中多加学习</li></ul></li></ul><h2 id="UObject（二）类型系统概述"><a href="#UObject（二）类型系统概述" class="headerlink" title="UObject（二）类型系统概述"></a><a href="https://zhuanlan.zhihu.com/p/24445322">UObject（二）类型系统概述</a></h2><h3 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h3><p>用 <code>类型系统</code>来表述Object之外的类型信息构建，用 <code>反射</code>来描述运行时得到类型的功能，通过类型信息反过来创建对象，读取修改属性，调用方法的功能行为。反射更多是一种行为能力，会让你更偏向动词。类型系统指的是程序运行空间内构建出来的类型信息组织。</p><h3 id="UHT方案"><a href="#UHT方案" class="headerlink" title="UHT方案"></a>UHT方案</h3><p>UHT即UnrealHeadTools。<br>在C++源文件中空的宏做标记，然后用UHT分析生成generated.h&#x2F;gen.cpp文件，之后在一起编译。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">UCLASS</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HELLO_API</span> UMyClass : <span class="hljs-keyword">public</span> UObject<br>&#123;<br><span class="hljs-built_in">GENERATED_BODY</span>()<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">UPROPERTY</span>(BlueprintReadWrite, Category=<span class="hljs-string">&quot;Test&quot;</span>)<br><span class="hljs-function"><span class="hljs-type">float</span> Score</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">UFUNCTION</span><span class="hljs-params">(BlueprintCallable, Category = <span class="hljs-string">&quot;Test&quot;</span>)</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CallableFuncTest</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-built_in">UFUNCTION</span>(BlueprintNativeEvent, Category = <span class="hljs-string">&quot;Test&quot;</span>)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NativeFuncTest</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-built_in">UFUNCTION</span>(BlueprintImplementableEvent, Category = <span class="hljs-string">&quot;Test&quot;</span>)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ImplementableFuncTest</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="UObject（三）类型系统设定和结构"><a href="#UObject（三）类型系统设定和结构" class="headerlink" title="UObject（三）类型系统设定和结构"></a><a href="https://zhuanlan.zhihu.com/p/24790386">UObject（三）类型系统设定和结构</a></h2><h3 id="UE里的宏标记"><a href="#UE里的宏标记" class="headerlink" title="UE里的宏标记"></a>UE里的宏标记</h3><p>大体上都是一些空宏。有两个重点：</p><ul><li>可以通过给类、枚举、属性、函数加上特定的宏来标记更多的元数据</li><li>在有必要的时候，这些标记宏甚至也可以安插进生成的代码来合成编译</li></ul><p>标记了宏，生成的代码为 <code>xxx.generated.h</code>、<code>xxx.gen.cpp</code>。<br>假如我们为A类生成了 <code>A.generated.h</code>和 <code>A.gen.cpp</code>，此时 <code>A.h</code>需要 <code>#include &quot;A.generated.h&quot;</code>而且规定是最后一个include。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> UPROPERTY(...)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UFUNCTION(...)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> USTRUCT(...)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UMETA(...)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UPARAM(...)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UENUM(...)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UDELEGATE(...)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RIGVM_METHOD(...)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UCLASS(...) BODY_MACRO_COMBINE(CURRENT_FILE_ID,_,__LINE__,_PROLOG)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UINTERFACE(...) UCLASS()</span><br></code></pre></td></tr></table></figure><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><img src="/2023/05/16/link/UE/UE-C++/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F-%E7%B1%BB%E5%9B%BE.svg" class="" title="结构关系"><ul><li>聚合类型UStruct)<ul><li>UFunction，只可包含属性作为函数的输入输出参数宏</li><li>UScriptStruct，只可包含属性。可以看做一个轻量的UObject，拥有和UObject一样的反射支持，序列化，复制等。但是其不受GC控制，需要自己控制内存分配和释放</li><li>UClass，可包含属性和函数</li></ul></li><li>原子类型<ul><li>UEnum，支持普通枚举和enum class</li><li>int，FString等基础类型没必要特别声明</li></ul></li></ul><p>把聚合类型统一起来，就形成了UStruct基类，可以把一些通用的添加属性等方法放在里面，同时可以实现继承。</p><p>UInterface比较特殊，可以继承多个接口。跟C++中的虚类一样，不同的是UE中的接口只可以包含函数。继承与UInterface作为一个接口，但是生成的类型数据依然用UClass存储。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> UINTERFACE(...) UCLASS()</span><br></code></pre></td></tr></table></figure><p>FProperty是定义，可以理解为用一个类型定义一个字段”type instance;”。<br><em>UE4.25将UProporty变成了FProproty。因为UProperty继承了UObject，而整个UE框架下的类中会有大量的属性，导致UProperty的构建&#x2F;消耗成本很高，影响垃圾回收性能。<a href="https://zhuanlan.zhihu.com/p/380610877">UE4 FProperty - 知乎 (zhihu.com)</a></em></p><p>元数据UMetaData其实就是个TMap&lt;FName,FString&gt;的键值对，用于为编辑器提供分类、友好名字、提示信息等，最终发布时不会包含此信息。</p><h3 id="为什么需要基类UField？"><a href="#为什么需要基类UField？" class="headerlink" title="为什么需要基类UField？"></a>为什么需要基类UField？</h3><ol><li>统一类型数据。相同的基类，可以存储在一个数组中，保证定义顺序;</li><li>在基类中维护元数据UMetaData;</li><li>方便添加一些额外方法;</li></ol><p><em><strong>个人觉得主要还是分层思想的体现</strong></em></p><h3 id="为什么UField要继承于UObject"><a href="#为什么UField要继承于UObject" class="headerlink" title="为什么UField要继承于UObject"></a>为什么UField要继承于UObject</h3><p>继承UObject的能力：GC、反射、编辑器继承、序列化等。另外UE的一切皆Object思想。</p><hr><h2 id="UObject（四）类型系统代码生成"><a href="#UObject（四）类型系统代码生成" class="headerlink" title="UObject（四）类型系统代码生成"></a><a href="https://zhuanlan.zhihu.com/p/25098685">UObject（四）类型系统代码生成</a></h2><h3 id="UHT代码生成"><a href="#UHT代码生成" class="headerlink" title="UHT代码生成"></a>UHT代码生成</h3><p>在C++程序中的预处理是用来对源代码进行宏展，预编译指令处理，注释删除等操作。一旦我们采用了宏标记的方法，我们都需要进行简单或复杂的词法分析，提取出有用的信息，然后生成所需要的代码。</p><ul><li>FileName.generated.h</li><li>FileName.gen.cpp</li><li>FileName.init.gen.cpp</li></ul><blockquote><p>生成的函数大多以Z_开头，其实没什么特别的含义，用Z是为了字母排序总是出现在各种IDE的智能感知最下面，尽量隐藏起来。</p></blockquote><h3 id="UCLASS的生成代码剖析"><a href="#UCLASS的生成代码剖析" class="headerlink" title="UCLASS的生成代码剖析"></a>UCLASS的生成代码剖析</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CoreMinimal.h&quot;</span><span class="hljs-comment">// 通用基础头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UObject/Object.h&quot;</span><span class="hljs-comment">// UObject等相关定义</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MyClass.generated.h&quot;</span><span class="hljs-comment">// UHT生成的头文件，必须是最后一个include，避免宏依赖顺序的问题</span></span><br><br><span class="hljs-built_in">UCLASS</span>() <span class="hljs-comment">// 标记宏</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UOBJECTLEARN_API</span> UMyClass : <span class="hljs-keyword">public</span> UObject<br>&#123;<br><span class="hljs-built_in">GENERATED_BODY</span>() <span class="hljs-comment">// 展开调用了MyClass.generated.h中定义的宏</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="生成的头文件"><a href="#生成的头文件" class="headerlink" title="生成的头文件"></a>生成的头文件</h4><h5 id="GENERATED-BODY"><a href="#GENERATED-BODY" class="headerlink" title="GENERATED_BODY"></a>GENERATED_BODY</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BODY_MACRO_COMBINE_INNER(A,B,C,D) A##B##C##D</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BODY_MACRO_COMBINE(A,B,C,D) BODY_MACRO_COMBINE_INNER(A,B,C,D)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GENERATED_BODY(...) BODY_MACRO_COMBINE(CURRENT_FILE_ID,_,__LINE__,_GENERATED_BODY);</span><br></code></pre></td></tr></table></figure><p>生成另外一个宏的名称，这个宏就定义在MyClass.generated.h中。</p><p><strong>CURRENT_FILE_ID</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CURRENT_FILE_ID \</span><br><span class="hljs-meta">FID_unreal_learning_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyClass_h</span><br></code></pre></td></tr></table></figure><p>最终生成的<strong>宏名称</strong>为：<br><code>FID_unreal_learning_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyClass_h_15_GENERATED_BODY</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> FID_unreal_learning_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyClass_h_15_GENERATED_BODY \</span><br><span class="hljs-meta">PRAGMA_DISABLE_DEPRECATION_WARNINGS \</span><br><span class="hljs-meta">public: \</span><br><span class="hljs-meta">FID_unreal_learning_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyClass_h_15_SPARSE_DATA \</span><br><span class="hljs-meta">FID_unreal_learning_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyClass_h_15_RPC_WRAPPERS_NO_PURE_DECLS \</span><br><span class="hljs-meta">FID_unreal_learning_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyClass_h_15_ACCESSORS \</span><br><span class="hljs-meta">FID_unreal_learning_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyClass_h_15_INCLASS_NO_PURE_DECLS \</span><br><span class="hljs-meta">FID_unreal_learning_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyClass_h_15_ENHANCED_CONSTRUCTORS \</span><br><span class="hljs-meta">private: \</span><br><span class="hljs-meta">PRAGMA_ENABLE_DEPRECATION_WARNINGS</span><br></code></pre></td></tr></table></figure><p>其中public下的前三个宏实现为空。</p><p><strong>INCLASS_NO_PURE_DECLS</strong></p><p>定义类的基本方法，包括：</p><ul><li>StaticClass系列</li><li>重载new、delete方法</li><li>序列化方法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> FID_unreal_learning_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyClass_h_15_INCLASS_NO_PURE_DECLS \</span><br><span class="hljs-meta">private: \</span><br><span class="hljs-meta">static void StaticRegisterNativesUMyClass(); \</span><br><span class="hljs-meta">friend struct Z_Construct_UClass_UMyClass_Statics; \</span><br><span class="hljs-meta">public: \</span><br><span class="hljs-meta">DECLARE_CLASS(UMyClass, UObject, COMPILED_IN_FLAGS(0), CASTCLASS_None, TEXT(<span class="hljs-string">&quot;/Script/UObjectLearn&quot;</span>), NO_API) \</span><br><span class="hljs-meta">DECLARE_SERIALIZER(UMyClass)</span><br></code></pre></td></tr></table></figure><ul><li><p>StaticRegisterNativesUMyClass：定义了注册类型的静态方法</p></li><li><p>DECLARE_CLASS：声明类</p><ul><li>TClass： 类名</li><li>TSuperClass：基类名字</li><li>TStaticFlag：类的属性标记，见EClassFlags</li><li>TStaticCastFlags：指定了该类可以转换为哪些类，见EClassCastFlags</li><li>TPackage：包名。所有对象必须处于一个包中，每个包都有一个名字。这里是”&#x2F;Script&#x2F;UObjectLearn”(工程下的一个Plugin名字)</li><li>TRequiredAPI：导入DLL标记，这里是NO_API，不需要导出。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DECLARE_CLASS( TClass, TSuperClass, TStaticFlags, TStaticCastFlags, TPackage, TRequiredAPI  ) \</span><br><span class="hljs-meta">private: \</span><br><span class="hljs-meta">    TClass&amp; operator=(TClass&amp;&amp;);   \</span><br><span class="hljs-meta">    TClass&amp; operator=(const TClass&amp;);   \</span><br><span class="hljs-meta">TRequiredAPI static UClass* GetPrivateStaticClass(); \</span><br><span class="hljs-meta">public: \</span><br><span class="hljs-meta"><span class="hljs-comment">/** Bitwise union of #EClassFlags pertaining to this class.*/</span> \</span><br><span class="hljs-meta">enum &#123;StaticClassFlags=TStaticFlags&#125;; \</span><br><span class="hljs-meta"><span class="hljs-comment">/** Typedef for the base class (&#123;&#123; typedef-type &#125;&#125;) */</span> \</span><br><span class="hljs-meta">typedef TSuperClass Super;\</span><br><span class="hljs-meta"><span class="hljs-comment">/** Typedef for &#123;&#123; typedef-type &#125;&#125;. */</span> \</span><br><span class="hljs-meta">typedef TClass ThisClass;\</span><br><span class="hljs-meta"><span class="hljs-comment">/** Returns a UClass object representing this class at runtime */</span> \</span><br><span class="hljs-meta">inline static UClass* StaticClass() \</span><br><span class="hljs-meta">&#123; \</span><br><span class="hljs-meta">return GetPrivateStaticClass(); \</span><br><span class="hljs-meta">&#125; \</span><br><span class="hljs-meta"><span class="hljs-comment">/** Returns the package this class belongs in */</span> \</span><br><span class="hljs-meta">inline static const TCHAR* StaticPackage() \</span><br><span class="hljs-meta">&#123; \</span><br><span class="hljs-meta">return TPackage; \</span><br><span class="hljs-meta">&#125; \</span><br><span class="hljs-meta"><span class="hljs-comment">/** Returns the static cast flags for this class */</span> \</span><br><span class="hljs-meta">inline static EClassCastFlags StaticClassCastFlags() \</span><br><span class="hljs-meta">&#123; \</span><br><span class="hljs-meta">return TStaticCastFlags; \</span><br><span class="hljs-meta">&#125; \</span><br><span class="hljs-meta"><span class="hljs-comment">/** For internal use only; use StaticConstructObject() to create new objects. */</span> \</span><br><span class="hljs-meta">inline void* operator new(const size_t InSize, EInternal InInternalOnly, UObject* InOuter = (UObject*)GetTransientPackage(), FName InName = NAME_None, EObjectFlags InSetFlags = RF_NoFlags) \</span><br><span class="hljs-meta">&#123; \</span><br><span class="hljs-meta">return StaticAllocateObject(StaticClass(), InOuter, InName, InSetFlags); \</span><br><span class="hljs-meta">&#125; \</span><br><span class="hljs-meta"><span class="hljs-comment">/** For internal use only; use StaticConstructObject() to create new objects. */</span> \</span><br><span class="hljs-meta">inline void* operator new( const size_t InSize, EInternal* InMem ) \</span><br><span class="hljs-meta">&#123; \</span><br><span class="hljs-meta">return (void*)InMem; \</span><br><span class="hljs-meta">&#125; \</span><br><span class="hljs-meta"><span class="hljs-comment">/* Eliminate V1062 warning from PVS-Studio while keeping MSVC and Clang happy. */</span> \</span><br><span class="hljs-meta">inline void operator delete(void* InMem) \</span><br><span class="hljs-meta">&#123; \</span><br><span class="hljs-meta">::operator delete(InMem); \</span><br><span class="hljs-meta">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>DECLARE_SERIALIZER：声明序列化方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DECLARE_SERIALIZER( TClass ) \</span><br><span class="hljs-meta">friend FArchive &amp;operator&lt;&lt;( FArchive&amp; Ar, TClass*&amp; Res ) \</span><br><span class="hljs-meta">&#123; \</span><br><span class="hljs-meta">return Ar &lt;&lt; (UObject*&amp;)Res; \</span><br><span class="hljs-meta">&#125; \</span><br><span class="hljs-meta">friend void operator&lt;&lt;(FStructuredArchive::FSlot InSlot, TClass*&amp; Res) \</span><br><span class="hljs-meta">&#123; \</span><br><span class="hljs-meta">InSlot &lt;&lt; (UObject*&amp;)Res; \</span><br><span class="hljs-meta">&#125;</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>ENHANCED_CONSTRUCTORS</strong></p><p>定义构造、析构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> FID_unreal_learning_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyClass_h_15_ENHANCED_CONSTRUCTORS \</span><br><span class="hljs-meta"><span class="hljs-comment">/** Standard constructor, called after all reflected properties have been initialized */</span> \</span><br><span class="hljs-meta">NO_API UMyClass(const FObjectInitializer&amp; ObjectInitializer = FObjectInitializer::Get()) : Super(ObjectInitializer) &#123; &#125;; \</span><br><span class="hljs-meta">private: \</span><br><span class="hljs-meta"><span class="hljs-comment">/** Private move- and copy-constructors, should never be used */</span> \</span><br><span class="hljs-meta">NO_API UMyClass(UMyClass&amp;&amp;); \</span><br><span class="hljs-meta">NO_API UMyClass(const UMyClass&amp;); \</span><br><span class="hljs-meta">public: \</span><br><span class="hljs-meta">DECLARE_VTABLE_PTR_HELPER_CTOR(NO_API, UMyClass); \</span><br><span class="hljs-meta">DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER(UMyClass); \</span><br><span class="hljs-meta">DEFINE_DEFAULT_OBJECT_INITIALIZER_CONSTRUCTOR_CALL(UMyClass) \</span><br><span class="hljs-meta">NO_API virtual ~UMyClass();</span><br></code></pre></td></tr></table></figure><ul><li><p>DECLARE_VTABLE_PTR_HELPER_CTOR(NO_API, UMyClass); &#x2F;&#x2F; 仅用于内部热重载(<a href="https://unrealcommunity.wiki/live-compiling-in-unreal-projects-tp14jcgs">hot-reload</a>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DECLARE_VTABLE_PTR_HELPER_CTOR(API, TClass) \</span><br><span class="hljs-meta"><span class="hljs-comment">/** DO NOT USE. This constructor is for internal usage only for hot-reload purposes. */</span> \</span><br><span class="hljs-meta">API TClass(FVTableHelper&amp; Helper);</span><br></code></pre></td></tr></table></figure></li><li><p>DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER(UMyClass); &#x2F;&#x2F; 仅用于内部热重载(hot-reload)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">if</span> WITH_RELOAD &amp;&amp; !CHECK_PUREVIRTUALS</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER(TClass) \</span><br><span class="hljs-meta">static UObject* __VTableCtorCaller(FVTableHelper&amp; Helper) \</span><br><span class="hljs-meta">&#123; \</span><br><span class="hljs-meta">return new (EC_InternalUseOnlyConstructor, (UObject*)GetTransientPackage(), NAME_None, RF_NeedLoad | RF_ClassDefaultObject | RF_TagGarbageTemp) TClass(Helper); \</span><br><span class="hljs-meta">&#125;</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">// WITH_RELOAD &amp;&amp; !CHECK_PUREVIRTUALS</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER(TClass) \</span><br><span class="hljs-meta">DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER_DUMMY()</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// WITH_RELOAD &amp;&amp; !CHECK_PUREVIRTUALS</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER_DUMMY() \</span><br><span class="hljs-meta">static UObject* __VTableCtorCaller(FVTableHelper&amp; Helper) \</span><br><span class="hljs-meta">&#123; \</span><br><span class="hljs-meta">return nullptr; \</span><br><span class="hljs-meta">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>DEFINE_DEFAULT_OBJECT_INITIALIZER_CONSTRUCTOR_CALL(UMyClass)</p><ul><li>__DefaultConstructor<br>可将FObjectInitializer中的UObject(GetObject())转化为UMyClass对象，可见StaticClass方法的实现中调用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFINE_DEFAULT_OBJECT_INITIALIZER_CONSTRUCTOR_CALL(TClass) \</span><br><span class="hljs-meta">static void __DefaultConstructor(const FObjectInitializer&amp; X) &#123; new((EInternal*)X.GetObj())TClass(X); &#125;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="生成的实现"><a href="#生成的实现" class="headerlink" title="生成的实现"></a>生成的实现</h4><ul><li>IMPLEMENT_CLASS_NO_AUTO_REGISTRATION<br>实现了 <code>GetPrivateStaticClass</code>方法，调用了 <code>GetPrivateStaticClassBody</code>方法，通过反射，获得了 <code>UClass</code>对象</li><li>特化了StaticClass函数模板<br><code>template&lt;&gt; UOBJECTLEARN_API UClass* StaticClass&lt;UMyClass&gt;()</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 引用CoreUObject里的函数，主要是为了得到UObject本身对应的UClass</span><br><span class="hljs-function">COREUOBJECT_API UClass* <span class="hljs-title">Z_Construct_UClass_UObject</span><span class="hljs-params">()</span></span>&#123;...&#125;<br><span class="hljs-comment">// 构造UMyClass对应的UClass对象</span><br><span class="hljs-function">UOBJECTLEARN_API UClass* <span class="hljs-title">Z_Construct_UClass_UMyClass</span><span class="hljs-params">()</span></span>&#123;...&#125;<br><span class="hljs-comment">// 构造UMyClass对应的UClass对象，区别是没有后续的注册过程</span><br><span class="hljs-function">UOBJECTLEARN_API UClass* <span class="hljs-title">Z_Construct_UClass_UMyClass_NoRegister</span><span class="hljs-params">()</span></span>&#123;...&#125;<br><span class="hljs-comment">// UObjectLearn.init.gen.cpp中实现，通过UECodeGen_Private::ConstructUPackage构造UPackage</span><br><span class="hljs-function">UPackage* <span class="hljs-title">Z_Construct_UPackage__Script_UObjectLearn</span><span class="hljs-params">()</span></span>&#123;...&#125;<br><span class="hljs-comment">// 创建UClass*</span><br><span class="hljs-function">UClass* <span class="hljs-title">UMyClass::GetPrivateStaticClass</span><span class="hljs-params">()</span></span>&#123;...&#125;<br><span class="hljs-comment">// 对象注册，调用RegisterCompiledInInfo</span><br><span class="hljs-function"><span class="hljs-type">static</span> FRegisterCompiledInInfo <span class="hljs-title">Z_CompiledInDeferFile_FID_unreal_learning_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyClass_h_2018255607</span><span class="hljs-params">(TEXT(<span class="hljs-string">&quot;/Script/UObjectLearn&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">Z_CompiledInDeferFile_FID_unreal_learning_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyClass_h_Statics::ClassInfo, UE_ARRAY_COUNT(Z_CompiledInDeferFile_FID_unreal_learning_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyClass_h_Statics::ClassInfo),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>IMPLEMENT_CLASS_NO_AUTO_REGISTRATION</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMPLEMENT_CLASS_NO_AUTO_REGISTRATION(TClass) \</span><br><span class="hljs-meta">FClassRegistrationInfo Z_Registration_Info_UClass_##TClass; \</span><br><span class="hljs-meta">UClass* TClass::GetPrivateStaticClass() \</span><br><span class="hljs-meta">&#123; \</span><br><span class="hljs-meta"><span class="hljs-keyword">if</span> (!Z_Registration_Info_UClass_##TClass.InnerSingleton) \</span><br><span class="hljs-meta">&#123; \</span><br><span class="hljs-meta"><span class="hljs-comment">/* this could be handled with templates, but we want it external to avoid code bloat */</span> \</span><br><span class="hljs-meta">GetPrivateStaticClassBody( \</span><br><span class="hljs-meta">StaticPackage(), \</span><br><span class="hljs-meta">(TCHAR*)TEXT(#TClass) + 1 + ((StaticClassFlags &amp; CLASS_Deprecated) ? 11 : 0), \</span><br><span class="hljs-meta">Z_Registration_Info_UClass_##TClass.InnerSingleton, \</span><br><span class="hljs-meta">StaticRegisterNatives##TClass, \</span><br><span class="hljs-meta">sizeof(TClass), \</span><br><span class="hljs-meta">alignof(TClass), \</span><br><span class="hljs-meta">(EClassFlags)TClass::StaticClassFlags, \</span><br><span class="hljs-meta">TClass::StaticClassCastFlags(), \</span><br><span class="hljs-meta">TClass::StaticConfigName(), \</span><br><span class="hljs-meta">(UClass::ClassConstructorType)InternalConstructor<span class="hljs-string">&lt;TClass&gt;</span>, \</span><br><span class="hljs-meta">(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<span class="hljs-string">&lt;TClass&gt;</span>, \</span><br><span class="hljs-meta">UOBJECT_CPPCLASS_STATICFUNCTIONS_FORCLASS(TClass), \</span><br><span class="hljs-meta">&amp;TClass::Super::StaticClass, \</span><br><span class="hljs-meta">&amp;TClass::WithinClass::StaticClass \</span><br><span class="hljs-meta">); \</span><br><span class="hljs-meta">&#125; \</span><br><span class="hljs-meta">return Z_Registration_Info_UClass_##TClass.InnerSingleton; \</span><br><span class="hljs-meta">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="UCLASS中的字段和函数"><a href="#UCLASS中的字段和函数" class="headerlink" title="UCLASS中的字段和函数"></a>UCLASS中的字段和函数</h4><p>在MyClass.h中添加字段和函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">UCLASS</span>(BlueprintType)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UOBJECTLEARN_API</span> UMyClass : <span class="hljs-keyword">public</span> UObject<br>&#123;<br><span class="hljs-built_in">GENERATED_BODY</span>()<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">UPROPERTY</span>(BlueprintReadWrite)<br><span class="hljs-type">float</span> Score;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="hljs-string">&quot;UObjectLearn&quot;</span>)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CallableFunc</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//C++实现，蓝图调用</span><br><br><span class="hljs-built_in">UFUNCTION</span>(BlueprintNativeEvent, Category = <span class="hljs-string">&quot;UObjectLearn&quot;</span>)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NativeFunc</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//C++实现默认版本，蓝图可重载实现</span><br><br><span class="hljs-built_in">UFUNCTION</span>(BlueprintImplementableEvent, Category = <span class="hljs-string">&quot;UObjectLearn&quot;</span>)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ImplementableFunc</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">//C++不实现，蓝图实现</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在MyClass.cpp中实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UMyClass::CallableFunc</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UMyClass::NativeFunc_Implementation</span><span class="hljs-params">()</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>对比没有字段和函数的UCLASS生成，增加了 <code>RPC_WRAPPERS</code>和 <code>RPC_WRAPPERS_NO_PURE_DECLS</code>宏的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> FID_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyClass_h_15_RPC_WRAPPERS \</span><br><span class="hljs-meta">virtual void NativeFunc_Implementation(); \ <span class="hljs-comment">// 默认实现的函数声明，可以自己声明，则这里不会出现该函数声明</span></span><br> \<br><span class="hljs-built_in">DECLARE_FUNCTION</span>(execNativeFunc); \ <span class="hljs-comment">// 声明供蓝图调用的函数</span><br><span class="hljs-built_in">DECLARE_FUNCTION</span>(execCallableFunc); <span class="hljs-comment">// 声明供蓝图调用的函数</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FID_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyClass_h_15_RPC_WRAPPERS_NO_PURE_DECLS \</span><br><span class="hljs-meta">virtual void NativeFunc_Implementation(); \ <span class="hljs-comment">// 默认实现的函数声明，可以自己声明，则这里不会出现该函数声明</span></span><br> \<br><span class="hljs-built_in">DECLARE_FUNCTION</span>(execNativeFunc); \ <span class="hljs-comment">// 声明供蓝图调用的函数</span><br><span class="hljs-built_in">DECLARE_FUNCTION</span>(execCallableFunc); <span class="hljs-comment">// 声明供蓝图调用的函数</span><br></code></pre></td></tr></table></figure><p>其中 <code>DECLARE_FUNCTION</code>的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DECLARE_FUNCTION(func) static void func( UObject* Context, FFrame&amp; Stack, RESULT_DECL )</span><br></code></pre></td></tr></table></figure><p>对比没有字段和函数的UCLASS生成，MyClass.gen.cpp中的变化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 实现为蓝图调用的函数execNativeFunc</span><br>DEFINE_FUNCTION(UMyClass::execNativeFunc)&#123;...<span class="hljs-comment">// 调用NativeFunc_Implementation()&#125;</span><br><span class="hljs-comment">// 实现为蓝图调用的函数execCallableFunc</span><br>DEFINE_FUNCTION(UMyClass::execCallableFunc) &#123;...<span class="hljs-comment">// 调用CallableFunc()&#125;</span><br><span class="hljs-comment">// 函数名字定义</span><br><span class="hljs-type">static</span> FName NAME_UMyClass_ImplementableFunc = FName(TEXT(<span class="hljs-string">&quot;ImplementableFunc&quot;</span>));<br><span class="hljs-type">void</span> <span class="hljs-title function_">UMyClass::ImplementableFunc</span><span class="hljs-params">()</span>&#123;...&#125; <span class="hljs-comment">// c++的默认实现，主要为了编译通过</span><br><span class="hljs-comment">// 函数名字定义</span><br><span class="hljs-type">static</span> FName NAME_UMyClass_NativeFunc = FName(TEXT(<span class="hljs-string">&quot;NativeFunc&quot;</span>));<br><span class="hljs-type">void</span> <span class="hljs-title function_">UMyClass::NativeFunc</span><span class="hljs-params">()</span>&#123;...&#125; <span class="hljs-comment">// c++的默认实现，主要为了编译通过</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">UMyClass::StaticRegisterNativesUMyClass</span><span class="hljs-params">()</span>&#123;...&#125; <span class="hljs-comment">// 注册函数信息CallableFunc、NativeFunc</span><br><span class="hljs-comment">// 三个方法的UFunction*生成方法</span><br>UFunction* <span class="hljs-title function_">Z_Construct_UFunction_UMyClass_CallableFunc</span><span class="hljs-params">()</span> &#123;...&#125;<br>UFunction* <span class="hljs-title function_">Z_Construct_UFunction_UMyClass_ImplementableFunc</span><span class="hljs-params">()</span> &#123;...&#125;<br>UFunction* <span class="hljs-title function_">Z_Construct_UFunction_UMyClass_NativeFunc</span><span class="hljs-params">()</span> &#123;...&#125;<br><span class="hljs-comment">// 将三个方法和一个属性填到UClass中</span><br><span class="hljs-type">const</span> UECodeGen_Private::FClassParams Z_Construct_UClass_UMyClass_Statics::ClassParams = &#123;<br>&amp;UMyClass::StaticClass,<br>nullptr,<br>&amp;StaticCppClassTypeInfo,<br>DependentSingletons,<br>FuncInfo, <span class="hljs-comment">// 方法信息</span><br>Z_Construct_UClass_UMyClass_Statics::PropPointers, <span class="hljs-comment">// 成员信息</span><br>nullptr,<br>UE_ARRAY_COUNT(DependentSingletons),<br>UE_ARRAY_COUNT(FuncInfo),<br>UE_ARRAY_COUNT(Z_Construct_UClass_UMyClass_Statics::PropPointers),<br><span class="hljs-number">0</span>,<br><span class="hljs-number">0x001000A0</span>u,<br>METADATA_PARAMS(Z_Construct_UClass_UMyClass_Statics::Class_MetaDataParams, UE_ARRAY_COUNT(Z_Construct_UClass_UMyClass_Statics::Class_MetaDataParams))<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="完整展开"><a href="#完整展开" class="headerlink" title="完整展开"></a>完整展开</h4><h5 id="MyClass-h"><a href="#MyClass-h" class="headerlink" title="MyClass.h"></a><strong>MyClass.h</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">UCLASS</span>(BlueprintType)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UOBJECTLEARN_API</span> UMyClass : <span class="hljs-keyword">public</span> UObject<br>&#123;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// BlueprintImplementableEvent 实现的默认声明</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">NativeFunc_Implementation</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 为NativeFunc声明供蓝图调用的函数 </span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">execNativeFunc</span><span class="hljs-params">(UObject* Context, FFrame&amp; Stack, <span class="hljs-type">void</span>* <span class="hljs-type">const</span> Z_Param__Result)</span></span>;<br><span class="hljs-comment">// 为CallableFunc声明供蓝图调用的函数 </span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">execCallableFunc</span><span class="hljs-params">(UObject* Context, FFrame&amp; Stack, <span class="hljs-type">void</span>* <span class="hljs-type">const</span> Z_Param__Result)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 注册相关信息（如函数）</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">StaticRegisterNativesUMyClass</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 定义了一些UECodeGen_Private相关类型的结构信息</span><br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Z_Construct_UClass_UMyClass_Statics</span>;<br><br><span class="hljs-keyword">private</span>:<br>UMyClass&amp; <span class="hljs-keyword">operator</span>=(UMyClass&amp;&amp;);<br>UMyClass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> UMyClass&amp;);<br><span class="hljs-comment">// StaticClass()内部调用的就是这个函数</span><br><span class="hljs-function"><span class="hljs-type">static</span> UClass* <span class="hljs-title">GetPrivateStaticClass</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">enum</span> &#123; StaticClassFlags = (<span class="hljs-number">0</span> | CLASS_Intrinsic) &#125;; <span class="hljs-comment">// EClassFlags::CLASS_Intrinsic 说明类是直接声明的，而不是通过UHT</span><br><br><span class="hljs-keyword">typedef</span> UObject Super;<br><span class="hljs-keyword">typedef</span> UMyClass ThisClass;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">static</span> UClass* <span class="hljs-title">StaticClass</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetPrivateStaticClass</span>(); &#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> TCHAR* <span class="hljs-title">StaticPackage</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">L&quot;/Script/UObjectLearn&quot;</span>; &#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">static</span> EClassCastFlags <span class="hljs-title">StaticClassCastFlags</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> CASTCLASS_None; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> InSize, EInternal InInternalOnly,</span></span><br><span class="hljs-params"><span class="hljs-function">                          UObject* InOuter = (UObject*)GetTransientPackage(), FName InName = NAME_None,</span></span><br><span class="hljs-params"><span class="hljs-function">                          EObjectFlags InSetFlags = RF_NoFlags)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">StaticAllocateObject</span>(<span class="hljs-built_in">StaticClass</span>(), InOuter, InName, InSetFlags);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> InSize, EInternal* InMem)</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)InMem; &#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* InMem)</span> </span>&#123; ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(InMem)</span></span>; &#125;<br><span class="hljs-keyword">friend</span> FArchive&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(FArchive&amp; Ar, UMyClass*&amp; Res) &#123; <span class="hljs-keyword">return</span> Ar &lt;&lt; (UObject*&amp;)Res; &#125;<br><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>&lt;&lt;(FStructuredArchive::FSlot InSlot, UMyClass*&amp; Res) &#123; InSlot &lt;&lt; (UObject*&amp;)Res; &#125;<br><br><span class="hljs-built_in">UMyClass</span>(<span class="hljs-type">const</span> FObjectInitializer&amp; ObjectInitializer = FObjectInitializer::<span class="hljs-built_in">Get</span>()) : <span class="hljs-built_in">Super</span>(ObjectInitializer)<br>&#123;<br>&#125;;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">UMyClass</span>(UMyClass&amp;&amp;);<br><span class="hljs-built_in">UMyClass</span>(<span class="hljs-type">const</span> UMyClass&amp;);<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">UMyClass</span>(FVTableHelper&amp; Helper);<br><span class="hljs-comment">// InternalVTableHelperCtorCaller&lt;UMyClass&gt;</span><br><span class="hljs-type">static</span> UObject* __VTableCtorCaller(FVTableHelper&amp; Helper)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span>(EC_InternalUseOnlyConstructor, (UObject*)<span class="hljs-built_in">GetTransientPackage</span>(), NAME_None,<br>           RF_NeedLoad | RF_ClassDefaultObject | RF_TagGarbageTemp) <span class="hljs-built_in">UMyClass</span>(Helper);<br>&#125;;<br><span class="hljs-comment">// InternalConstructor&lt;UMyClass&gt;</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __DefaultConstructor(<span class="hljs-type">const</span> FObjectInitializer&amp; X) &#123; <span class="hljs-keyword">new</span>((EInternal*)X.<span class="hljs-built_in">GetObj</span>())<span class="hljs-built_in">UMyClass</span>(X); &#125;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">UMyClass</span>();<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">UPROPERTY</span>(BlueprintReadWrite)<br><span class="hljs-type">float</span> Score;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="hljs-string">&quot;UObjectLearn&quot;</span>)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CallableFunc</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//C++实现，蓝图调用</span><br><br><span class="hljs-built_in">UFUNCTION</span>(BlueprintNativeEvent, Category = <span class="hljs-string">&quot;UObjectLearn&quot;</span>)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NativeFunc</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//C++实现默认版本，蓝图可重载实现</span><br><br><span class="hljs-built_in">UFUNCTION</span>(BlueprintImplementableEvent, Category = <span class="hljs-string">&quot;UObjectLearn&quot;</span>)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ImplementableFunc</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//C++不实现，蓝图实现</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="MyClass-gen-cpp"><a href="#MyClass-gen-cpp" class="headerlink" title="MyClass.gen.cpp"></a>MyClass.gen.cpp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UObject/GeneratedCppIncludes.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UObjectLearn/Private/MyClass.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EmptyLinkFunctionForGeneratedCodeMyClass</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br><br><span class="hljs-comment">// Cross Module References</span><br><span class="hljs-comment">// 引用CoreUObject里的函数，主要是为了得到UObject本身对应的UClass</span><br><span class="hljs-function">COREUOBJECT_API UClass* <span class="hljs-title">Z_Construct_UClass_UObject</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 构造UMyClass对应的UClass对象</span><br><span class="hljs-function">UOBJECTLEARN_API UClass* <span class="hljs-title">Z_Construct_UClass_UMyClass</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 构造UMyClass对应的UClass对象，区别是没有后续的注册过程</span><br><span class="hljs-function">UOBJECTLEARN_API UClass* <span class="hljs-title">Z_Construct_UClass_UMyClass_NoRegister</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// UObjectLearn.init.gen.cpp中实现，通过UECodeGen_Private::ConstructUPackage构造UPackage</span><br><span class="hljs-function">UPackage* <span class="hljs-title">Z_Construct_UPackage__Script_UObjectLearn</span><span class="hljs-params">()</span></span>; <br><span class="hljs-comment">// End Cross Module References</span><br><span class="hljs-comment">// 实现为蓝图调用的函数execNativeFunc</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UMyClass::execNativeFunc</span><span class="hljs-params">(UObject* Context, FFrame&amp; Stack, <span class="hljs-type">void</span>* <span class="hljs-type">const</span> Z_Param__Result)</span></span><br><span class="hljs-function"></span>&#123; <br>Stack.Code += !!Stack.Code;;<br>&#123;<br>((ThisClass*)(Context))-&gt;<span class="hljs-built_in">NativeFunc_Implementation</span>(); <br>&#125;<br>&#125;<br><span class="hljs-comment">// 实现为蓝图调用的函数execCallableFunc</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UMyClass::execCallableFunc</span><span class="hljs-params">(UObject* Context, FFrame&amp; Stack, <span class="hljs-type">void</span>* <span class="hljs-type">const</span> Z_Param__Result)</span></span><br><span class="hljs-function"></span>&#123;<br>Stack.Code += !!Stack.Code;;<br>&#123;<br>((ThisClass*)(Context))-&gt;<span class="hljs-built_in">CallableFunc</span>();<br>&#125;;<br>&#125;<br><span class="hljs-comment">// 函数名字定义</span><br><span class="hljs-type">static</span> FName NAME_UMyClass_ImplementableFunc = <span class="hljs-built_in">FName</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;ImplementableFunc&quot;</span>));<br><span class="hljs-comment">// c++的默认实现，主要为了编译通过</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UMyClass::ImplementableFunc</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">ProcessEvent</span>(<span class="hljs-built_in">FindFunctionChecked</span>(NAME_UMyClass_ImplementableFunc),<span class="hljs-literal">NULL</span>);<br>&#125;<br><span class="hljs-type">static</span> FName NAME_UMyClass_NativeFunc = <span class="hljs-built_in">FName</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;NativeFunc&quot;</span>));<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UMyClass::NativeFunc</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">ProcessEvent</span>(<span class="hljs-built_in">FindFunctionChecked</span>(NAME_UMyClass_NativeFunc),<span class="hljs-literal">NULL</span>);<br>&#125;<br><span class="hljs-comment">// 注册类信息，如下将CallableFunc、NativeFunc注册进UClass*</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UMyClass::StaticRegisterNativesUMyClass</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>UClass* Class = UMyClass::<span class="hljs-built_in">StaticClass</span>();<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> FNameNativePtrPair Funcs[] = &#123;<br>&#123;<span class="hljs-string">&quot;CallableFunc&quot;</span>, &amp;UMyClass::execCallableFunc&#125;,<br>&#123;<span class="hljs-string">&quot;NativeFunc&quot;</span>, &amp;UMyClass::execNativeFunc&#125;,<br>&#125;;<br>FNativeFunctionRegistrar::<span class="hljs-built_in">RegisterFunctions</span>(Class, Funcs, <span class="hljs-built_in">UE_ARRAY_COUNT</span>(Funcs));<br>&#125;<br><span class="hljs-comment">// 下面是为了构造CallableFunc的UFunction</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Z_Construct_UFunction_UMyClass_CallableFunc_Statics</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> WITH_METADATA</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FFunctionParams FuncParams;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> WITH_METADATA</span><br><span class="hljs-type">const</span> UECodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_UMyClass_CallableFunc_Statics::Function_MetaDataParams<br>[] = &#123;<br>&#123;<span class="hljs-string">&quot;Category&quot;</span>, <span class="hljs-string">&quot;UObjectLearn&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;ModuleRelativePath&quot;</span>, <span class="hljs-string">&quot;Private/MyClass.h&quot;</span>&#125;,<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">const</span> UECodeGen_Private::FFunctionParams Z_Construct_UFunction_UMyClass_CallableFunc_Statics::FuncParams = &#123;<br>(UObject*(*)())Z_Construct_UClass_UMyClass, <span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;CallableFunc&quot;</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>,<br>RF_Public | RF_Transient | RF_MarkAsNative, (EFunctionFlags)<span class="hljs-number">0x04020401</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">METADATA_PARAMS</span>(<br>Z_Construct_UFunction_UMyClass_CallableFunc_Statics::Function_MetaDataParams,<br><span class="hljs-built_in">UE_ARRAY_COUNT</span>(Z_Construct_UFunction_UMyClass_CallableFunc_Statics::Function_MetaDataParams))<br>&#125;;<br><br><span class="hljs-function">UFunction* <span class="hljs-title">Z_Construct_UFunction_UMyClass_CallableFunc</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">static</span> UFunction* ReturnFunction = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">if</span> (!ReturnFunction)<br>&#123;<br>UECodeGen_Private::<span class="hljs-built_in">ConstructUFunction</span>(&amp;ReturnFunction,<br>                                      Z_Construct_UFunction_UMyClass_CallableFunc_Statics::FuncParams);<br>&#125;<br><span class="hljs-keyword">return</span> ReturnFunction;<br>&#125;<br><span class="hljs-comment">// 下面是为了构造ImplementableFunc的UFunction</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Z_Construct_UFunction_UMyClass_ImplementableFunc_Statics</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> WITH_METADATA</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FFunctionParams FuncParams;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> WITH_METADATA</span><br><span class="hljs-type">const</span> UECodeGen_Private::FMetaDataPairParam<br>Z_Construct_UFunction_UMyClass_ImplementableFunc_Statics::Function_MetaDataParams[] = &#123;<br>&#123;<span class="hljs-string">&quot;Category&quot;</span>, <span class="hljs-string">&quot;UObjectLearn&quot;</span>&#125;,<br>&#123;<br><span class="hljs-string">&quot;Comment&quot;</span>,<br><span class="hljs-string">&quot;//C++\xe5\xae\x9e\xe7\x8e\xb0\xe9\xbb\x98\xe8\xae\xa4\xe7\x89\x88\xe6\x9c\xac\xef\xbc\x8c\xe8\x93\x9d\xe5\x9b\xbe\xe5\x8f\xaf\xe9\x87\x8d\xe8\xbd\xbd\xe5\xae\x9e\xe7\x8e\xb0\n&quot;</span><br>&#125;,<br>&#123;<span class="hljs-string">&quot;ModuleRelativePath&quot;</span>, <span class="hljs-string">&quot;Private/MyClass.h&quot;</span>&#125;,<br>&#123;<br><span class="hljs-string">&quot;ToolTip&quot;</span>,<br><span class="hljs-string">&quot;C++\xe5\xae\x9e\xe7\x8e\xb0\xe9\xbb\x98\xe8\xae\xa4\xe7\x89\x88\xe6\x9c\xac\xef\xbc\x8c\xe8\x93\x9d\xe5\x9b\xbe\xe5\x8f\xaf\xe9\x87\x8d\xe8\xbd\xbd\xe5\xae\x9e\xe7\x8e\xb0&quot;</span><br>&#125;,<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">const</span> UECodeGen_Private::FFunctionParams Z_Construct_UFunction_UMyClass_ImplementableFunc_Statics::FuncParams = &#123;<br>(UObject*(*)())Z_Construct_UClass_UMyClass, <span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;ImplementableFunc&quot;</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>,<br>RF_Public | RF_Transient | RF_MarkAsNative, (EFunctionFlags)<span class="hljs-number">0x08020800</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">METADATA_PARAMS</span>(<br>Z_Construct_UFunction_UMyClass_ImplementableFunc_Statics::Function_MetaDataParams,<br><span class="hljs-built_in">UE_ARRAY_COUNT</span>(Z_Construct_UFunction_UMyClass_ImplementableFunc_Statics::Function_MetaDataParams))<br>&#125;;<br><br><span class="hljs-function">UFunction* <span class="hljs-title">Z_Construct_UFunction_UMyClass_ImplementableFunc</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">static</span> UFunction* ReturnFunction = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">if</span> (!ReturnFunction)<br>&#123;<br>UECodeGen_Private::<span class="hljs-built_in">ConstructUFunction</span>(&amp;ReturnFunction,<br>                                      Z_Construct_UFunction_UMyClass_ImplementableFunc_Statics::FuncParams);<br>&#125;<br><span class="hljs-keyword">return</span> ReturnFunction;<br>&#125;<br><span class="hljs-comment">// 下面是为了构造NativeFunc的UFunction</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Z_Construct_UFunction_UMyClass_NativeFunc_Statics</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> WITH_METADATA</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FFunctionParams FuncParams;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> WITH_METADATA</span><br><span class="hljs-type">const</span> UECodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_UMyClass_NativeFunc_Statics::Function_MetaDataParams[]<br>= &#123;<br>&#123;<span class="hljs-string">&quot;Category&quot;</span>, <span class="hljs-string">&quot;UObjectLearn&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;Comment&quot;</span>, <span class="hljs-string">&quot;//C++\xe5\xae\x9e\xe7\x8e\xb0\xef\xbc\x8c\xe8\x93\x9d\xe5\x9b\xbe\xe8\xb0\x83\xe7\x94\xa8\n&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;ModuleRelativePath&quot;</span>, <span class="hljs-string">&quot;Private/MyClass.h&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;ToolTip&quot;</span>, <span class="hljs-string">&quot;C++\xe5\xae\x9e\xe7\x8e\xb0\xef\xbc\x8c\xe8\x93\x9d\xe5\x9b\xbe\xe8\xb0\x83\xe7\x94\xa8&quot;</span>&#125;,<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">const</span> UECodeGen_Private::FFunctionParams Z_Construct_UFunction_UMyClass_NativeFunc_Statics::FuncParams = &#123;<br>(UObject*(*)())Z_Construct_UClass_UMyClass, <span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;NativeFunc&quot;</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>,<br>RF_Public | RF_Transient | RF_MarkAsNative, (EFunctionFlags)<span class="hljs-number">0x08020C00</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">METADATA_PARAMS</span>(<br>Z_Construct_UFunction_UMyClass_NativeFunc_Statics::Function_MetaDataParams,<br><span class="hljs-built_in">UE_ARRAY_COUNT</span>(Z_Construct_UFunction_UMyClass_NativeFunc_Statics::Function_MetaDataParams))<br>&#125;;<br><br><span class="hljs-function">UFunction* <span class="hljs-title">Z_Construct_UFunction_UMyClass_NativeFunc</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">static</span> UFunction* ReturnFunction = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">if</span> (!ReturnFunction)<br>&#123;<br>UECodeGen_Private::<span class="hljs-built_in">ConstructUFunction</span>(&amp;ReturnFunction,<br>                                      Z_Construct_UFunction_UMyClass_NativeFunc_Statics::FuncParams);<br>&#125;<br><span class="hljs-keyword">return</span> ReturnFunction;<br>&#125;<br><br>FClassRegistrationInfo Z_Registration_Info_UClass_UMyClass;<br><br><span class="hljs-function">UClass* <span class="hljs-title">UMyClass::GetPrivateStaticClass</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!Z_Registration_Info_UClass_UMyClass.InnerSingleton)<br>&#123;<br><span class="hljs-comment">// 真正创建UClass*</span><br><span class="hljs-built_in">GetPrivateStaticClassBody</span>(<br><span class="hljs-built_in">StaticPackage</span>(), <span class="hljs-comment">// Package名字</span><br>(TCHAR*)<span class="hljs-string">L&quot;UMyClass&quot;</span> + <span class="hljs-number">1</span> + ((StaticClassFlags &amp; CLASS_Deprecated) ? <span class="hljs-number">11</span> : <span class="hljs-number">0</span>), <br>Z_Registration_Info_UClass_UMyClass.InnerSingleton, <span class="hljs-comment">// 输出参数 UClass*&amp;</span><br>StaticRegisterNativesUMyClass, <span class="hljs-comment">// 注册类信息的回调</span><br><span class="hljs-built_in">sizeof</span>(UMyClass),<br><span class="hljs-built_in">alignof</span>(UMyClass),<br>(EClassFlags)UMyClass::StaticClassFlags, <span class="hljs-comment">// EClassFlags</span><br>UMyClass::<span class="hljs-built_in">StaticClassCastFlags</span>(), <span class="hljs-comment">// EClassCastFlags</span><br>UMyClass::<span class="hljs-built_in">StaticConfigName</span>(), <br>(UClass::ClassConstructorType)InternalConstructor&lt;UMyClass&gt;, <span class="hljs-comment">// __DefaultConstructor</span><br>(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller&lt;UMyClass&gt;, <span class="hljs-comment">// __VTableCtorCaller</span><br><span class="hljs-built_in">FUObjectCppClassStaticFunctions</span>(<br>  FUObjectCppClassStaticFunctions::<span class="hljs-built_in">AddReferencedObjectsType</span>(&amp;UMyClass::AddReferencedObjects),<br>  FUObjectCppClassStaticFunctions::<span class="hljs-built_in">DeclareCustomVersionsType</span>(&amp;UMyClass::DeclareCustomVersions),<br>  FUObjectCppClassStaticFunctions::<span class="hljs-built_in">AppendToClassSchemaType</span>(&amp;UMyClass::AppendToClassSchema),<br>  FUObjectCppClassStaticFunctions::<span class="hljs-built_in">DeclareConstructClassesType</span>(&amp;UMyClass::DeclareConstructClasses)),<br>              &amp;UMyClass::Super::StaticClass,<br>&amp;UMyClass::WithinClass::StaticClass);<br>&#125;<br><span class="hljs-keyword">return</span> Z_Registration_Info_UClass_UMyClass.InnerSingleton;<br>&#125;;<br><span class="hljs-comment">// 构造UMyClass对应的UClass对象，区别是没有后续的注册过程</span><br><span class="hljs-function">UClass* <span class="hljs-title">Z_Construct_UClass_UMyClass_NoRegister</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> UMyClass::<span class="hljs-built_in">StaticClass</span>();<br>&#125;<br><span class="hljs-comment">// 下面是为了构造UMyClass对应的UClass对象：Z_Construct_UClass_UMyClass</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Z_Construct_UClass_UMyClass_Statics</span><br>&#123;<br><span class="hljs-type">static</span> UObject* (*<span class="hljs-type">const</span> DependentSingletons[])();<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> FClassFunctionLinkInfo FuncInfo[];<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> WITH_METADATA</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[];<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> WITH_METADATA</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FMetaDataPairParam NewProp_Score_MetaData[];<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FFloatPropertyParams NewProp_Score;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FPropertyParamsBase* <span class="hljs-type">const</span> PropPointers[];<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> FCppClassTypeInfoStatic StaticCppClassTypeInfo;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FClassParams ClassParams;<br>&#125;;<br><br>UObject* (*<span class="hljs-type">const</span> Z_Construct_UClass_UMyClass_Statics::DependentSingletons[])() = &#123;<br>(UObject* (*)())Z_Construct_UClass_UObject,<br>(UObject* (*)())Z_Construct_UPackage__Script_UObjectLearn,<br>&#125;;<br><span class="hljs-type">const</span> FClassFunctionLinkInfo Z_Construct_UClass_UMyClass_Statics::FuncInfo[] = &#123;<br>&#123;&amp;Z_Construct_UFunction_UMyClass_CallableFunc, <span class="hljs-string">&quot;CallableFunc&quot;</span>&#125;, <span class="hljs-comment">// 2210339770</span><br>&#123;&amp;Z_Construct_UFunction_UMyClass_ImplementableFunc, <span class="hljs-string">&quot;ImplementableFunc&quot;</span>&#125;, <span class="hljs-comment">// 3656022940</span><br>&#123;&amp;Z_Construct_UFunction_UMyClass_NativeFunc, <span class="hljs-string">&quot;NativeFunc&quot;</span>&#125;, <span class="hljs-comment">// 2525684224</span><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> WITH_METADATA</span><br><span class="hljs-type">const</span> UECodeGen_Private::FMetaDataPairParam Z_Construct_UClass_UMyClass_Statics::Class_MetaDataParams[] = &#123;<br>&#123;<span class="hljs-string">&quot;BlueprintType&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;Comment&quot;</span>, <span class="hljs-string">&quot;/**\n * \n */&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;IncludePath&quot;</span>, <span class="hljs-string">&quot;MyClass.h&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;ModuleRelativePath&quot;</span>, <span class="hljs-string">&quot;Private/MyClass.h&quot;</span>&#125;,<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> WITH_METADATA</span><br><span class="hljs-type">const</span> UECodeGen_Private::FMetaDataPairParam Z_Construct_UClass_UMyClass_Statics::NewProp_Score_MetaData[] = &#123;<br>&#123;<span class="hljs-string">&quot;Category&quot;</span>, <span class="hljs-string">&quot;MyClass&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;ModuleRelativePath&quot;</span>, <span class="hljs-string">&quot;Private/MyClass.h&quot;</span>&#125;,<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">const</span> UECodeGen_Private::FFloatPropertyParams Z_Construct_UClass_UMyClass_Statics::NewProp_Score = &#123;<br><span class="hljs-string">&quot;Score&quot;</span>, <span class="hljs-literal">nullptr</span>, (EPropertyFlags)<span class="hljs-number">0x0010000000000004</span>, UECodeGen_Private::EPropertyGenFlags::Float,<br>RF_Public | RF_Transient | RF_MarkAsNative, <span class="hljs-number">1</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-built_in">STRUCT_OFFSET</span>(UMyClass, Score), <span class="hljs-built_in">METADATA_PARAMS</span>(<br>Z_Construct_UClass_UMyClass_Statics::NewProp_Score_MetaData,<br><span class="hljs-built_in">UE_ARRAY_COUNT</span>(Z_Construct_UClass_UMyClass_Statics::NewProp_Score_MetaData))<br>&#125;;<br><span class="hljs-type">const</span> UECodeGen_Private::FPropertyParamsBase* <span class="hljs-type">const</span> Z_Construct_UClass_UMyClass_Statics::PropPointers[] = &#123;<br>(<span class="hljs-type">const</span> UECodeGen_Private::FPropertyParamsBase*)&amp;Z_Construct_UClass_UMyClass_Statics::NewProp_Score,<br>&#125;;<br><span class="hljs-type">const</span> FCppClassTypeInfoStatic Z_Construct_UClass_UMyClass_Statics::StaticCppClassTypeInfo = &#123;<br>TCppClassTypeTraits&lt;UMyClass&gt;::IsAbstract,<br>&#125;;<br><span class="hljs-type">const</span> UECodeGen_Private::FClassParams Z_Construct_UClass_UMyClass_Statics::ClassParams = &#123;<br>&amp;UMyClass::StaticClass,<br><span class="hljs-literal">nullptr</span>,<br>&amp;StaticCppClassTypeInfo,<br>DependentSingletons,<br>FuncInfo,<br>Z_Construct_UClass_UMyClass_Statics::PropPointers,<br><span class="hljs-literal">nullptr</span>,<br><span class="hljs-built_in">UE_ARRAY_COUNT</span>(DependentSingletons),<br><span class="hljs-built_in">UE_ARRAY_COUNT</span>(FuncInfo),<br><span class="hljs-built_in">UE_ARRAY_COUNT</span>(Z_Construct_UClass_UMyClass_Statics::PropPointers),<br><span class="hljs-number">0</span>,<br><span class="hljs-number">0x001000A0u</span>,<br><span class="hljs-built_in">METADATA_PARAMS</span>(Z_Construct_UClass_UMyClass_Statics::Class_MetaDataParams,<br>                <span class="hljs-built_in">UE_ARRAY_COUNT</span>(Z_Construct_UClass_UMyClass_Statics::Class_MetaDataParams))<br>&#125;;<br><span class="hljs-comment">// 构造UMyClass对应的UClass对象</span><br><span class="hljs-function">UClass* <span class="hljs-title">Z_Construct_UClass_UMyClass</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!Z_Registration_Info_UClass_UMyClass.OuterSingleton)<br>&#123;<br>UECodeGen_Private::<span class="hljs-built_in">ConstructUClass</span>(Z_Registration_Info_UClass_UMyClass.OuterSingleton,<br>                                   Z_Construct_UClass_UMyClass_Statics::ClassParams);<br>&#125;<br><span class="hljs-keyword">return</span> Z_Registration_Info_UClass_UMyClass.OuterSingleton;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;&gt;<br>UOBJECTLEARN_API UClass* <span class="hljs-built_in">StaticClass</span>&lt;UMyClass&gt;()<br>&#123;<br><span class="hljs-keyword">return</span> UMyClass::<span class="hljs-built_in">StaticClass</span>();<br>&#125;<br><br>UMyClass::<span class="hljs-built_in">UMyClass</span>(FVTableHelper&amp; Helper) : <span class="hljs-built_in">Super</span>(Helper)<br>&#123;<br>&#125;;;<br><br>UMyClass::~<span class="hljs-built_in">UMyClass</span>()<br>&#123;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Z_CompiledInDeferFile_FID_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyClass_h_Statics</span><br>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> FClassRegisterCompiledInInfo ClassInfo[];<br>&#125;;<br><br><span class="hljs-type">const</span> FClassRegisterCompiledInInfo<br>Z_CompiledInDeferFile_FID_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyClass_h_Statics::ClassInfo[] =<br>&#123;<br>&#123;<br>Z_Construct_UClass_UMyClass, UMyClass::StaticClass, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;UMyClass&quot;</span>), &amp;Z_Registration_Info_UClass_UMyClass,<br><span class="hljs-built_in">CONSTRUCT_RELOAD_VERSION_INFO</span>(FClassReloadVersionInfo, <span class="hljs-built_in">sizeof</span>(UMyClass), <span class="hljs-number">343687568U</span>)<br>&#125;,<br>&#125;;<br><span class="hljs-comment">// 对象注册，调用RegisterCompiledInInfo</span><br><span class="hljs-function"><span class="hljs-type">static</span> FRegisterCompiledInInfo</span><br><span class="hljs-function"><span class="hljs-title">Z_CompiledInDeferFile_FID_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyClass_h_3142771497</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;/Script/UObjectLearn&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">Z_CompiledInDeferFile_FID_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyClass_h_Statics::ClassInfo,</span></span><br><span class="hljs-params"><span class="hljs-function">UE_ARRAY_COUNT(</span></span><br><span class="hljs-params"><span class="hljs-function">Z_CompiledInDeferFile_FID_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyClass_h_Statics::</span></span><br><span class="hljs-params"><span class="hljs-function">ClassInfo),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UMyClass::CallableFunc</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UMyClass::NativeFunc_Implementation</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="UENUM的生成代码剖析"><a href="#UENUM的生成代码剖析" class="headerlink" title="UENUM的生成代码剖析"></a>UENUM的生成代码剖析</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MyEnum.generated.h&quot;</span></span><br><br><span class="hljs-built_in">UENUM</span>(BlueprintType)<br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">EMyEnum</span> : uint8<br>&#123;<br><span class="hljs-function">MY_Dance <span class="hljs-title">UMETA</span><span class="hljs-params">(DisplayName = <span class="hljs-string">&quot;Dance&quot;</span>)</span>,</span><br><span class="hljs-function">MY_Rain <span class="hljs-title">UMETA</span><span class="hljs-params">(DisplayName = <span class="hljs-string">&quot;Rain&quot;</span>)</span>,</span><br><span class="hljs-function">MY_Song<span class="hljs-title">UMETA</span><span class="hljs-params">(DisplayName = <span class="hljs-string">&quot;Song&quot;</span>)</span></span><br><span class="hljs-function">&#125;</span>;<br><br></code></pre></td></tr></table></figure><h4 id="生成的头文件-1"><a href="#生成的头文件-1" class="headerlink" title="生成的头文件"></a>生成的头文件</h4><p>比较简单，重点是：</p><ul><li>特化了TIsUEnumClass模板</li><li>特化了StaticEnum模板方法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Copyright Epic Games, Inc. All Rights Reserved.</span><br><span class="hljs-comment">/*===========================================================================</span><br><span class="hljs-comment">Generated code exported from UnrealHeaderTool.</span><br><span class="hljs-comment">DO NOT modify this manually! Edit the corresponding .h files instead!</span><br><span class="hljs-comment">===========================================================================*/</span><br><br><span class="hljs-comment">// IWYU pragma: private, include &quot;MyEnum.h&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UObject/ObjectMacros.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UObject/ScriptMacros.h&quot;</span></span><br><br>PRAGMA_DISABLE_DEPRECATION_WARNINGS<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> UOBJECTLEARN_MyEnum_generated_h</span><br><span class="hljs-meta">#<span class="hljs-keyword">error</span> <span class="hljs-string">&quot;MyEnum.generated.h already included, missing &#x27;#pragma once&#x27; in MyEnum.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UOBJECTLEARN_MyEnum_generated_h</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> CURRENT_FILE_ID</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CURRENT_FILE_ID FID_unreal_learning_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyEnum_h</span><br><br><span class="hljs-comment">// 定义一个遍历枚举值的宏，只是为了方便使用</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOREACH_ENUM_EMYENUM(op) \</span><br><span class="hljs-meta">op(EMyEnum::MY_Dance) \</span><br><span class="hljs-meta">op(EMyEnum::MY_Rain) \</span><br><span class="hljs-meta">op(EMyEnum::MY_Song) </span><br><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">EMyEnum</span> : uint8;<br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TIsUEnumClass</span>&lt;EMyEnum&gt; &#123; <span class="hljs-keyword">enum</span> &#123; Value = <span class="hljs-literal">true</span> &#125;; &#125;;<br><span class="hljs-keyword">template</span>&lt;&gt; UOBJECTLEARN_API UEnum* <span class="hljs-built_in">StaticEnum</span>&lt;EMyEnum&gt;();<br><br>PRAGMA_ENABLE_DEPRECATION_WARNINGS<br><br></code></pre></td></tr></table></figure><h4 id="生成的实现-1"><a href="#生成的实现-1" class="headerlink" title="生成的实现"></a>生成的实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Copyright Epic Games, Inc. All Rights Reserved.</span><br><span class="hljs-comment">/*===========================================================================</span><br><span class="hljs-comment">Generated code exported from UnrealHeaderTool.</span><br><span class="hljs-comment">DO NOT modify this manually! Edit the corresponding .h files instead!</span><br><span class="hljs-comment">===========================================================================*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UObject/GeneratedCppIncludes.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UObjectLearn/Private/MyEnum.h&quot;</span></span><br><span class="hljs-function">PRAGMA_DISABLE_DEPRECATION_WARNINGS</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EmptyLinkFunctionForGeneratedCodeMyEnum</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-comment">// Cross Module References</span><br><span class="hljs-comment">// 构造EMyEnum对应的UEnum对象</span><br><span class="hljs-function">UOBJECTLEARN_API UEnum* <span class="hljs-title">Z_Construct_UEnum_UObjectLearn_EMyEnum</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// UObjectLearn.init.gen.cpp中实现，通过UECodeGen_Private::ConstructUPackage构造UPackage</span><br><span class="hljs-function">UPackage* <span class="hljs-title">Z_Construct_UPackage__Script_UObjectLearn</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// End Cross Module References</span><br><span class="hljs-type">static</span> FEnumRegistrationInfo Z_Registration_Info_UEnum_EMyEnum;<br><span class="hljs-function"><span class="hljs-type">static</span> UEnum* <span class="hljs-title">EMyEnum_StaticEnum</span><span class="hljs-params">()</span> <span class="hljs-comment">// 定义一个获取UEnum便利函数，会在延迟注册的时候被用到</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!Z_Registration_Info_UEnum_EMyEnum.OuterSingleton)<br>&#123;<br><span class="hljs-comment">// 传入Z_Construct_UEnum_UObjectLearn_EMyEnum进行构造</span><br>Z_Registration_Info_UEnum_EMyEnum.OuterSingleton = <span class="hljs-built_in">GetStaticEnum</span>(Z_Construct_UEnum_UObjectLearn_EMyEnum, <span class="hljs-built_in">Z_Construct_UPackage__Script_UObjectLearn</span>(), <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;EMyEnum&quot;</span>));<br>&#125;<br><span class="hljs-keyword">return</span> Z_Registration_Info_UEnum_EMyEnum.OuterSingleton;<br>&#125;<br><span class="hljs-keyword">template</span>&lt;&gt; UOBJECTLEARN_API UEnum* <span class="hljs-built_in">StaticEnum</span>&lt;EMyEnum&gt;()<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">EMyEnum_StaticEnum</span>();<br>&#125;<br><span class="hljs-comment">// 下面的定义是为了生成UEnum* Z_Construct_UEnum_UObjectLearn_EMyEnum</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Z_Construct_UEnum_UObjectLearn_EMyEnum_Statics</span><br>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FEnumeratorParam Enumerators[];<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> WITH_METADATA</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[];<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FEnumParams EnumParams;<br>&#125;;<br><span class="hljs-type">const</span> UECodeGen_Private::FEnumeratorParam Z_Construct_UEnum_UObjectLearn_EMyEnum_Statics::Enumerators[] = &#123;<br>&#123; <span class="hljs-string">&quot;EMyEnum::MY_Dance&quot;</span>, (int64)EMyEnum::MY_Dance &#125;,<br>&#123; <span class="hljs-string">&quot;EMyEnum::MY_Rain&quot;</span>, (int64)EMyEnum::MY_Rain &#125;,<br>&#123; <span class="hljs-string">&quot;EMyEnum::MY_Song&quot;</span>, (int64)EMyEnum::MY_Song &#125;,<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> WITH_METADATA</span><br><span class="hljs-type">const</span> UECodeGen_Private::FMetaDataPairParam Z_Construct_UEnum_UObjectLearn_EMyEnum_Statics::Enum_MetaDataParams[] = &#123;<br>&#123; <span class="hljs-string">&quot;BlueprintType&quot;</span>, <span class="hljs-string">&quot;true&quot;</span> &#125;,<br>&#123; <span class="hljs-string">&quot;ModuleRelativePath&quot;</span>, <span class="hljs-string">&quot;Private/MyEnum.h&quot;</span> &#125;,<br>&#123; <span class="hljs-string">&quot;MY_Dance.DisplayName&quot;</span>, <span class="hljs-string">&quot;Dance&quot;</span> &#125;,<br>&#123; <span class="hljs-string">&quot;MY_Dance.Name&quot;</span>, <span class="hljs-string">&quot;EMyEnum::MY_Dance&quot;</span> &#125;,<br>&#123; <span class="hljs-string">&quot;MY_Rain.DisplayName&quot;</span>, <span class="hljs-string">&quot;Rain&quot;</span> &#125;,<br>&#123; <span class="hljs-string">&quot;MY_Rain.Name&quot;</span>, <span class="hljs-string">&quot;EMyEnum::MY_Rain&quot;</span> &#125;,<br>&#123; <span class="hljs-string">&quot;MY_Song.DisplayName&quot;</span>, <span class="hljs-string">&quot;Song&quot;</span> &#125;,<br>&#123; <span class="hljs-string">&quot;MY_Song.Name&quot;</span>, <span class="hljs-string">&quot;EMyEnum::MY_Song&quot;</span> &#125;,<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">const</span> UECodeGen_Private::FEnumParams Z_Construct_UEnum_UObjectLearn_EMyEnum_Statics::EnumParams = &#123;<br>(UObject*(*)())Z_Construct_UPackage__Script_UObjectLearn,<br><span class="hljs-literal">nullptr</span>,<br><span class="hljs-string">&quot;EMyEnum&quot;</span>,<br><span class="hljs-string">&quot;EMyEnum&quot;</span>,<br>Z_Construct_UEnum_UObjectLearn_EMyEnum_Statics::Enumerators,<br><span class="hljs-built_in">UE_ARRAY_COUNT</span>(Z_Construct_UEnum_UObjectLearn_EMyEnum_Statics::Enumerators),<br>RF_Public|RF_Transient|RF_MarkAsNative,<br>EEnumFlags::None,<br>(uint8)UEnum::ECppForm::EnumClass,<br><span class="hljs-built_in">METADATA_PARAMS</span>(Z_Construct_UEnum_UObjectLearn_EMyEnum_Statics::Enum_MetaDataParams, <span class="hljs-built_in">UE_ARRAY_COUNT</span>(Z_Construct_UEnum_UObjectLearn_EMyEnum_Statics::Enum_MetaDataParams))<br>&#125;;<br><span class="hljs-comment">// 构造EMyEnum关联的UEnum*</span><br><span class="hljs-function">UEnum* <span class="hljs-title">Z_Construct_UEnum_UObjectLearn_EMyEnum</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!Z_Registration_Info_UEnum_EMyEnum.InnerSingleton)<br>&#123;<br>UECodeGen_Private::<span class="hljs-built_in">ConstructUEnum</span>(Z_Registration_Info_UEnum_EMyEnum.InnerSingleton, Z_Construct_UEnum_UObjectLearn_EMyEnum_Statics::EnumParams);<br>&#125;<br><span class="hljs-keyword">return</span> Z_Registration_Info_UEnum_EMyEnum.InnerSingleton;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Z_CompiledInDeferFile_FID_unreal_learning_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyEnum_h_Statics</span><br>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> FEnumRegisterCompiledInInfo EnumInfo[];<br>&#125;;<br><span class="hljs-type">const</span> FEnumRegisterCompiledInInfo Z_CompiledInDeferFile_FID_unreal_learning_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyEnum_h_Statics::EnumInfo[] = &#123;<br>&#123; EMyEnum_StaticEnum, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;EMyEnum&quot;</span>), &amp;Z_Registration_Info_UEnum_EMyEnum, <span class="hljs-built_in">CONSTRUCT_RELOAD_VERSION_INFO</span>(FEnumReloadVersionInfo, <span class="hljs-number">1966967219U</span>) &#125;,<br>&#125;;<br><span class="hljs-comment">// 对象注册，调用RegisterCompiledInInfo</span><br><span class="hljs-function"><span class="hljs-type">static</span> FRegisterCompiledInInfo <span class="hljs-title">Z_CompiledInDeferFile_FID_unreal_learning_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyEnum_h_2167825752</span><span class="hljs-params">(TEXT(<span class="hljs-string">&quot;/Script/UObjectLearn&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">Z_CompiledInDeferFile_FID_unreal_learning_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyEnum_h_Statics::EnumInfo, UE_ARRAY_COUNT(Z_CompiledInDeferFile_FID_unreal_learning_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyEnum_h_Statics::EnumInfo))</span></span>;<br>PRAGMA_ENABLE_DEPRECATION_WARNINGS<br><br></code></pre></td></tr></table></figure><h3 id="USTRUCT的生成代码剖析"><a href="#USTRUCT的生成代码剖析" class="headerlink" title="USTRUCT的生成代码剖析"></a>USTRUCT的生成代码剖析</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MyStruct.generated.h&quot;</span></span><br><br><span class="hljs-built_in">USTRUCT</span>(BlueprintType)<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FMyStruct</span><br>&#123;<br><span class="hljs-built_in">GENERATED_USTRUCT_BODY</span>()<br><br><span class="hljs-built_in">UPROPERTY</span>(BlueprintReadWrite)<br><span class="hljs-type">float</span> Score;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="生成的头文件-2"><a href="#生成的头文件-2" class="headerlink" title="生成的头文件"></a>生成的头文件</h4><p>因为FMyStruct不继承与UObject，所以结构比较简单。</p><p>核心是定义了一个 <code>StaticStruct</code>的方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Copyright Epic Games, Inc. All Rights Reserved.</span><br><span class="hljs-comment">/*===========================================================================</span><br><span class="hljs-comment">Generated code exported from UnrealHeaderTool.</span><br><span class="hljs-comment">DO NOT modify this manually! Edit the corresponding .h files instead!</span><br><span class="hljs-comment">===========================================================================*/</span><br><br><span class="hljs-comment">// IWYU pragma: private, include &quot;MyStruct.h&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UObject/ObjectMacros.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UObject/ScriptMacros.h&quot;</span></span><br><br>PRAGMA_DISABLE_DEPRECATION_WARNINGS<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> UOBJECTLEARN_MyStruct_generated_h</span><br><span class="hljs-meta">#<span class="hljs-keyword">error</span> <span class="hljs-string">&quot;MyStruct.generated.h already included, missing &#x27;#pragma once&#x27; in MyStruct.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UOBJECTLEARN_MyStruct_generated_h</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FID_unreal_learning_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyStruct_h_11_GENERATED_BODY \</span><br><span class="hljs-meta">friend struct Z_Construct_UScriptStruct_FMyStruct_Statics; \</span><br><span class="hljs-meta">UOBJECTLEARN_API static class UScriptStruct* StaticStruct();</span><br><br><span class="hljs-comment">// StaticStruct()特化</span><br><span class="hljs-keyword">template</span>&lt;&gt; UOBJECTLEARN_API UScriptStruct* <span class="hljs-built_in">StaticStruct</span>&lt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">FMyStruct</span>&gt;();<br><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> CURRENT_FILE_ID</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CURRENT_FILE_ID FID_unreal_learning_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyStruct_h</span><br><br><br>PRAGMA_ENABLE_DEPRECATION_WARNINGS<br><br></code></pre></td></tr></table></figure><h4 id="生成的实现-2"><a href="#生成的实现-2" class="headerlink" title="生成的实现"></a>生成的实现</h4><p>实现与UENUM的实现很类似。<code>FMyStruct::StaticStruct</code>&#x3D;&#x3D;<code>EMyEnum_StaticEnum</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Copyright Epic Games, Inc. All Rights Reserved.</span><br><span class="hljs-comment">/*===========================================================================</span><br><span class="hljs-comment">Generated code exported from UnrealHeaderTool.</span><br><span class="hljs-comment">DO NOT modify this manually! Edit the corresponding .h files instead!</span><br><span class="hljs-comment">===========================================================================*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UObject/GeneratedCppIncludes.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UObjectLearn/Private/MyStruct.h&quot;</span></span><br><span class="hljs-function">PRAGMA_DISABLE_DEPRECATION_WARNINGS</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EmptyLinkFunctionForGeneratedCodeMyStruct</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br><br><span class="hljs-comment">// Cross Module References</span><br><span class="hljs-comment">// 构造FMyStruct对应的UScriptStruct对象</span><br><span class="hljs-function">UOBJECTLEARN_API UScriptStruct* <span class="hljs-title">Z_Construct_UScriptStruct_FMyStruct</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// UObjectLearn.init.gen.cpp中实现，通过UECodeGen_Private::ConstructUPackage构造UPackage</span><br><span class="hljs-function">UPackage* <span class="hljs-title">Z_Construct_UPackage__Script_UObjectLearn</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// End Cross Module References</span><br><span class="hljs-type">static</span> FStructRegistrationInfo Z_Registration_Info_UScriptStruct_MyStruct;<br><br><span class="hljs-function"><span class="hljs-keyword">class</span> UScriptStruct* <span class="hljs-title">FMyStruct::StaticStruct</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!Z_Registration_Info_UScriptStruct_MyStruct.OuterSingleton)<br>&#123;<br>Z_Registration_Info_UScriptStruct_MyStruct.OuterSingleton = <span class="hljs-built_in">GetStaticStruct</span>(<br>Z_Construct_UScriptStruct_FMyStruct, <span class="hljs-built_in">Z_Construct_UPackage__Script_UObjectLearn</span>(), <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;MyStruct&quot;</span>));<br>&#125;<br><span class="hljs-keyword">return</span> Z_Registration_Info_UScriptStruct_MyStruct.OuterSingleton;<br>&#125;<br><br><span class="hljs-comment">// 实现头文件声明的StaticStruct&lt;FMyStruct&gt;特化，调用 FMyStruct::StaticStruct</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br>UOBJECTLEARN_API UScriptStruct* <span class="hljs-built_in">StaticStruct</span>&lt;FMyStruct&gt;()<br>&#123;<br><span class="hljs-keyword">return</span> FMyStruct::<span class="hljs-built_in">StaticStruct</span>();<br>&#125;<br><span class="hljs-comment">// 以下是为了构造UScriptStruct：Z_Construct_UScriptStruct_FMyStruct()</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Z_Construct_UScriptStruct_FMyStruct_Statics</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> WITH_METADATA</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[];<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-title">NewStructOps</span><span class="hljs-params">()</span></span>;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FStructParams ReturnStructParams;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> WITH_METADATA</span><br><span class="hljs-type">const</span> UECodeGen_Private::FMetaDataPairParam Z_Construct_UScriptStruct_FMyStruct_Statics::Struct_MetaDataParams[] = &#123;<br>&#123;<span class="hljs-string">&quot;BlueprintType&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;ModuleRelativePath&quot;</span>, <span class="hljs-string">&quot;Private/MyStruct.h&quot;</span>&#125;,<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">Z_Construct_UScriptStruct_FMyStruct_Statics::NewStructOps</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (UScriptStruct::ICppStructOps*)<span class="hljs-keyword">new</span> UScriptStruct::<span class="hljs-built_in">TCppStructOps</span>&lt;FMyStruct&gt;();<br>&#125;<br><br><span class="hljs-type">const</span> UECodeGen_Private::FStructParams Z_Construct_UScriptStruct_FMyStruct_Statics::ReturnStructParams = &#123;<br>(UObject* (*)())Z_Construct_UPackage__Script_UObjectLearn,<br><span class="hljs-literal">nullptr</span>,<br>&amp;NewStructOps,<br><span class="hljs-string">&quot;MyStruct&quot;</span>,<br><span class="hljs-built_in">sizeof</span>(FMyStruct),<br><span class="hljs-built_in">alignof</span>(FMyStruct),<br><span class="hljs-literal">nullptr</span>,<br><span class="hljs-number">0</span>,<br>RF_Public | RF_Transient | RF_MarkAsNative,<br><span class="hljs-built_in">EStructFlags</span>(<span class="hljs-number">0x00000001</span>),<br><span class="hljs-built_in">METADATA_PARAMS</span>(Z_Construct_UScriptStruct_FMyStruct_Statics::Struct_MetaDataParams,<br>                <span class="hljs-built_in">UE_ARRAY_COUNT</span>(Z_Construct_UScriptStruct_FMyStruct_Statics::Struct_MetaDataParams))<br>&#125;;<br><span class="hljs-comment">// 构造FMyStruct对应的UScriptStruct对象</span><br><span class="hljs-function">UScriptStruct* <span class="hljs-title">Z_Construct_UScriptStruct_FMyStruct</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!Z_Registration_Info_UScriptStruct_MyStruct.InnerSingleton)<br>&#123;<br>UECodeGen_Private::<span class="hljs-built_in">ConstructUScriptStruct</span>(Z_Registration_Info_UScriptStruct_MyStruct.InnerSingleton,<br>                                          Z_Construct_UScriptStruct_FMyStruct_Statics::ReturnStructParams);<br>&#125;<br><span class="hljs-keyword">return</span> Z_Registration_Info_UScriptStruct_MyStruct.InnerSingleton;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Z_CompiledInDeferFile_FID_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyStruct_h_Statics</span><br>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> FStructRegisterCompiledInInfo ScriptStructInfo[];<br>&#125;;<br><br><span class="hljs-type">const</span> FStructRegisterCompiledInInfo<br>Z_CompiledInDeferFile_FID_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyStruct_h_Statics::ScriptStructInfo<br>[] = &#123;<br>&#123;<br>FMyStruct::StaticStruct, Z_Construct_UScriptStruct_FMyStruct_Statics::NewStructOps, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;MyStruct&quot;</span>),<br>&amp;Z_Registration_Info_UScriptStruct_MyStruct,<br><span class="hljs-built_in">CONSTRUCT_RELOAD_VERSION_INFO</span>(FStructReloadVersionInfo, <span class="hljs-built_in">sizeof</span>(FMyStruct), <span class="hljs-number">4101929637U</span>)<br>&#125;,<br>&#125;;<br><span class="hljs-comment">// 对象注册，调用RegisterCompiledInInfo</span><br><span class="hljs-function"><span class="hljs-type">static</span> FRegisterCompiledInInfo</span><br><span class="hljs-function"><span class="hljs-title">Z_CompiledInDeferFile_FID_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyStruct_h_137600743</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;/Script/UObjectLearn&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">Z_CompiledInDeferFile_FID_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyStruct_h_Statics::ScriptStructInfo,</span></span><br><span class="hljs-params"><span class="hljs-function">UE_ARRAY_COUNT(</span></span><br><span class="hljs-params"><span class="hljs-function">Z_CompiledInDeferFile_FID_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyStruct_h_Statics::</span></span><br><span class="hljs-params"><span class="hljs-function">ScriptStructInfo),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>)</span></span>;<br>PRAGMA_ENABLE_DEPRECATION_WARNINGS<br><br><br></code></pre></td></tr></table></figure><h3 id="UINTERFACE的生成代码剖析"><a href="#UINTERFACE的生成代码剖析" class="headerlink" title="UINTERFACE的生成代码剖析"></a>UINTERFACE的生成代码剖析</h3><p>UMyInterface和IMyInterface必须要一起定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Fill out your copyright notice in the Description page of Project Settings.</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CoreMinimal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MyInterface.generated.h&quot;</span></span><br><br><span class="hljs-built_in">UINTERFACE</span>(BlueprintType)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UMyInterface</span> : <span class="hljs-keyword">public</span> UInterface<br>&#123;<br><span class="hljs-built_in">GENERATED_BODY</span>()<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IMyInterface</span><br>&#123;<br><span class="hljs-built_in">GENERATED_BODY</span>()<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">UFUNCTION</span>(BlueprintImplementableEvent)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BPFun</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>因为UMyInterface继承于UObject的原因，所以也是从属于Object系统的一份子，所以同样需要遵循构造函数的规则。UInterface本身其实也可以算是UClass的一种，所以生成的代码跟UClass中的生成都差不多，区别是用了COMPILED_IN_FLAGS(CLASS_Abstract | CLASS_Interface)的不同标记。</p><p>UINTERFACE生成的头文件与UCLASS类似，以下直接展开头文件和cpp：</p><h4 id="展开的头文件"><a href="#展开的头文件" class="headerlink" title="展开的头文件"></a>展开的头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">UINTERFACE</span>(BlueprintType)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UMyInterface</span> : <span class="hljs-keyword">public</span> UInterface<br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">StaticRegisterNativesUMyInterface</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Z_Construct_UClass_UMyInterface_Statics</span>;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">private</span>:<br>UMyInterface&amp; <span class="hljs-keyword">operator</span>=(UMyInterface&amp;&amp;);<br>UMyInterface&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> UMyInterface&amp;);<br><span class="hljs-function"><span class="hljs-type">static</span> UClass* <span class="hljs-title">GetPrivateStaticClass</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">enum</span> &#123; StaticClassFlags = (CLASS_Abstract | CLASS_Interface | CLASS_Intrinsic) &#125;;<span class="hljs-comment">// 标记与UCLASS展开的不同</span><br><br><span class="hljs-keyword">typedef</span> UInterface Super;<br><span class="hljs-keyword">typedef</span> UMyInterface ThisClass;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">static</span> UClass* <span class="hljs-title">StaticClass</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetPrivateStaticClass</span>(); &#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> TCHAR* <span class="hljs-title">StaticPackage</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">L&quot;/Script/UObjectLearn&quot;</span>; &#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">static</span> EClassCastFlags <span class="hljs-title">StaticClassCastFlags</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> CASTCLASS_None; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> InSize, EInternal InInternalOnly,</span></span><br><span class="hljs-params"><span class="hljs-function">                          UObject* InOuter = (UObject*)GetTransientPackage(), FName InName = NAME_None,</span></span><br><span class="hljs-params"><span class="hljs-function">                          EObjectFlags InSetFlags = RF_NoFlags)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">StaticAllocateObject</span>(<span class="hljs-built_in">StaticClass</span>(), InOuter, InName, InSetFlags);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> InSize, EInternal* InMem)</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)InMem; &#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* InMem)</span> </span>&#123; ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(InMem)</span></span>; &#125;<br><span class="hljs-keyword">friend</span> FArchive&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(FArchive&amp; Ar, UMyInterface*&amp; Res) &#123; <span class="hljs-keyword">return</span> Ar &lt;&lt; (UObject*&amp;)Res; &#125;<br><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>&lt;&lt;(FStructuredArchive::FSlot InSlot, UMyInterface*&amp; Res) &#123; InSlot &lt;&lt; (UObject*&amp;)Res; &#125;<br><br><span class="hljs-built_in">UMyInterface</span>(<span class="hljs-type">const</span> FObjectInitializer&amp; ObjectInitializer = FObjectInitializer::<span class="hljs-built_in">Get</span>()) : <span class="hljs-built_in">Super</span>(ObjectInitializer)<br>&#123;<br>&#125;;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">UMyInterface</span>(UMyInterface&amp;&amp;);<br><span class="hljs-built_in">UMyInterface</span>(<span class="hljs-type">const</span> UMyInterface&amp;);<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">UMyInterface</span>(FVTableHelper&amp; Helper);;<br><br><span class="hljs-type">static</span> UObject* __VTableCtorCaller(FVTableHelper&amp; Helper)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span>(EC_InternalUseOnlyConstructor, (UObject*)<span class="hljs-built_in">GetTransientPackage</span>(), NAME_None,<br>           RF_NeedLoad | RF_ClassDefaultObject | RF_TagGarbageTemp) <span class="hljs-built_in">UMyInterface</span>(Helper);<br>&#125;;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __DefaultConstructor(<span class="hljs-type">const</span> FObjectInitializer&amp; X) &#123; <span class="hljs-keyword">new</span>((EInternal*)X.<span class="hljs-built_in">GetObj</span>())<span class="hljs-built_in">UMyInterface</span>(X); &#125;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">UMyInterface</span>();<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IMyInterface</span><br>&#123;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">IMyInterface</span>()<br>&#123;<br>&#125;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">typedef</span> UMyInterface UClassType;<br><span class="hljs-keyword">typedef</span> IMyInterface ThisClass;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Execute_BPFun</span><span class="hljs-params">(<span class="hljs-type">const</span> UObject* O)</span></span>;<br><span class="hljs-keyword">virtual</span> UObject* _getUObject() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; &#125;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">UFUNCTION</span>(BlueprintImplementableEvent)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BPFun</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="展开的gen实现"><a href="#展开的gen实现" class="headerlink" title="展开的gen实现"></a>展开的gen实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Copyright Epic Games, Inc. All Rights Reserved.</span><br><span class="hljs-comment">/*===========================================================================</span><br><span class="hljs-comment">Generated code exported from UnrealHeaderTool.</span><br><span class="hljs-comment">DO NOT modify this manually! Edit the corresponding .h files instead!</span><br><span class="hljs-comment">===========================================================================*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UObject/GeneratedCppIncludes.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UObjectLearn/Public/MyInterface.h&quot;</span></span><br><span class="hljs-function">PRAGMA_DISABLE_DEPRECATION_WARNINGS</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EmptyLinkFunctionForGeneratedCodeMyInterface</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br><br><span class="hljs-comment">// Cross Module References</span><br><span class="hljs-comment">// 引用CoreUObject里的函数，主要是为了得到UInterface本身对应的UClass</span><br><span class="hljs-function">COREUOBJECT_API UClass* <span class="hljs-title">Z_Construct_UClass_UInterface</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">UOBJECTLEARN_API UClass* <span class="hljs-title">Z_Construct_UClass_UMyInterface</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">UOBJECTLEARN_API UClass* <span class="hljs-title">Z_Construct_UClass_UMyInterface_NoRegister</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">UPackage* <span class="hljs-title">Z_Construct_UPackage__Script_UObjectLearn</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// End Cross Module References</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">IMyInterface::BPFun</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 断言，不可直接调用。可以使用Execute_BPFun。</span><br><span class="hljs-built_in">check</span>(<span class="hljs-number">0</span> &amp;&amp; <span class="hljs-string">&quot;Do not directly call Event functions in Interfaces. Call Execute_BPFun instead.&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UMyInterface::StaticRegisterNativesUMyInterface</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Z_Construct_UFunction_UMyInterface_BPFun_Statics</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> WITH_METADATA</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FMetaDataPairParam Function_MetaDataParams[];<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FFunctionParams FuncParams;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> WITH_METADATA</span><br><span class="hljs-type">const</span> UECodeGen_Private::FMetaDataPairParam Z_Construct_UFunction_UMyInterface_BPFun_Statics::Function_MetaDataParams[]<br>= &#123;<br>&#123;<span class="hljs-string">&quot;ModuleRelativePath&quot;</span>, <span class="hljs-string">&quot;Public/MyInterface.h&quot;</span>&#125;,<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">const</span> UECodeGen_Private::FFunctionParams Z_Construct_UFunction_UMyInterface_BPFun_Statics::FuncParams = &#123;<br>(UObject*(*)())Z_Construct_UClass_UMyInterface, <span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;BPFun&quot;</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>,<br>RF_Public | RF_Transient | RF_MarkAsNative, (EFunctionFlags)<span class="hljs-number">0x48020800</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">METADATA_PARAMS</span>(<br>Z_Construct_UFunction_UMyInterface_BPFun_Statics::Function_MetaDataParams,<br><span class="hljs-built_in">UE_ARRAY_COUNT</span>(Z_Construct_UFunction_UMyInterface_BPFun_Statics::Function_MetaDataParams))<br>&#125;;<br><br><span class="hljs-function">UFunction* <span class="hljs-title">Z_Construct_UFunction_UMyInterface_BPFun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">static</span> UFunction* ReturnFunction = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">if</span> (!ReturnFunction)<br>&#123;<br>UECodeGen_Private::<span class="hljs-built_in">ConstructUFunction</span>(&amp;ReturnFunction,<br>                                      Z_Construct_UFunction_UMyInterface_BPFun_Statics::FuncParams);<br>&#125;<br><span class="hljs-keyword">return</span> ReturnFunction;<br>&#125;<br><br>FClassRegistrationInfo Z_Registration_Info_UClass_UMyInterface;<br><br><span class="hljs-function">UClass* <span class="hljs-title">UMyInterface::GetPrivateStaticClass</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!Z_Registration_Info_UClass_UMyInterface.InnerSingleton)<br>&#123;<br><span class="hljs-built_in">GetPrivateStaticClassBody</span>(<span class="hljs-built_in">StaticPackage</span>(),<br>(TCHAR*)<span class="hljs-string">L&quot;UMyInterface&quot;</span> + <span class="hljs-number">1</span> + ((StaticClassFlags &amp; CLASS_Deprecated) ? <span class="hljs-number">11</span> : <span class="hljs-number">0</span>),<br>Z_Registration_Info_UClass_UMyInterface.InnerSingleton,<br>StaticRegisterNativesUMyInterface, <br><span class="hljs-built_in">sizeof</span>(UMyInterface), <br><span class="hljs-built_in">alignof</span>(UMyInterface),<br>(EClassFlags)UMyInterface::StaticClassFlags, <br>UMyInterface::<span class="hljs-built_in">StaticClassCastFlags</span>(),<br>UMyInterface::<span class="hljs-built_in">StaticConfigName</span>(),<br>(UClass::ClassConstructorType)InternalConstructor&lt;UMyInterface&gt;,<br>(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller&lt;UMyInterface&gt;,<br><span class="hljs-built_in">FUObjectCppClassStaticFunctions</span>(<br>  FUObjectCppClassStaticFunctions::<span class="hljs-built_in">AddReferencedObjectsType</span>(<br>  &amp;UMyInterface::AddReferencedObjects),<br>  FUObjectCppClassStaticFunctions::<span class="hljs-built_in">DeclareCustomVersionsType</span>(<br>  &amp;UMyInterface::DeclareCustomVersions),<br>  FUObjectCppClassStaticFunctions::<span class="hljs-built_in">AppendToClassSchemaType</span>(<br>  &amp;UMyInterface::AppendToClassSchema),<br>  FUObjectCppClassStaticFunctions::<span class="hljs-built_in">DeclareConstructClassesType</span>(<br>  &amp;UMyInterface::DeclareConstructClasses)), <br>  &amp;UMyInterface::Super::StaticClass,<br>&amp;UMyInterface::WithinClass::StaticClass);<br>&#125;<br><span class="hljs-keyword">return</span> Z_Registration_Info_UClass_UMyInterface.InnerSingleton;<br>&#125;;<br><br><span class="hljs-function">UClass* <span class="hljs-title">Z_Construct_UClass_UMyInterface_NoRegister</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> UMyInterface::<span class="hljs-built_in">StaticClass</span>();<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Z_Construct_UClass_UMyInterface_Statics</span><br>&#123;<br><span class="hljs-type">static</span> UObject* (*<span class="hljs-type">const</span> DependentSingletons[])();<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> FClassFunctionLinkInfo FuncInfo[];<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> WITH_METADATA</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FMetaDataPairParam Class_MetaDataParams[];<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> FCppClassTypeInfoStatic StaticCppClassTypeInfo;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FClassParams ClassParams;<br>&#125;;<br><br>UObject* (*<span class="hljs-type">const</span> Z_Construct_UClass_UMyInterface_Statics::DependentSingletons[])() = &#123;<br>(UObject* (*)())Z_Construct_UClass_UInterface,<br>(UObject* (*)())Z_Construct_UPackage__Script_UObjectLearn,<br>&#125;;<br><span class="hljs-type">const</span> FClassFunctionLinkInfo Z_Construct_UClass_UMyInterface_Statics::FuncInfo[] = &#123;<br>&#123;&amp;Z_Construct_UFunction_UMyInterface_BPFun, <span class="hljs-string">&quot;BPFun&quot;</span>&#125;, <span class="hljs-comment">// 4112179274</span><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> WITH_METADATA</span><br><span class="hljs-type">const</span> UECodeGen_Private::FMetaDataPairParam Z_Construct_UClass_UMyInterface_Statics::Class_MetaDataParams[] = &#123;<br>&#123;<span class="hljs-string">&quot;BlueprintType&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;ModuleRelativePath&quot;</span>, <span class="hljs-string">&quot;Public/MyInterface.h&quot;</span>&#125;,<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">const</span> FCppClassTypeInfoStatic Z_Construct_UClass_UMyInterface_Statics::StaticCppClassTypeInfo = &#123;<br>TCppClassTypeTraits&lt;IMyInterface&gt;::IsAbstract,<br>&#125;;<br><span class="hljs-type">const</span> UECodeGen_Private::FClassParams Z_Construct_UClass_UMyInterface_Statics::ClassParams = &#123;<br>&amp;UMyInterface::StaticClass,<br><span class="hljs-literal">nullptr</span>,<br>&amp;StaticCppClassTypeInfo,<br>DependentSingletons,<br>FuncInfo,<br><span class="hljs-literal">nullptr</span>,<br><span class="hljs-literal">nullptr</span>,<br><span class="hljs-built_in">UE_ARRAY_COUNT</span>(DependentSingletons),<br><span class="hljs-built_in">UE_ARRAY_COUNT</span>(FuncInfo),<br><span class="hljs-number">0</span>,<br><span class="hljs-number">0</span>,<br><span class="hljs-number">0x000040A1u</span>,<br><span class="hljs-built_in">METADATA_PARAMS</span>(Z_Construct_UClass_UMyInterface_Statics::Class_MetaDataParams,<br>                <span class="hljs-built_in">UE_ARRAY_COUNT</span>(Z_Construct_UClass_UMyInterface_Statics::Class_MetaDataParams))<br>&#125;;<br><br><span class="hljs-function">UClass* <span class="hljs-title">Z_Construct_UClass_UMyInterface</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!Z_Registration_Info_UClass_UMyInterface.OuterSingleton)<br>&#123;<br>UECodeGen_Private::<span class="hljs-built_in">ConstructUClass</span>(Z_Registration_Info_UClass_UMyInterface.OuterSingleton,<br>                                   Z_Construct_UClass_UMyInterface_Statics::ClassParams);<br>&#125;<br><span class="hljs-keyword">return</span> Z_Registration_Info_UClass_UMyInterface.OuterSingleton;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;&gt;<br>UOBJECTLEARN_API UClass* <span class="hljs-built_in">StaticClass</span>&lt;UMyInterface&gt;()<br>&#123;<br><span class="hljs-keyword">return</span> UMyInterface::<span class="hljs-built_in">StaticClass</span>();<br>&#125;<br><br>UMyInterface::<span class="hljs-built_in">UMyInterface</span>(FVTableHelper&amp; Helper) : <span class="hljs-built_in">Super</span>(Helper)<br>&#123;<br>&#125;;;<br><br>UMyInterface::~<span class="hljs-built_in">UMyInterface</span>()<br>&#123;<br>&#125;<br><br><span class="hljs-type">static</span> FName NAME_UMyInterface_BPFun = <span class="hljs-built_in">FName</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;BPFun&quot;</span>));<br><span class="hljs-comment">// 执行UFunction的方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">IMyInterface::Execute_BPFun</span><span class="hljs-params">(<span class="hljs-type">const</span> UObject* O)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">check</span>(O != <span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">check</span>(O-&gt;<span class="hljs-built_in">GetClass</span>()-&gt;<span class="hljs-built_in">ImplementsInterface</span>(UMyInterface::<span class="hljs-built_in">StaticClass</span>()));<br>UFunction* <span class="hljs-type">const</span> Func = O-&gt;<span class="hljs-built_in">FindFunction</span>(NAME_UMyInterface_BPFun);<br><span class="hljs-keyword">if</span> (Func)<br>&#123;<br><span class="hljs-built_in">const_cast</span>&lt;UObject*&gt;(O)-&gt;<span class="hljs-built_in">ProcessEvent</span>(Func, <span class="hljs-literal">NULL</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Z_CompiledInDeferFile_FID_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Public_MyInterface_h_Statics</span><br>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> FClassRegisterCompiledInInfo ClassInfo[];<br>&#125;;<br><br><span class="hljs-type">const</span> FClassRegisterCompiledInInfo<br>Z_CompiledInDeferFile_FID_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Public_MyInterface_h_Statics::ClassInfo[]<br>= &#123;<br>&#123;<br>Z_Construct_UClass_UMyInterface, UMyInterface::StaticClass, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;UMyInterface&quot;</span>),<br>&amp;Z_Registration_Info_UClass_UMyInterface,<br><span class="hljs-built_in">CONSTRUCT_RELOAD_VERSION_INFO</span>(FClassReloadVersionInfo, <span class="hljs-built_in">sizeof</span>(UMyInterface), <span class="hljs-number">1095936241U</span>)<br>&#125;,<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">static</span> FRegisterCompiledInInfo</span><br><span class="hljs-function"><span class="hljs-title">Z_CompiledInDeferFile_FID_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Public_MyInterface_h_3890766416</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;/Script/UObjectLearn&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">Z_CompiledInDeferFile_FID_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Public_MyInterface_h_Statics::ClassInfo,</span></span><br><span class="hljs-params"><span class="hljs-function">UE_ARRAY_COUNT(</span></span><br><span class="hljs-params"><span class="hljs-function">Z_CompiledInDeferFile_FID_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Public_MyInterface_h_Statics::</span></span><br><span class="hljs-params"><span class="hljs-function">ClassInfo),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>)</span></span>;<br>PRAGMA_ENABLE_DEPRECATION_WARNINGS<br><br></code></pre></td></tr></table></figure><hr><h2 id="UObject（五）类型系统信息收集"><a href="#UObject（五）类型系统信息收集" class="headerlink" title="UObject（五）类型系统信息收集"></a><a href="https://zhuanlan.zhihu.com/p/26019216">UObject（五）类型系统信息收集</a></h2><h3 id="Static自动注册模式"><a href="#Static自动注册模式" class="headerlink" title="Static自动注册模式"></a>Static自动注册模式</h3><p>全局声明静态成员，在静态成员初始化时，进行构造，调用其构造方法，而构造方法中调用了注册相关的接口，继而实现自动注册。</p><p>这种模式称之为<strong>StaticAutoRegister，其执行是在main函数被执行之前</strong>。</p><p>把static生命再用宏包装一层，就可以实现一个简单的自动注册流程了。</p><p>在C++标准里，不同编译单元的全局静态变量的初始化顺序没有明确规定，所以要注意注册的顺序问题。UE是以Module来组织引擎结构的，一个个Module可以通过脚本配置来选择性的编译加载。</p><h3 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h3><p>对照上文的生成代码，分别介绍Class(Interface同理)、Enum、Struct等的信息收集方式。</p><h4 id="Class的收集"><a href="#Class的收集" class="headerlink" title="Class的收集"></a>Class的收集</h4><p>UHT生成的命名过长，为了阅读方便，忽略了字符：<code>FID_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_</code></p><p>在MyClass.gen.cpp中，有如下Static自动注册：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Z_CompiledInDeferFile_MyClass_h_Statics</span><br>&#123;<br><span class="hljs-comment">// 类的编译信息，由静态方法定义时进行赋值，有几个UClass就有几个ClassInfo</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> FClassRegisterCompiledInInfo ClassInfo[];<br>&#125;;<br><span class="hljs-comment">////////////////////////// 系统结构声明</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FClassReloadVersionInfo</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> WITH_RELOAD</span><br>SIZE_T Size = <span class="hljs-number">0</span>;<br>uint32 Hash = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br><span class="hljs-keyword">using</span> FClassRegistrationInfo = TRegistrationInfo&lt;UClass, FClassReloadVersionInfo&gt;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FClassRegisterCompiledInInfo</span><br>&#123;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UClass</span>* (*OuterRegister)();<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UClass</span>* (*InnerRegister)();<br><span class="hljs-type">const</span> TCHAR* Name;<br>FClassRegistrationInfo* Info;<br>FClassReloadVersionInfo VersionInfo;<br>&#125;;<br><span class="hljs-comment">////////////////////////// </span><br><span class="hljs-comment">// 定义CompiledInInfo，即FClassRegisterCompiledInInfo</span><br><span class="hljs-type">const</span> FClassRegisterCompiledInInfo<br>Z_CompiledInDeferFile_MyClass_h_Statics::ClassInfo[] =<br>&#123;<br>&#123;<br>Z_Construct_UClass_UMyClass,  <span class="hljs-comment">// .OuterRegister</span><br>UMyClass::StaticClass,       <span class="hljs-comment">// .InnerRegister</span><br><span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;UMyClass&quot;</span>), <span class="hljs-comment">// .Name</span><br>&amp;Z_Registration_Info_UClass_UMyClass,<span class="hljs-comment">// .Info</span><br><span class="hljs-built_in">CONSTRUCT_RELOAD_VERSION_INFO</span>(FClassReloadVersionInfo, <span class="hljs-built_in">sizeof</span>(UMyClass), <span class="hljs-number">343687568U</span>) <span class="hljs-comment">// .VersionInfo</span><br>&#125;,<br>&#125;;<br><span class="hljs-comment">// 静态注册:FRegisterCompiledInInfo </span><br><span class="hljs-function"><span class="hljs-type">static</span> FRegisterCompiledInInfo <span class="hljs-title">Z_CompiledInDeferFile_MyClass_h_3142771497</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;/Script/UObjectLearn&quot;</span>), <span class="hljs-comment">// .PackageName</span></span></span><br><span class="hljs-params"><span class="hljs-function">Z_CompiledInDeferFile_MyClass_h_Statics::ClassInfo, <span class="hljs-comment">// .ClassInfo</span></span></span><br><span class="hljs-params"><span class="hljs-function">UE_ARRAY_COUNT(Z_CompiledInDeferFile_MyClass_h_Statics::ClassInfo), <span class="hljs-comment">// .NumClassInfo</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-literal">nullptr</span>, <span class="hljs-comment">// .StructInfo</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-number">0</span>,<span class="hljs-comment">// .NumStructInfo</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-literal">nullptr</span>, <span class="hljs-comment">// .EnumInfo</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">// .NumEnumInfo</span><br><span class="hljs-comment">////////////////////////// 系统结构声明</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FRegisterCompiledInInfo</span><br>&#123;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ... Args&gt;<br><span class="hljs-built_in">FRegisterCompiledInInfo</span>(Args&amp;&amp; ... args)<br>&#123;<br><span class="hljs-built_in">RegisterCompiledInInfo</span>(std::forward&lt;Args&gt;(args)...);<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RegisterCompiledInInfo</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> TCHAR* PackageName, </span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> FClassRegisterCompiledInInfo* ClassInfo, <span class="hljs-type">size_t</span> NumClassInfo, </span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> FStructRegisterCompiledInInfo* StructInfo, <span class="hljs-type">size_t</span> NumStructInfo, </span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> FEnumRegisterCompiledInInfo* EnumInfo, <span class="hljs-type">size_t</span> NumEnumInfo)</span> </span><br><span class="hljs-function"></span>&#123;...&#125;<br><span class="hljs-comment">////////////////////////// </span><br></code></pre></td></tr></table></figure><p>可知：通过静态全局声明 <code>FRegisterCompiledInInfo</code>，将 <code>UMyClass</code>通过 <code>FClassRegisterCompiledInInfo</code>进行了注册。<br><code>FClassRegisterCompiledInInfo</code>收集了 <code>OuterRegister</code>、<code>InnerRegister</code>、类名字、<code>TRegistrationInfo&lt;UClass, FClassReloadVersionInfo&gt;</code>对象、<code>FClassReloadVersionInfo</code>对象。</p><p><code>RegisterCompiledInInfo</code>的完整实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RegisterCompiledInInfo</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> TCHAR* PackageName, </span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> FClassRegisterCompiledInInfo* ClassInfo, <span class="hljs-type">size_t</span> NumClassInfo, </span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> FStructRegisterCompiledInInfo* StructInfo, <span class="hljs-type">size_t</span> NumStructInfo, </span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> FEnumRegisterCompiledInInfo* EnumInfo, <span class="hljs-type">size_t</span> NumEnumInfo)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">LLM_SCOPE</span>(ELLMTag::UObject);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> Index = <span class="hljs-number">0</span>; Index &lt; NumClassInfo; ++Index)<br>&#123;<br><span class="hljs-type">const</span> FClassRegisterCompiledInInfo&amp; Info = ClassInfo[Index];<br><span class="hljs-built_in">RegisterCompiledInInfo</span>(Info.OuterRegister, Info.InnerRegister, PackageName, Info.Name, *Info.Info, Info.VersionInfo);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> Index = <span class="hljs-number">0</span>; Index &lt; NumStructInfo; ++Index)<br>&#123;<br><span class="hljs-type">const</span> FStructRegisterCompiledInInfo&amp; Info = StructInfo[Index];<br><span class="hljs-built_in">RegisterCompiledInInfo</span>(Info.OuterRegister, PackageName, Info.Name, *Info.Info, Info.VersionInfo);<br><span class="hljs-keyword">if</span> (Info.CreateCppStructOps != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>UScriptStruct::<span class="hljs-built_in">DeferCppStructOps</span>(<span class="hljs-built_in">FTopLevelAssetPath</span>(<span class="hljs-built_in">FName</span>(PackageName), <span class="hljs-built_in">FName</span>(Info.Name)), (UScriptStruct::ICppStructOps*)Info.<span class="hljs-built_in">CreateCppStructOps</span>());<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> Index = <span class="hljs-number">0</span>; Index &lt; NumEnumInfo; ++Index)<br>&#123;<br><span class="hljs-type">const</span> FEnumRegisterCompiledInInfo&amp; Info = EnumInfo[Index];<br><span class="hljs-built_in">RegisterCompiledInInfo</span>(Info.OuterRegister, PackageName, Info.Name, *Info.Info, Info.VersionInfo);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法中遍历 <code>NumClassInfo</code>，将对应的 <code>ClassInfo</code>，传入 <code>RegisterCompiledInfo</code>的另一个重载方法中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RegisterCompiledInInfo</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">class</span> UClass* (*InOuterRegister)(), </span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">class</span> UClass* (*InInnerRegister)(), </span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> TCHAR* InPackageName, </span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> TCHAR* InName, </span></span><br><span class="hljs-params"><span class="hljs-function">FClassRegistrationInfo&amp; InInfo, </span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> FClassReloadVersionInfo&amp; InVersionInfo)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">check</span>(InOuterRegister);<br><span class="hljs-built_in">check</span>(InInnerRegister);<br>FClassDeferredRegistry::AddResult result = FClassDeferredRegistry::<span class="hljs-built_in">Get</span>().<span class="hljs-built_in">AddRegistration</span>(InOuterRegister, InInnerRegister, InPackageName, InName, InInfo, InVersionInfo);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> WITH_RELOAD</span><br><span class="hljs-keyword">if</span> (result == FClassDeferredRegistry::AddResult::ExistingChanged &amp;&amp; !<span class="hljs-built_in">IsReloadActive</span>())<br>&#123;<br><span class="hljs-comment">// Class exists, this can only happen during hot-reload or live coding</span><br><span class="hljs-built_in">UE_LOG</span>(LogUObjectBase, Fatal, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Trying to recreate changed class &#x27;%s&#x27; outside of hot reload and live coding!&quot;</span>), InName);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-function">FString <span class="hljs-title">NoPrefix</span><span class="hljs-params">(UObjectBase::RemoveClassPrefix(InName))</span></span>;<br><span class="hljs-built_in">NotifyRegistrationEvent</span>(InPackageName, *NoPrefix, ENotifyRegistrationType::NRT_Class, ENotifyRegistrationPhase::NRP_Added, (UObject * (*)())(InOuterRegister), <span class="hljs-literal">false</span>);<br><span class="hljs-built_in">NotifyRegistrationEvent</span>(InPackageName, *(<span class="hljs-built_in">FString</span>(DEFAULT_OBJECT_PREFIX) + NoPrefix), ENotifyRegistrationType::NRT_ClassCDO, ENotifyRegistrationPhase::NRP_Added, (UObject * (*)())(InOuterRegister), <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-keyword">using</span> FClassDeferredRegistry = TDeferredRegistry&lt;FClassRegistrationInfo&gt;; <span class="hljs-comment">// TDeferredRegistry是一个单例</span><br><span class="hljs-keyword">using</span> FClassRegistrationInfo = TRegistrationInfo&lt;UClass, FClassReloadVersionInfo&gt;;<br></code></pre></td></tr></table></figure><p>重点是：<code>FClassDeferredRegistry::Get().AddRegistration(...)</code>，实际就是在向维护的 <code>TArray&lt;FRegistrant&gt; Registrations</code>插入数据，并没有其他的处理，这一步就叫做<strong>收集</strong>。</p><p>仔细观察 <code>RegisterCompiledInInfo</code>的实现，发现其还有针对于 <code>struct</code>和 <code>enum</code>的处理，其原理从代码可知，都是通过了重载对应类型的 <code>RegisterCompiledInInfo</code>方法进行了处理。从 <code>UClass</code>的处理中可以猜得到，<code>struct</code>和 <code>enum</code>必然也维护了对应的 <code>TArray</code>数组进行了数据收集。</p><h4 id="Enum的收集"><a href="#Enum的收集" class="headerlink" title="Enum的收集"></a>Enum的收集</h4><p>接上文，MyEnum.gen.cpp同样也是通过 <code>FRegisterCompiledInInfo</code>的静态注册的方式进行了信息的收集。方式与 <code>UClass</code>的收集一致，下面是针对 <code>UEnum</code>进行了重载的 <code>RegisterCompiledInInfo</code>实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RegisterCompiledInInfo</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">class</span> UEnum* (*InOuterRegister)(), <span class="hljs-comment">// </span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> TCHAR* InPackageName, </span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> TCHAR* InName, </span></span><br><span class="hljs-params"><span class="hljs-function">FEnumRegistrationInfo&amp; InInfo, </span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> FEnumReloadVersionInfo&amp; InVersionInfo)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">check</span>(InOuterRegister);<br>FEnumDeferredRegistry::<span class="hljs-built_in">Get</span>().<span class="hljs-built_in">AddRegistration</span>(InOuterRegister, <span class="hljs-literal">nullptr</span>, InPackageName, InName, InInfo, InVersionInfo);<br><span class="hljs-built_in">NotifyRegistrationEvent</span>(InPackageName, InName, ENotifyRegistrationType::NRT_Enum, ENotifyRegistrationPhase::NRP_Added, (UObject * (*)())(InOuterRegister), <span class="hljs-literal">false</span>);<br>&#125;<br><span class="hljs-keyword">using</span> FEnumDeferredRegistry = TDeferredRegistry&lt;FEnumRegistrationInfo&gt;;<br></code></pre></td></tr></table></figure><h4 id="Struct的收集"><a href="#Struct的收集" class="headerlink" title="Struct的收集"></a>Struct的收集</h4><p>类似的，<code>struct</code>也是一样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">RegisterCompiledInInfo</span><span class="hljs-params">(</span><br><span class="hljs-params">class UScriptStruct* (*InOuterRegister)(), </span><br><span class="hljs-params"><span class="hljs-type">const</span> TCHAR* InPackageName, </span><br><span class="hljs-params"><span class="hljs-type">const</span> TCHAR* InName, </span><br><span class="hljs-params">FStructRegistrationInfo&amp; InInfo, </span><br><span class="hljs-params"><span class="hljs-type">const</span> FStructReloadVersionInfo&amp; InVersionInfo)</span><br>&#123;<br>check(InOuterRegister);<br>FStructDeferredRegistry::Get().AddRegistration(InOuterRegister, nullptr, InPackageName, InName, InInfo, InVersionInfo);<br>NotifyRegistrationEvent(InPackageName, InName, ENotifyRegistrationType::NRT_Struct, ENotifyRegistrationPhase::NRP_Added, (UObject * (*)())(InOuterRegister), <span class="hljs-literal">false</span>);<br>&#125;<br>using FStructDeferredRegistry = TDeferredRegistry&lt;FStructRegistrationInfo&gt;;<br></code></pre></td></tr></table></figure><p>而比较特殊的是，struct还有如下的特殊处理，存储了 <code>TCppStructOps</code>，用于管理c++ struct：<br><em><code>Interface to template to manage dynamic access to C++ struct construction and destruction</code></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">UScriptStruct::<span class="hljs-built_in">DeferCppStructOps</span>(<span class="hljs-built_in">FTopLevelAssetPath</span>(<span class="hljs-built_in">FName</span>(PackageName), <span class="hljs-built_in">FName</span>(Info.Name)), (UScriptStruct::ICppStructOps*)Info.<span class="hljs-built_in">CreateCppStructOps</span>());<br></code></pre></td></tr></table></figure><p>其用意就在于如果对于一块已经擦除了类型的内存数据，我们怎么能在其上正确的构造结构对象数据或者析构。这个时候，如果我们能够得到一个统一的 <code>ICppStructOps*</code>指针指向类型安全的 <code>TCppStructOps&lt;CPPSTRUCT&gt;</code>对象，就能够通过接口函数动态、多态、类型安全的执行构造和析构工作。</p><h4 id="Function的收集"><a href="#Function的收集" class="headerlink" title="Function的收集"></a>Function的收集</h4><p>首先 <code>UMyClass::StaticRegisterNativesUMyClass</code>调用了 <code>FNativeFunctionRegistrar::RegisterFunctions</code>来将方法注册到 <code>UClass</code>中，该方法通过 <code>GetPrivateStaticClass</code>传入并调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">UMyClass::StaticRegisterNativesUMyClass</span><span class="hljs-params">()</span><br>&#123;<br>UClass* Class = UMyClass::StaticClass();<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> FNameNativePtrPair Funcs[] = &#123;<br>&#123;<span class="hljs-string">&quot;CallableFunc&quot;</span>, &amp;UMyClass::execCallableFunc&#125;,<br>&#123;<span class="hljs-string">&quot;NativeFunc&quot;</span>, &amp;UMyClass::execNativeFunc&#125;,<br>&#125;;<br>FNativeFunctionRegistrar::RegisterFunctions(Class, Funcs, UE_ARRAY_COUNT(Funcs));<br>&#125;<br></code></pre></td></tr></table></figure><p>其次在通过 <code>FRegisterCompiledInInfo</code>进行注册 <code>UClass</code>时，会同时将 <code>UFunction</code>注册（收集）进去。</p><h4 id="UObject的收集"><a href="#UObject的收集" class="headerlink" title="UObject的收集"></a>UObject的收集</h4><p>在第一次调用 <code>UObject::StaticClass()</code>时，检测到 <code>UClass*</code>未生成，则会转发到 <code>GetPrivateStaticClassBody </code>中去生成一个 <code>UClass*</code>。</p><hr><h2 id="UObject（六）类型系统代码生成重构-UE4CodeGen-Private"><a href="#UObject（六）类型系统代码生成重构-UE4CodeGen-Private" class="headerlink" title="UObject（六）类型系统代码生成重构-UE4CodeGen_Private"></a><a href="https://zhuanlan.zhihu.com/p/34059049">UObject（六）类型系统代码生成重构-UE4CodeGen_Private</a></h2><h3 id="UECodeGen-Private"><a href="#UECodeGen-Private" class="headerlink" title="UECodeGen_Private"></a>UECodeGen_Private</h3><p>简单说在UE的开发迭代过程中，会不断进行优化，文中讲到的代码生成重构，核心是说新增了UE4CodeGen_Private系列方法，其提供了UFunction、UEnum、UScriptStruct、UPackage和UClass的构造实现。</p><p>UE5.1中，名字已经改为更加通用的 <code>UECodeGen_Private</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> UECodeGen_Private<br>&#123;<br>...各种Params结构的声明<br><span class="hljs-built_in">UE_DEPRECATED</span>(<span class="hljs-number">5.0</span>, <span class="hljs-string">&quot;ConstructUFunction deprecated.  Please use the version of ConstructUFunction which retains the singleton pointer.&quot;</span>)<br><span class="hljs-function">COREUOBJECT_API <span class="hljs-type">void</span> <span class="hljs-title">ConstructUFunction</span><span class="hljs-params">(UFunction*&amp; OutFunction, <span class="hljs-type">const</span> FFunctionParams&amp; Params)</span></span>;<br><span class="hljs-function">COREUOBJECT_API <span class="hljs-type">void</span> <span class="hljs-title">ConstructUFunction</span><span class="hljs-params">(UFunction** SingletonPtr, <span class="hljs-type">const</span> FFunctionParams&amp; Params)</span></span>;<br><span class="hljs-function">COREUOBJECT_API <span class="hljs-type">void</span> <span class="hljs-title">ConstructUEnum</span><span class="hljs-params">(UEnum*&amp; OutEnum, <span class="hljs-type">const</span> FEnumParams&amp; Params)</span></span>;<br><span class="hljs-function">COREUOBJECT_API <span class="hljs-type">void</span> <span class="hljs-title">ConstructUScriptStruct</span><span class="hljs-params">(UScriptStruct*&amp; OutStruct, <span class="hljs-type">const</span> FStructParams&amp; Params)</span></span>;<br><span class="hljs-function">COREUOBJECT_API <span class="hljs-type">void</span> <span class="hljs-title">ConstructUPackage</span><span class="hljs-params">(UPackage*&amp; OutPackage, <span class="hljs-type">const</span> FPackageParams&amp; Params)</span></span>;<br><span class="hljs-function">COREUOBJECT_API <span class="hljs-type">void</span> <span class="hljs-title">ConstructUClass</span><span class="hljs-params">(UClass*&amp; OutClass, <span class="hljs-type">const</span> FClassParams&amp; Params)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思考：为什么生成的代码里大量用了函数指针来返回对象？</strong></p><p>函数指针实际是一个工厂方法，其内部维护了已经静态成员指针，如果为空，则进行构造，最终返回一个对象。这么做的目的是解决静态依赖，在用到的时候在去构造。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">UClass* <span class="hljs-title">Z_Construct_UClass_UMyClass</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!Z_Registration_Info_UClass_UMyClass.OuterSingleton)<br>&#123;<br>UECodeGen_Private::<span class="hljs-built_in">ConstructUClass</span>(Z_Registration_Info_UClass_UMyClass.OuterSingleton,<br>                                   Z_Construct_UClass_UMyClass_Statics::ClassParams);<br>&#125;<br><span class="hljs-keyword">return</span> Z_Registration_Info_UClass_UMyClass.OuterSingleton;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="UObject（七）类型系统注册-第一个UClass"><a href="#UObject（七）类型系统注册-第一个UClass" class="headerlink" title="UObject（七）类型系统注册-第一个UClass"></a><a href="https://zhuanlan.zhihu.com/p/57005310">UObject（七）类型系统注册-第一个UClass</a></h2><p>UHT利用代码里的宏标记来生成反射代码来记录信息，在main函数调用之前，利用静态变量的初始化来收集这些类型的原数据信息到一个个的数据结构里。</p><p>接下来，就是将收集到的信息进行注册。而注册的第一步也就是static初始化的最后一步就是创建出第一个UClass-&gt;UObject。</p><h3 id="UObject的收集-1"><a href="#UObject的收集-1" class="headerlink" title="UObject的收集"></a>UObject的收集</h3><p>UObject作为类型系统的根，是什么时候触发相应的UClass*生成的呢？<br>在 <code>ScriptCore.cpp</code>中，有对 <code>execCallMathFunction</code>的声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ScriptCore.cpp</span><br><span class="hljs-built_in">IMPLEMENT_VM_FUNCTION</span>(EX_CallMath, execCallMathFunction);<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMPLEMENT_VM_FUNCTION(BytecodeIndex, func) \</span><br><span class="hljs-meta">STORE_INSTRUCTION_NAME(BytecodeIndex) \</span><br><span class="hljs-meta">IMPLEMENT_FUNCTION(func) \</span><br><span class="hljs-meta">static uint8 UObject##func##BytecodeTemp = GRegisterNative( BytecodeIndex, &amp;UObject::func );</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMPLEMENT_FUNCTION(func) \</span><br><span class="hljs-meta">static FNativeFunctionRegistrar UObject##func##Registar(UObject::StaticClass(),#func,&amp;UObject::func);</span><br></code></pre></td></tr></table></figure><p>展开后，可以发现一个static初始化的实现，而其第一个参数就是 <code>UObject::StaticClass()</code></p><blockquote><p>其实不用纠结为什么execCallMatchFunction是第一个，重点在于其调用了UObject::StaticClass()，func是什么其实无所谓</p></blockquote><p>而 <code>UObject</code>的 <code>StaticClass</code>的实现（<code>DECLARE_CLASS </code>），调用了 <code>GetPrivateStaticClass</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">static</span> UClass* <span class="hljs-title">StaticClass</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">GetPrivateStaticClass</span>(); <br>&#125; <br></code></pre></td></tr></table></figure><p>UHT会自动生成 <code>GetPrivateStaticClass()</code>（参见UCLASS生成代码剖析部分 <code>IMPLEMENT_CLASS</code>)。而UObject的 <code>IMPLEMENT_CLASS</code>是定义在了 <code>NoExportTypes.h</code>中。</p><h3 id="NoExportTypes-h"><a href="#NoExportTypes-h" class="headerlink" title="NoExportTypes.h"></a>NoExportTypes.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">if</span> CPP</span><br><br><span class="hljs-comment">//包含一些头文件来让NoExportTypes.gen.cpp可以编译通过</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !CPP<span class="hljs-comment">//这里面的部分是不参与编译的，所以不会产生定义冲突，但是却可以让UHT分析，因为UHT只是个文本分析器而已。</span></span><br><br><span class="hljs-comment">//枚举的声明，只是加上了宏标记。</span><br><span class="hljs-comment">//结构的声明，只是加上了宏标记。</span><br><br><span class="hljs-comment">//UObject的声明，C++的内容其实不重要，重要的是让UHT分析得到些什么信息</span><br><span class="hljs-built_in">UCLASS</span>(abstract, noexport)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UObject</span><br>&#123;<br>    <span class="hljs-built_in">GENERATED_BODY</span>()<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UFUNCTION</span>(BlueprintImplementableEvent, meta=(BlueprintInternalUseOnly = <span class="hljs-string">&quot;true&quot;</span>))<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ExecuteUbergraph</span><span class="hljs-params">(int32 EntryPoint)</span></span>;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>这样，UHT生成的 <code>NoexportTypes.gen.cpp</code>中，就定义了该 <code>IMPLEMENT_CLASS</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">IMPLEMENT_CLASS_NO_AUTO_REGISTRATION</span>(UObject);<br></code></pre></td></tr></table></figure><h3 id="GetPrivateStaticClass"><a href="#GetPrivateStaticClass" class="headerlink" title="GetPrivateStaticClass"></a>GetPrivateStaticClass</h3><p><code>IMPLEMENT_CLASS</code>展开后，定义了 <code>GetPrivateStaticClass</code>的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 类的声明</span><br><span class="hljs-built_in">DECLARE_CLASS</span>(UObject,UObject,CLASS_Abstract|CLASS_Intrinsic|CLASS_MatchedSerializers,CASTCLASS_None,<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;/Script/CoreUObject&quot;</span>),NO_API)<br><br><span class="hljs-comment">// 实现的展开</span><br>FClassRegistrationInfo Z_Registration_Info_UClass_UObject;<br><br><span class="hljs-function">UClass* <span class="hljs-title">UObject::GetPrivateStaticClass</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!Z_Registration_Info_UClass_UObject.InnerSingleton)<br>&#123;<br><span class="hljs-built_in">GetPrivateStaticClassBody</span>(<br><span class="hljs-built_in">StaticPackage</span>(), <span class="hljs-comment">// 包名，这里是TEXT(&quot;/Script/CoreUObject&quot;)</span><br>(TCHAR*)<span class="hljs-string">L&quot;UObject&quot;</span> + <span class="hljs-number">1</span> + ((StaticClassFlags &amp; CLASS_Deprecated) ? <span class="hljs-number">11</span> : <span class="hljs-number">0</span>), <span class="hljs-comment">//类名，+1去掉U、A、F前缀，+11去掉Deprecated_前缀</span><br>Z_Registration_Info_UClass_UObject.InnerSingleton, <span class="hljs-comment">// 输出的引用</span><br>StaticRegisterNativesUObject, <span class="hljs-comment">// 注册类Native函数的指针</span><br><span class="hljs-built_in">sizeof</span>(UObject), <span class="hljs-comment">// 类大小</span><br><span class="hljs-built_in">alignof</span>(UObject), <span class="hljs-comment">// 类对齐方式</span><br>(EClassFlags)UObject::StaticClassFlags, <span class="hljs-comment">// 类标记，CLASS_Abstract|CLASS_Intrinsic|CLASS_MatchedSerializers</span><br>UObject::<span class="hljs-built_in">StaticClassCastFlags</span>(), <span class="hljs-comment">// 虽然是调用，但只是简单返回值CASTCLASS_None</span><br>UObject::<span class="hljs-built_in">StaticConfigName</span>(), <span class="hljs-comment">// 配置文件名，用于从config里读取值 TEXT(&quot;Engine&quot;)</span><br>(UClass::ClassConstructorType)InternalConstructor&lt;UObject&gt;, <span class="hljs-comment">//构造函数指针，包了一层 __DefaultConstructor</span><br>(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller&lt;UObject&gt;,<span class="hljs-comment">//hotreload的时候使用来构造虚函数表 __VTableCtorCaller</span><br><span class="hljs-built_in">FUObjectCppClassStaticFunctions</span>( <span class="hljs-comment">//GC使用的添加额外引用对象的静态函数指针</span><br>  FUObjectCppClassStaticFunctions::<span class="hljs-built_in">AddReferencedObjectsType</span>(&amp;UObject::AddReferencedObjects),<br>  FUObjectCppClassStaticFunctions::<span class="hljs-built_in">DeclareCustomVersionsType</span>(&amp;UObject::DeclareCustomVersions),<br>  FUObjectCppClassStaticFunctions::<span class="hljs-built_in">AppendToClassSchemaType</span>(&amp;UObject::AppendToClassSchema),<br>  FUObjectCppClassStaticFunctions::<span class="hljs-built_in">DeclareConstructClassesType</span>(&amp;UObject::DeclareConstructClasses)), <br>&amp;UObject::Super::StaticClass, <span class="hljs-comment">// 获取基类UClass*的函数指针，这里Super是UObject</span><br>&amp;UObject::WithinClass::StaticClass); <span class="hljs-comment">//获取对象外部类UClass*的函数指针，默认是UObject</span><br>&#125;<br><span class="hljs-keyword">return</span> Z_Registration_Info_UClass_UObject.InnerSingleton;<br>&#125;;<br></code></pre></td></tr></table></figure><p>大部分细节在前文生成代码剖析部分做过解释，此处不再赘述。</p><p>这里解释一下 <code>Super</code>和 <code>WithinClass</code>：<br><code>Super</code>指的是类的基类，<code>WithinClass</code>指的是对象的Outer对象的类型。这里要区分开的是类型系统和对象系统之间的差异，<code>Super</code>表示的是类型上的必须依赖于基类先构建 <code>UClass*</code>才能构建构建子类的 <code>UClass*</code>；<code>WithinClass</code>表示的是这个 <code>UObject*</code>在构建好之后应该限制放在哪种Outer下面，这个Outer所属于的 <code>UClass*</code>我们必须先提前构建好。</p><h3 id="GetPrivateStaticClassBody"><a href="#GetPrivateStaticClassBody" class="headerlink" title="GetPrivateStaticClassBody"></a>GetPrivateStaticClassBody</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GetPrivateStaticClassBody</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> TCHAR* PackageName,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> TCHAR* Name,</span></span><br><span class="hljs-params"><span class="hljs-function">UClass*&amp; ReturnClass,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">void</span>(*RegisterNativeFunc)(),</span></span><br><span class="hljs-params"><span class="hljs-function">uint32 InSize,</span></span><br><span class="hljs-params"><span class="hljs-function">uint32 InAlignment,</span></span><br><span class="hljs-params"><span class="hljs-function">EClassFlags InClassFlags,</span></span><br><span class="hljs-params"><span class="hljs-function">EClassCastFlags InClassCastFlags,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> TCHAR* InConfigName,</span></span><br><span class="hljs-params"><span class="hljs-function">UClass::ClassConstructorType InClassConstructor,</span></span><br><span class="hljs-params"><span class="hljs-function">UClass::ClassVTableHelperCtorCallerType InClassVTableHelperCtorCaller,</span></span><br><span class="hljs-params"><span class="hljs-function">FUObjectCppClassStaticFunctions&amp;&amp; InCppClassStaticFunctions,</span></span><br><span class="hljs-params"><span class="hljs-function">UClass::StaticClassFunctionType InSuperClassFn,</span></span><br><span class="hljs-params"><span class="hljs-function">UClass::StaticClassFunctionType InWithinClassFn</span></span><br><span class="hljs-params"><span class="hljs-function">)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 分配内存(UE的全局内存分配器),这里理解为返回一块内存即可。</span><br>ReturnClass = (UClass*)GUObjectAllocator.<span class="hljs-built_in">AllocateUObject</span>(<span class="hljs-built_in">sizeof</span>(UClass), <span class="hljs-built_in">alignof</span>(UClass), <span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 注意执行到这里，外部的Z_Registration_Info_UClass_UObject.InnerSingleton就有值了</span><br><br><span class="hljs-comment">// 用placement new 在内存上手动调用构造函数。这么做的原因是UE内存是统一管理的，所以将内存分配和调用构造分开。</span><br>ReturnClass = ::<span class="hljs-built_in">new</span> (ReturnClass)<br><span class="hljs-built_in">UClass</span><br>(<br>EC_StaticConstructor,<br>Name,<br>InSize,<br>InAlignment,<br>InClassFlags,<br>InClassCastFlags,<br>InConfigName,<br><span class="hljs-built_in">EObjectFlags</span>(RF_Public | RF_Standalone | RF_Transient | RF_MarkAsNative | RF_MarkAsRootSet),<br>InClassConstructor,<br>InClassVTableHelperCtorCaller,<br><span class="hljs-built_in">MoveTemp</span>(InCppClassStaticFunctions)<br>);<br><span class="hljs-built_in">check</span>(ReturnClass);<br><span class="hljs-comment">// 初始化UClass*对象</span><br><span class="hljs-built_in">InitializePrivateStaticClass</span>(<br><span class="hljs-built_in">InSuperClassFn</span>(),<br>ReturnClass,<br><span class="hljs-built_in">InWithinClassFn</span>(),<br>PackageName,<br>Name<br>);<br><span class="hljs-comment">// 注册Native函数到UClass中去。(Native函数指的是在C++有函数体实现的函数，而蓝图中的函数和BlueprintImplementableEvent的函数就不是Native函数)</span><br><span class="hljs-built_in">RegisterNativeFunc</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="InitializePrivateStaticClass"><a href="#InitializePrivateStaticClass" class="headerlink" title="InitializePrivateStaticClass"></a>InitializePrivateStaticClass</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">COREUOBJECT_API <span class="hljs-type">void</span> <span class="hljs-title">InitializePrivateStaticClass</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">class</span> UClass* TClass_Super_StaticClass,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">class</span> UClass* TClass_PrivateStaticClass,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">class</span> UClass* TClass_WithinClass_StaticClass,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> TCHAR* PackageName,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> TCHAR* Name</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">TRACE_LOADTIME_CLASS_INFO</span>(TClass_PrivateStaticClass, Name);<br><br><span class="hljs-comment">/* No recursive ::StaticClass calls allowed. Setup extras. */</span><br><span class="hljs-keyword">if</span> (TClass_Super_StaticClass != TClass_PrivateStaticClass)<br>&#123; <span class="hljs-comment">//设定类之间的SuperStruct</span><br>TClass_PrivateStaticClass-&gt;<span class="hljs-built_in">SetSuperStruct</span>(TClass_Super_StaticClass);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>TClass_PrivateStaticClass-&gt;<span class="hljs-built_in">SetSuperStruct</span>(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">//UObject无基类</span><br>&#125;<br>TClass_PrivateStaticClass-&gt;ClassWithin = TClass_WithinClass_StaticClass; <span class="hljs-comment">//设定Outer类类型</span><br><br><span class="hljs-comment">// Register the class&#x27;s dependencies, then itself.</span><br>TClass_PrivateStaticClass-&gt;<span class="hljs-built_in">RegisterDependencies</span>();<br>&#123;<br><span class="hljs-comment">// Defer</span><br>TClass_PrivateStaticClass-&gt;<span class="hljs-built_in">Register</span>(PackageName, Name);<span class="hljs-comment">//转到UObjectBase::Register()</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="UObjectBase-Register"><a href="#UObjectBase-Register" class="headerlink" title="UObjectBase::Register()"></a>UObjectBase::Register()</h3><p>这里终于对 <code>UClass*</code>开始了注册。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FPendingRegistrantInfo</span><br>&#123;<br><span class="hljs-type">const</span> TCHAR*Name; <span class="hljs-comment">//对象名字</span><br><span class="hljs-type">const</span> TCHAR*PackageName; <span class="hljs-comment">//所属包的名字</span><br><span class="hljs-function"><span class="hljs-type">static</span> TMap&lt;UObjectBase*, FPendingRegistrantInfo&gt;&amp; <span class="hljs-title">GetMap</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//用对象指针做Key，这样才可以通过对象地址获得其名字信息，这个时候UClass对象本身其实还没有名字，要等之后的注册才能设置进去</span><br><span class="hljs-type">static</span> TMap&lt;UObjectBase*, FPendingRegistrantInfo&gt; PendingRegistrantInfo;<br><span class="hljs-keyword">return</span> PendingRegistrantInfo;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FPendingRegistrant</span><br>&#123;<br>UObjectBase*Object; <span class="hljs-comment">// 对象指针，用该值去PendingRegistrants里查找名字。</span><br>FPendingRegistrant*NextAutoRegister; <span class="hljs-comment">// 链表下一个节点</span><br>&#125;;<br><span class="hljs-type">static</span> FPendingRegistrant* GFirstPendingRegistrant = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//全局链表头</span><br><span class="hljs-type">static</span> FPendingRegistrant* GLastPendingRegistrant = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//全局链表尾</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UObjectBase::Register</span><span class="hljs-params">(<span class="hljs-type">const</span> TCHAR* PackageName,<span class="hljs-type">const</span> TCHAR* InName)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 添加到全局单件Map里，用对象指针做Key，Value是对象的名字和所属包的名字。</span><br>TMap&lt;UObjectBase*, FPendingRegistrantInfo&gt;&amp; PendingRegistrants = FPendingRegistrantInfo::<span class="hljs-built_in">GetMap</span>();<br><br>FPendingRegistrant* PendingRegistration = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FPendingRegistrant</span>(<span class="hljs-keyword">this</span>);<br>PendingRegistrants.<span class="hljs-built_in">Add</span>(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">FPendingRegistrantInfo</span>(InName, PackageName));<br><br><span class="hljs-comment">// 添加到全局链表里，每个链表节点带着一个本对象指针，简单的链表添加操作</span><br><span class="hljs-keyword">if</span> (GLastPendingRegistrant)<br>&#123;<br>GLastPendingRegistrant-&gt;NextAutoRegister = PendingRegistration;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">check</span>(!GFirstPendingRegistrant);<br>GFirstPendingRegistrant = PendingRegistration;<br>&#125;<br>GLastPendingRegistrant = PendingRegistration;<br>&#125;<br></code></pre></td></tr></table></figure><p>到此，第一个 <code>UClass</code>(即 <code>UObject*</code>)就创建出来了。</p><h3 id="RegisterNativeFunc"><a href="#RegisterNativeFunc" class="headerlink" title="RegisterNativeFunc"></a>RegisterNativeFunc</h3><p>这部分可以参考《Function的收集》部分的内容。这步操作这是简单的往 <code>UClass*</code>里添加Native函数的数据。</p><p><strong>思考：为什么一开始就往UClass里添加Native函数？</strong><br>首先Native函数信息早晚都要添加到UClass中，执行到这里UClass都已经创建出来了，索性直接存到 <code>NativeFunctionLookupTable</code>里。 另外 <code>NativeFunctionLookupTable </code>使用 <code>TArray </code>是因为函数不会很多，<code>TArry</code>的线性查找也比较快，而且省内存。</p><p><strong>思考：非Native函数怎么办？</strong><br><code>BlueprintImplementableEvent</code>不需要我们自己定义函数体，UHT会自动生成一个函数体，当我们在调用的时候，会触发一次函数查找，如果在蓝图中有定义，则会得到调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UMyClass::ImplementableFunc</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">ProcessEvent</span>(<span class="hljs-built_in">FindFunctionChecked</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;ImplementableFunc&quot;</span>),<span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="UObject（八）类型系统注册-CoreUObject模块加载"><a href="#UObject（八）类型系统注册-CoreUObject模块加载" class="headerlink" title="UObject（八）类型系统注册-CoreUObject模块加载"></a><a href="https://zhuanlan.zhihu.com/p/57611137">UObject（八）类型系统注册-CoreUObject模块加载</a></h2><p>之前讲的是程序启动后在执行Main函数前所做的Static初始化阶段。接下来开始介绍Main函数入口进来后的流程。</p><h3 id="引擎整体流程"><a href="#引擎整体流程" class="headerlink" title="引擎整体流程"></a>引擎整体流程</h3><p>PC端的入口在 <code>LanuchWindows.cpp:WinMain</code>。下图中绿色的部分表示有涉及 <code>CoreUObject</code>模块。</p><img src="/2023/05/16/link/UE/UE-C++/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/1680929494406.png" class="" width="1680929494406"><ul><li><p>static初始化就是指的是前文说的收集过程</p></li><li><p>以Windows平台为例，<code>WinMain</code>是 <code>LaunchWindows.cpp</code>里定义的程序入口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">int32 WINAPI <span class="hljs-title">WinMain</span><span class="hljs-params">(_In_ HINSTANCE hInInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ <span class="hljs-type">char</span>* pCmdLine, _In_ int32 nCmdShow)</span></span><br><span class="hljs-function"></span>&#123;<br>int32 Result = <span class="hljs-built_in">LaunchWindowsStartup</span>(hInInstance, hPrevInstance, pCmdLine, nCmdShow, <span class="hljs-literal">nullptr</span>);<br><span class="hljs-built_in">LaunchWindowsShutdown</span>();<br><span class="hljs-keyword">return</span> Result;<br>&#125;<br><span class="hljs-function">LAUNCH_API int32 <span class="hljs-title">LaunchWindowsStartup</span><span class="hljs-params">( HINSTANCE hInInstance, HINSTANCE hPrevInstance, <span class="hljs-type">char</span>*, int32 nCmdShow, <span class="hljs-type">const</span> TCHAR* CmdLine )</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">TRACE_BOOKMARK</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;WinMain.Enter&quot;</span>));<br>...<br>ErrorLevel = <span class="hljs-built_in">GuardedMain</span>( CmdLine );<br>...<br><span class="hljs-keyword">return</span> ErrorLevel;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>GuardedMain</code>是真正的实现程序循环的地方。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">int32 <span class="hljs-title">GuardedMain</span><span class="hljs-params">( <span class="hljs-type">const</span> TCHAR* CmdLine )</span></span><br><span class="hljs-function"></span>&#123;<br>...<br><span class="hljs-comment">//预初始化  转向 GEngineLoop.PreInit( CmdLine );</span><br>int32 ErrorLevel = <span class="hljs-built_in">EnginePreInit</span>( CmdLine );<br>...<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> WITH_EDITOR</span><br><span class="hljs-keyword">if</span> (GIsEditor) <span class="hljs-comment">//编辑器有其初始化版本</span><br>&#123;<br>ErrorLevel = <span class="hljs-built_in">EditorInit</span>(GEngineLoop);<br>&#125;<br><span class="hljs-keyword">else</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#123;<span class="hljs-comment">//Runtime下的初始化    转向 GEngineLoop.Init();</span><br>ErrorLevel = <span class="hljs-built_in">EngineInit</span>();<br>&#125;<br>...<br><span class="hljs-keyword">if</span> (!GUELibraryOverrideSettings.bIsEmbedded)<br>&#123;<br><span class="hljs-keyword">while</span>( !<span class="hljs-built_in">IsEngineExitRequested</span>() )<br>&#123;<br><span class="hljs-built_in">EngineTick</span>();<span class="hljs-comment">//无限循环的Tick    转向 GEngineLoop.Tick();</span><br>&#125;<br>&#125;<br>...<br><span class="hljs-keyword">return</span> ErrorLevel;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>FEngineLoop::PreInit</code>是我们关心的涉及 <code>UObject</code>启动的最开始的地方</p></li></ul><h3 id="FEngineLoop-PreInit"><a href="#FEngineLoop-PreInit" class="headerlink" title="FEngineLoop::PreInit"></a>FEngineLoop::PreInit</h3><p>UE是建立在UObject对象系统上的，所以引擎循环的预初始化部分就得开始加载 <code>CoreUObject</code>了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">int32 <span class="hljs-title">FEngineLoop::PreInit</span><span class="hljs-params">(<span class="hljs-type">const</span> TCHAR* CmdLine)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 注意，下面列出的实现是其调用的一些子方法中的实现，比较零散，统一梳理在这里，用&#123;&#125;控制块表现关键方法的调用层次</span><br>...<br><span class="hljs-built_in">LoadCoreModules</span>(); <span class="hljs-comment">//加载CoreUObject模块</span><br>&#123;<br>FModuleManager::<span class="hljs-built_in">Get</span>().<span class="hljs-built_in">LoadModule</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;CoreUObject&quot;</span>);<br>&#123;<br><span class="hljs-built_in">StartupModule</span>();<br>&#123;<br><span class="hljs-built_in">UClassRegisterAllCompiledInClasses</span>(); <span class="hljs-comment">// 注册到目前为止已加载的所有类</span><br>&#125;<br>&#125;<br>&#125;<br>...<br><span class="hljs-built_in">LoadPreInitModules</span>();<span class="hljs-comment">//加载一些PreInit的模块，比如Engine，Renderer</span><br>...<br><span class="hljs-built_in">AppInit</span>(); <span class="hljs-comment">// 程序初始化</span><br>...<br><span class="hljs-built_in">ProcessNewlyLoadedUObjects</span>(); <span class="hljs-comment">// 处理最近加载的对象，在AppInt()中回调</span><br>...<br>FEngineLoop::<span class="hljs-built_in">LoadStartupModules</span>(); <span class="hljs-comment">// 自己写的LoadingPhase为PreDefault的模块在这个时候加载</span><br>...<br>GUObjectArray.<span class="hljs-built_in">CloseDisregardForGC</span>();    <span class="hljs-comment">//对象池启用，最开始是关闭的</span><br>...<br><span class="hljs-built_in">NotifyRegistrationComplete</span>();   <span class="hljs-comment">//注册完成事件通知，完成Package加载</span><br>&#125;<br></code></pre></td></tr></table></figure><p>最先加载的是 <code>CoreUObject</code>，其中的 <code>LoadCoreModules()</code>内部触发了 <code>FCoreUObjectModule::StartupModule()</code>。</p><h3 id="UClassRegisterAllCompiledInClasses"><a href="#UClassRegisterAllCompiledInClasses" class="headerlink" title="UClassRegisterAllCompiledInClasses"></a>UClassRegisterAllCompiledInClasses</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UClassRegisterAllCompiledInClasses</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>FClassDeferredRegistry&amp; Registry = FClassDeferredRegistry::<span class="hljs-built_in">Get</span>(); <span class="hljs-comment">// 收集的所有UCLASS的注册信息</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> FClassDeferredRegistry::FRegistrant&amp; Registrant : Registry.<span class="hljs-built_in">GetRegistrations</span>()) <span class="hljs-comment">// TArray&lt;FRegistrant&gt;</span><br>&#123;<br>UClass* RegisteredClass = FClassDeferredRegistry::<span class="hljs-built_in">InnerRegister</span>(Registrant); <span class="hljs-comment">// 调用注册 TClass::StaticClass()</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里将所有收集到的UCLASS进行了注册，最终调用的是 <code>TClass::StaticClass()</code>，可参见上文类型收集：<code>UMyClass</code>的收集过程 <code>RegisterCompiledInInfo()</code></p><p>注意：在Editor模式和Runtime模式下，各类的UClass的加载顺序不一样。一方面原因是因为dll连接加载的方式顺序不一样，另一方面是static变量初始化顺序是不确定的。在UE的代码里，有大量的防护性代码去加载前置所需要的类，这一阶段生成的UClass也只有 <code>SuperStruct</code>和 <code>WithinClass</code>之间的依赖，所以一定的顺序不定也没有关系。</p><p>至此，静态收集到的所有UClass都已经构建出来了，但这些对象内部的值还没有完成初始化设置。</p><hr><h2 id="UObject（九）类型系统注册-InitUObject"><a href="#UObject（九）类型系统注册-InitUObject" class="headerlink" title="UObject（九）类型系统注册-InitUObject"></a><a href="https://zhuanlan.zhihu.com/p/58244447">UObject（九）类型系统注册-InitUObject</a></h2><h3 id="AppInt"><a href="#AppInt" class="headerlink" title="AppInt"></a>AppInt</h3><p>主要做了一些程序入口的初始化工程，在最后一步用一个多播委托通知了程序初始化实践，让别的代码有机会继续进行一些初始化工作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">FEngineLoop::AppInit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//...做一些其他程序入口的初始化工作</span><br>    FCoreDelegates::OnInit.<span class="hljs-built_in">Broadcast</span>(); <span class="hljs-comment">//在前文注册的委托，在CoreUOject模块加载的时候指向了InitUObject</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="InitUObject"><a href="#InitUObject" class="headerlink" title="InitUObject"></a>InitUObject</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitUObject</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//...</span><br>    FCoreDelegates::OnExit.<span class="hljs-built_in">AddStatic</span>(StaticExit);   <span class="hljs-comment">//注册退出的事件</span><br>    <span class="hljs-comment">//每个Module加载完后(dll)，会触发dll里的static初始化，继而又收集到了一些元数据信息，注册下面这个方法用来进行新收集到的UClass构造</span><br>    FModuleManager::<span class="hljs-built_in">Get</span>().<span class="hljs-built_in">OnProcessLoadedObjectsCallback</span>().<span class="hljs-built_in">AddStatic</span>(ProcessNewlyLoadedUObjects);<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-built_in">StaticUObjectInit</span>();<span class="hljs-comment">//调用另一个函数</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="StaticUObjectInit"><a href="#StaticUObjectInit" class="headerlink" title="StaticUObjectInit"></a>StaticUObjectInit</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StaticUObjectInit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">UObjectBaseInit</span>();  <span class="hljs-comment">//继续转发</span><br>    <span class="hljs-comment">//最后，创建临时包</span><br>    GObjTransientPkg = <span class="hljs-built_in">NewObject</span>&lt;UPackage&gt;(<span class="hljs-literal">nullptr</span>, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;/Engine/Transient&quot;</span>), RF_Transient);<br>    GObjTransientPkg-&gt;<span class="hljs-built_in">AddToRoot</span>();  <span class="hljs-comment">//这个临时包总不会释放</span><br>    <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">//...</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> T &gt;</span><br><span class="hljs-function">T* <span class="hljs-title">NewObject</span><span class="hljs-params">(UObject* Outer = (UObject*)GetTransientPackage())</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>继续转发调用，但我们发现在 <code>UObjectBaseInit</code>初始化结束后，就已经可以开始 <code>NewObject</code>了，标志着整个UObject系统的成功创建！<code>GObjTransientPkg</code>是个全局变量，所有没有Outer的对象都会放在这个包里。我们在 <code>NewObject</code>的时候，如果不提供Outer，则会返回这个临时包，符合了UObject对象必须在UPackage里的一贯基本原则。</p><h3 id="UObjectBaseInit"><a href="#UObjectBaseInit" class="headerlink" title="UObjectBaseInit"></a>UObjectBaseInit</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UObjectBaseInit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">// 初始化UObject的内存分配存储系统和对象HASH系统</span><br>    GUObjectAllocator.<span class="hljs-built_in">AllocatePermanentObjectPool</span>(SizeOfPermanentObjectPool);<span class="hljs-comment">//初始化对象分配器</span><br>    GUObjectArray.<span class="hljs-built_in">AllocateObjectPool</span>(MaxUObjects, MaxObjectsNotConsideredByGC, bPreAllocateUObjectArray);<span class="hljs-comment">//初始化对象管理数组</span><br><span class="hljs-comment">// 创建了异步加载线程，用来后续Package(uasset)的加载</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitAsyncThread</span><span class="hljs-params">()</span></span>;<br><span class="hljs-built_in">InitAsyncThread</span>();  <span class="hljs-comment">//初始化Package(uasset)的异步加载线程</span><br><span class="hljs-comment">// 置初始化完成编辑为true</span><br>Internal::<span class="hljs-built_in">GetUObjectSubsystemInitialised</span>() = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// 处理注册项</span><br><span class="hljs-built_in">UObjectProcessRegistrants</span>();<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="UObjectProcessRegistrants"><a href="#UObjectProcessRegistrants" class="headerlink" title="UObjectProcessRegistrants"></a>UObjectProcessRegistrants</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">UObjectProcessRegistrants</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>TArray&lt;FPendingRegistrant&gt; PendingRegistrants;<br><span class="hljs-comment">// 将GFirstPendingRegistrant全局链表的内容抽出来</span><br><span class="hljs-built_in">DequeuePendingAutoRegistrants</span>(PendingRegistrants);<br><span class="hljs-comment">// 然后进行注册</span><br><span class="hljs-keyword">for</span>(int32 RegistrantIndex = <span class="hljs-number">0</span>;RegistrantIndex &lt; PendingRegistrants.<span class="hljs-built_in">Num</span>();++RegistrantIndex)<br>&#123;<br><span class="hljs-type">const</span> FPendingRegistrant&amp; PendingRegistrant = PendingRegistrants[RegistrantIndex];<br><span class="hljs-built_in">UObjectForceRegistration</span>(PendingRegistrant.Object, <span class="hljs-literal">false</span>);<br><span class="hljs-comment">// Register may have resulted in new pending registrants being enqueued, so dequeue those.</span><br><span class="hljs-comment">// 注册UObject的试试，可能会触发另一个Module加载，所以需要不断的提取</span><br><span class="hljs-built_in">DequeuePendingAutoRegistrants</span>(PendingRegistrants);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">DequeuePendingAutoRegistrants</span><span class="hljs-params">(TArray&lt;FPendingRegistrant&gt;&amp; OutPendingRegistrants)</span></span><br><span class="hljs-function"></span>&#123;<br>FPendingRegistrant* NextPendingRegistrant = GFirstPendingRegistrant;<br>GFirstPendingRegistrant = <span class="hljs-literal">NULL</span>;<br>GLastPendingRegistrant = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">while</span>(NextPendingRegistrant)<br>&#123;<br>FPendingRegistrant* PendingRegistrant = NextPendingRegistrant;<br>OutPendingRegistrants.<span class="hljs-built_in">Add</span>(*PendingRegistrant);<br>NextPendingRegistrant = PendingRegistrant-&gt;NextAutoRegister;<br><span class="hljs-keyword">delete</span> PendingRegistrant;<br>&#125;;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UObjectForceRegistration</span><span class="hljs-params">(UObjectBase* Object, <span class="hljs-type">bool</span> bCheckForModuleRelease)</span></span><br><span class="hljs-function"></span>&#123;<br>TMap&lt;UObjectBase*, FPendingRegistrantInfo&gt;&amp; PendingRegistrants = FPendingRegistrantInfo::<span class="hljs-built_in">GetMap</span>();<br><span class="hljs-comment">// 该方法会被重复调用:</span><br><span class="hljs-comment">// 1、UClass::CreateDefaultObject()内部用UObjectForceRegistration(ParentClass)来确认基类已经注册完成;</span><br><span class="hljs-comment">// 2、UE4CodeGen_Private::ConstructUClass()等构造类型对象的函数里用UObjectForceRegistration(NewClass)来保证该对象已经注册</span><br><span class="hljs-comment">// 通过下面的find来进行判断是否需要注册</span><br>FPendingRegistrantInfo* Info = PendingRegistrants.<span class="hljs-built_in">Find</span>(Object);<span class="hljs-comment">// 在收集的时候创建的，那时候还没有具体的名字</span><br><span class="hljs-keyword">if</span> (Info)<br>&#123;<br><span class="hljs-type">const</span> TCHAR* PackageName = Info-&gt;PackageName;<br><span class="hljs-type">const</span> TCHAR* Name = Info-&gt;Name;<br>PendingRegistrants.<span class="hljs-built_in">Remove</span>(Object);  <span class="hljs-comment">// delete this first so that it doesn&#x27;t try to do it twice</span><br>Object-&gt;<span class="hljs-built_in">DeferredRegister</span>(UClass::<span class="hljs-built_in">StaticClass</span>(),PackageName,Name);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="UObjectBase-DeferredRegister"><a href="#UObjectBase-DeferredRegister" class="headerlink" title="UObjectBase::DeferredRegister"></a>UObjectBase::DeferredRegister</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UObjectBase::DeferredRegister</span><span class="hljs-params">(UClass *UClassStaticClass,<span class="hljs-type">const</span> TCHAR* PackageName,<span class="hljs-type">const</span> TCHAR* InName)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// Set object properties.</span><br>UPackage* Package = <span class="hljs-built_in">CreatePackage</span>(PackageName); <span class="hljs-comment">// 创建其属于的Package</span><br>Package-&gt;<span class="hljs-built_in">SetPackageFlags</span>(PKG_CompiledIn);<br>OuterPrivate = Package; <span class="hljs-comment">// 设定Outer到该Package</span><br><br>ClassPrivate = UClassStaticClass; <span class="hljs-comment">// 设定属于的UClass*类型</span><br><br><span class="hljs-comment">// Add to the global object table.</span><br><span class="hljs-built_in">AddObject</span>(<span class="hljs-built_in">FName</span>(InName), EInternalObjectFlags::None); <span class="hljs-comment">// 注册该对象的名字</span><br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Add a newly created object to the name hash tables and the object array</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param Name name to assign to this uobject</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UObjectBase::AddObject</span><span class="hljs-params">(FName InName, EInternalObjectFlags InSetInternalFlags)</span></span><br><span class="hljs-function"></span>&#123;<br>NamePrivate = InName; <span class="hljs-comment">// 设定对象的名字</span><br>...<br>GUObjectArray.<span class="hljs-built_in">AllocateUObjectIndex</span>(<span class="hljs-keyword">this</span>);<br>...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Deferred 延时<br>在对象系统初始化之后在进行注册。因为还不能 <code>NewObject</code>和加载Package。</li><li>Register 注册<br>对代码里的class生成响应的UClass*对象并添加(注册)到全局对象数组里。</li></ul><p>至此，UClass对象已经进行了初步的初始化（创建Outer指向的Package、设置ClassPrivate、将UClass添加到全局的对象数组 <code>GUObjectArray</code>中去）。</p><hr><h2 id="UObject（十）类型系统构造-再次触发"><a href="#UObject（十）类型系统构造-再次触发" class="headerlink" title="UObject（十）类型系统构造-再次触发"></a><a href="https://zhuanlan.zhihu.com/p/58868952">UObject（十）类型系统构造-再次触发</a></h2><p>UClass对象的初始化还没有完成。</p><h3 id="ProcessNewlyLoadedUObjects"><a href="#ProcessNewlyLoadedUObjects" class="headerlink" title="ProcessNewlyLoadedUObjects"></a>ProcessNewlyLoadedUObjects</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ProcessNewlyLoadedUObjects</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">UClassRegisterAllCompiledInClasses</span>();   <span class="hljs-comment">//为代码里定义的那些类生成UClass*，TClass::StaticClass()</span><br><span class="hljs-comment">//有待注册项就继续循环注册</span><br><span class="hljs-type">bool</span> bNewUObjects = <span class="hljs-literal">false</span>;<br>TArray&lt;UClass*&gt; AllNewClasses;<br><span class="hljs-keyword">while</span> (GFirstPendingRegistrant ||<br>ClassRegistry.<span class="hljs-built_in">HasPendingRegistrations</span>() ||<br>StructRegistry.<span class="hljs-built_in">HasPendingRegistrations</span>() ||<br>EnumRegistry.<span class="hljs-built_in">HasPendingRegistrations</span>())<br>&#123;<br>bNewUObjects = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">UObjectProcessRegistrants</span>();    <span class="hljs-comment">//注册UClass*，生成其Package，保证后续操作之前内存里应把相关UClass*对象注册完毕</span><br><span class="hljs-built_in">UObjectLoadAllCompiledInStructs</span>();  <span class="hljs-comment">//为代码里的枚举和结构构造类型对象</span><br><span class="hljs-built_in">UObjectLoadAllCompiledInDefaultProperties</span>(AllNewClasses);    <span class="hljs-comment">//为代码里的类继续构造UClass对象，创建类默认对象(CDO)</span><br>&#125;<br><br><span class="hljs-keyword">if</span> (bNewUObjects &amp;&amp; !GIsInitialLoad)<br>&#123;<br><span class="hljs-keyword">for</span> (UClass* Class : AllNewClasses)<br>&#123;<br><span class="hljs-comment">// Assemble reference token stream for garbage collection/ RTGC.</span><br><span class="hljs-keyword">if</span> (!Class-&gt;<span class="hljs-built_in">HasAnyFlags</span>(RF_ClassDefaultObject) &amp;&amp; !Class-&gt;<span class="hljs-built_in">HasAnyClassFlags</span>(CLASS_TokenStreamAssembled))<br>&#123;<br>Class-&gt;<span class="hljs-built_in">AssembleReferenceTokenStream</span>(); <span class="hljs-comment">//构造引用记号流，为后续GC用(一种辅助GC分析对象引用的数据结构)</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="UObjectLoadAllCompiledInStructs"><a href="#UObjectLoadAllCompiledInStructs" class="headerlink" title="UObjectLoadAllCompiledInStructs"></a>UObjectLoadAllCompiledInStructs</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">UObjectLoadAllCompiledInStructs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>FEnumDeferredRegistry&amp; EnumRegistry = FEnumDeferredRegistry::<span class="hljs-built_in">Get</span>();<br>FStructDeferredRegistry&amp; StructRegistry = FStructDeferredRegistry::<span class="hljs-built_in">Get</span>();<br><br>&#123;<br>EnumRegistry.<span class="hljs-built_in">DoPendingPackageRegistrations</span>(); <span class="hljs-comment">// 创建Enum其所属于的Package</span><br>StructRegistry.<span class="hljs-built_in">DoPendingPackageRegistrations</span>(); <span class="hljs-comment">// 创建Struct其所属于的Package</span><br>&#125;<br><br><span class="hljs-comment">// Load Structs</span><br>EnumRegistry.<span class="hljs-built_in">DoPendingOuterRegistrations</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 调用生成代码里Z_Construct_UEnum_UObjectLearn_EMyEnum</span><br>StructRegistry.<span class="hljs-built_in">DoPendingOuterRegistrations</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">//调用生成代码里Z_Construct_UScriptStruct_FMyStruct</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoPendingPackageRegistrations</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (int32 Index = ProcessedRegistrations, Num = Registrations.<span class="hljs-built_in">Num</span>(); Index &lt; Num; ++Index)<br>&#123;<br><span class="hljs-built_in">CreatePackage</span>(Registrations[Index].PackageName);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoPendingOuterRegistrations</span><span class="hljs-params">(<span class="hljs-type">bool</span> UpdateCounter)</span></span><br><span class="hljs-function"></span>&#123;<br>int32 Num = Registrations.<span class="hljs-built_in">Num</span>();<br><span class="hljs-keyword">for</span> (int32 Index = ProcessedRegistrations; Index &lt; Num; ++Index)<br>&#123;<br><span class="hljs-built_in">OuterRegister</span>(Registrations[Index]);<br>&#125;<br><br><span class="hljs-keyword">if</span> (UpdateCounter)<br>&#123;<br>ProcessedRegistrations = Num;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> TType* <span class="hljs-title">OuterRegister</span><span class="hljs-params">(<span class="hljs-type">const</span> FRegistrant&amp; Registrant)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> Registrant.<span class="hljs-built_in">OuterRegisterFn</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>构造的顺序总是先enum再struct。是因为更基础的类型总是先构造。(struct里可以包含enum，但是enum里不包含struct)</p><h3 id="UObjectLoadAllCompiledInDefaultProperties"><a href="#UObjectLoadAllCompiledInDefaultProperties" class="headerlink" title="UObjectLoadAllCompiledInDefaultProperties"></a>UObjectLoadAllCompiledInDefaultProperties</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">UObjectLoadAllCompiledInDefaultProperties</span><span class="hljs-params">(TArray&lt;UClass*&gt;&amp; OutAllNewClasses)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function"><span class="hljs-type">static</span> FName <span class="hljs-title">LongEnginePackageName</span><span class="hljs-params">(TEXT(<span class="hljs-string">&quot;/Script/Engine&quot;</span>))</span></span>; <span class="hljs-comment">//引擎包的名字</span><br>FClassDeferredRegistry&amp; ClassRegistry = FClassDeferredRegistry::<span class="hljs-built_in">Get</span>();<br><span class="hljs-keyword">if</span> (ClassRegistry.<span class="hljs-built_in">HasPendingRegistrations</span>())<br>&#123;<br>TArray&lt;UClass*&gt; NewClasses;<br>TArray&lt;UClass*&gt; NewClassesInCoreUObject;<br>TArray&lt;UClass*&gt; NewClassesInEngine;<br><span class="hljs-comment">// DoPendingOuterRegistrations里遍历所有的FRegistrant并调用生成代码里的Z_Construct_UClass_UMyClass创建UClass*，将新建的UClass*传入下面的lambda方法中进行收集</span><br>ClassRegistry.<span class="hljs-built_in">DoPendingOuterRegistrations</span>(<span class="hljs-literal">true</span>, <br>[&amp;OutAllNewClasses, &amp;NewClasses, &amp;NewClassesInCoreUObject, &amp;NewClassesInEngine](<span class="hljs-type">const</span> TCHAR* PackageName, UClass&amp; Class) -&gt; <span class="hljs-type">void</span><br>&#123;<br><span class="hljs-keyword">if</span> (Class.<span class="hljs-built_in">GetOutermost</span>()-&gt;<span class="hljs-built_in">GetFName</span>() == GLongCoreUObjectPackageName) &#123;<br>NewClassesInCoreUObject.<span class="hljs-built_in">Add</span>(&amp;Class);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Class.<span class="hljs-built_in">GetOutermost</span>()-&gt;<span class="hljs-built_in">GetFName</span>() == LongEnginePackageName) &#123;<br>NewClassesInEngine.<span class="hljs-built_in">Add</span>(&amp;Class);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>NewClasses.<span class="hljs-built_in">Add</span>(&amp;Class);<br>&#125;<br>OutAllNewClasses.<span class="hljs-built_in">Add</span>(&amp;Class);<br>&#125;); <br><span class="hljs-comment">// 分别构造CDO对象</span><br><span class="hljs-keyword">for</span> (UClass* Class : NewClassesInCoreUObject) &#123; Class-&gt;<span class="hljs-built_in">GetDefaultObject</span>(); &#125;<br><span class="hljs-keyword">for</span> (UClass* Class : NewClassesInEngine) &#123; Class-&gt;<span class="hljs-built_in">GetDefaultObject</span>(); &#125;<br><span class="hljs-keyword">for</span> (UClass* Class : NewClasses) &#123; Class-&gt;<span class="hljs-built_in">GetDefaultObject</span>(); &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CloseDisregardForGC"><a href="#CloseDisregardForGC" class="headerlink" title="CloseDisregardForGC"></a>CloseDisregardForGC</h3><p>在此之前，一直都处于初始化载入阶段，这个阶段构造的类型UClass*和CDO对象，以及其属于的UPackage对象，都是属于引擎底层的<strong>必要对象</strong>，这些对象只有在游戏退出的时候才会销毁，所以他们不属GC管理。在类型系统构建完之后，就可以打开GC了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FUObjectArray::CloseDisregardForGC</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsEngineExitRequested</span>())<br>&#123;<br><span class="hljs-built_in">ProcessNewlyLoadedUObjects</span>(); <span class="hljs-comment">//之前仍然有可能加载了别的模块dll</span><br><br>UClass::<span class="hljs-built_in">AssembleReferenceTokenStreams</span>(); <span class="hljs-comment">//此时才是真正的第一次为所有的UClass*构建引用记号流</span><br>&#125;<br>...<br>OpenForDisregardForGC = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 开启GC</span><br>GIsInitialLoad = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 初始化载入阶段结束</span><br>&#125;<br></code></pre></td></tr></table></figure><p>至此，已经完成了各个类型的表达对象的构造。下图做一下总结：</p><p>【这个图还是基于UE4.1的，后续总结部分整理了基于UE5的类型构造过程】</p><ul><li>从左到右是类型信息的收集和消费过程，从上到下是依据代码的执行顺序。</li><li>红色箭头表示数据的添加，蓝色代表数据的消费使用。</li><li>浅蓝色箭头和矩形代表内存中UClass*以及类型对象的创建和构造。</li><li>信息手机里的黄色矩形，表示他们会一直在内存中，用来做查找使用，不会被清空。</li></ul><img src="/2023/05/16/link/UE/UE-C++/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/1681355640837.png" class="" width="1681355640837"><hr><h2 id="UObject（十一）类型系统构造-构造绑定链接"><a href="#UObject（十一）类型系统构造-构造绑定链接" class="headerlink" title="UObject（十一）类型系统构造-构造绑定链接"></a><a href="https://zhuanlan.zhihu.com/p/59553490">UObject（十一）类型系统构造-构造绑定链接</a></h2><p>在为每一个enum、struct、class在类型注册的最后，都进行了一次 <code>OuterRegisterFn</code>调用(可参见 <code>ClassRegistry.DoPendingOuterRegistrations</code>)，而这些其实就是生成代码里的函数。</p><p>本篇按生成顺序讲解这个里面的类型对象生成和构造。为方便阅读会列出一部分关键代码，全量的展开代码可参见《类型代码生成剖析》部分。</p><h3 id="UEnum"><a href="#UEnum" class="headerlink" title="UEnum"></a>UEnum</h3><h4 id="关键的生成代码"><a href="#关键的生成代码" class="headerlink" title="关键的生成代码"></a>关键的生成代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">static</span> FEnumRegistrationInfo Z_Registration_Info_UEnum_EMyEnum;<br><span class="hljs-function"><span class="hljs-type">static</span> UEnum* <span class="hljs-title">EMyEnum_StaticEnum</span><span class="hljs-params">()</span>   <span class="hljs-comment">// OuterRegisterFn</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!Z_Registration_Info_UEnum_EMyEnum.OuterSingleton)<br>&#123;<br><span class="hljs-comment">// 传入Z_Construct_UEnum_UObjectLearn_EMyEnum进行构造</span><br>Z_Registration_Info_UEnum_EMyEnum.OuterSingleton = <br><span class="hljs-built_in">GetStaticEnum</span>(<br>Z_Construct_UEnum_UObjectLearn_EMyEnum,  <span class="hljs-comment">// 返回构造的UEnum*</span><br><span class="hljs-built_in">Z_Construct_UPackage__Script_UObjectLearn</span>(),  <span class="hljs-comment">// 返回其所属的UPackage</span><br><span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;EMyEnum&quot;</span>)); <span class="hljs-comment">// Name</span><br>&#125;<br><span class="hljs-keyword">return</span> Z_Registration_Info_UEnum_EMyEnum.OuterSingleton;<br>&#125;<br><span class="hljs-comment">// 构造EMyEnum关联的UEnum*</span><br><span class="hljs-function">UEnum* <span class="hljs-title">Z_Construct_UEnum_UObjectLearn_EMyEnum</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!Z_Registration_Info_UEnum_EMyEnum.InnerSingleton)<br>&#123;<br>UECodeGen_Private::<span class="hljs-built_in">ConstructUEnum</span>(Z_Registration_Info_UEnum_EMyEnum.InnerSingleton, Z_Construct_UEnum_UObjectLearn_EMyEnum_Statics::EnumParams);<br>&#125;<br><span class="hljs-keyword">return</span> Z_Registration_Info_UEnum_EMyEnum.InnerSingleton;<br>&#125;<br><span class="hljs-comment">/////// EnumParams</span><br><span class="hljs-type">const</span> UECodeGen_Private::FEnumeratorParam Z_Construct_UEnum_UObjectLearn_EMyEnum_Statics::Enumerators[] = &#123;<br>&#123; <span class="hljs-string">&quot;EMyEnum::MY_Dance&quot;</span>, (int64)EMyEnum::MY_Dance &#125;,<br>&#123; <span class="hljs-string">&quot;EMyEnum::MY_Rain&quot;</span>, (int64)EMyEnum::MY_Rain &#125;,<br>&#123; <span class="hljs-string">&quot;EMyEnum::MY_Song&quot;</span>, (int64)EMyEnum::MY_Song &#125;,<br>&#125;;<br><span class="hljs-type">const</span> UECodeGen_Private::FEnumParams Z_Construct_UEnum_UObjectLearn_EMyEnum_Statics::EnumParams = &#123;<br>(UObject*(*)())Z_Construct_UPackage__Script_UObjectLearn, <span class="hljs-comment">// 所属的UPackage</span><br><span class="hljs-literal">nullptr</span>,<br><span class="hljs-string">&quot;EMyEnum&quot;</span>,<br><span class="hljs-string">&quot;EMyEnum&quot;</span>,<br>Z_Construct_UEnum_UObjectLearn_EMyEnum_Statics::Enumerators, <span class="hljs-comment">// 枚举项UECodeGen_Private::FEnumeratorParam &#123;NameUTF8, Value&#125;</span><br><span class="hljs-built_in">UE_ARRAY_COUNT</span>(Z_Construct_UEnum_UObjectLearn_EMyEnum_Statics::Enumerators),<br>RF_Public|RF_Transient|RF_MarkAsNative,<br>EEnumFlags::None,<br>(uint8)UEnum::ECppForm::EnumClass,<br><span class="hljs-built_in">METADATA_PARAMS</span>(Z_Construct_UEnum_UObjectLearn_EMyEnum_Statics::Enum_MetaDataParams, <span class="hljs-built_in">UE_ARRAY_COUNT</span>(Z_Construct_UEnum_UObjectLearn_EMyEnum_Statics::Enum_MetaDataParams))<br>&#125;;<br><br><span class="hljs-type">const</span> FEnumRegisterCompiledInInfo Z_CompiledInDeferFile_FID_unreal_learning_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyEnum_h_Statics::EnumInfo[] = &#123;<br>&#123; <br>EMyEnum_StaticEnum,  <span class="hljs-comment">// OuterRegisterFn</span><br><span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;EMyEnum&quot;</span>), <span class="hljs-comment">// Name</span><br>&amp;Z_Registration_Info_UEnum_EMyEnum,  <span class="hljs-comment">// Info</span><br><span class="hljs-built_in">CONSTRUCT_RELOAD_VERSION_INFO</span>(FEnumReloadVersionInfo, <span class="hljs-number">1966967219U</span>)  <span class="hljs-comment">// VersionInfo</span><br>&#125;, <br><span class="hljs-type">static</span> FRegisterCompiledInInfo <span class="hljs-built_in">Z_CompiledInDeferFile_FID_unreal_learning_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyEnum_h_2167825752</span><br>(<br><span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;/Script/UObjectLearn&quot;</span>), <span class="hljs-comment">// PackageName</span><br><span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, <span class="hljs-comment">// ClassInfo</span><br><span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, <span class="hljs-comment">// StructInfo</span><br>Z_CompiledInDeferFile_FID_unreal_learning_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyEnum_h_Statics::EnumInfo, <span class="hljs-comment">// EnumInfo</span><br><span class="hljs-built_in">UE_ARRAY_COUNT</span>(Z_CompiledInDeferFile_FID_unreal_learning_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyEnum_h_Statics::EnumInfo));<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>通过类型系统的收集(<code>static FRegisterCompiledInInfo xxx</code>)，将 <code>EMyEnum_StaticEnum</code>方法注册给了 <code>OuterReigsterFn</code>。</p><p>调用的时候内部的 <code>GetStaticEnum</code>方法会调用 <code>Z_Construct_UEnum_UObjectLearn_EMyEnum</code>，其定义了枚举项参数和枚举参数，最终发给 <code>UECodeGen_Private::ConstructUEnum</code>进行构造。</p><h4 id="UECodeGen-Private-ConstructEnum"><a href="#UECodeGen-Private-ConstructEnum" class="headerlink" title="UECodeGen_Private::ConstructEnum"></a>UECodeGen_Private::ConstructEnum</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ConstructUEnum</span><span class="hljs-params">(UEnum*&amp; OutEnum, <span class="hljs-type">const</span> FEnumParams&amp; Params)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// Outer: 所属的UPackage</span><br>UObject* (*OuterFunc)() = Params.OuterFunc; <br>UObject* Outer = OuterFunc ? <span class="hljs-built_in">OuterFunc</span>() : <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-keyword">if</span> (OutEnum) <span class="hljs-comment">// 防止重复构造</span><br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>UEnum* NewEnum = <span class="hljs-built_in">new</span> (EC_InternalUseOnlyConstructor, Outer, <span class="hljs-built_in">UTF8_TO_TCHAR</span>(Params.NameUTF8), Params.ObjectFlags) <span class="hljs-built_in">UEnum</span>(<span class="hljs-built_in">FObjectInitializer</span>());<br>OutEnum = NewEnum;<br><span class="hljs-comment">// 生成枚举名字值对的数组</span><br>TArray&lt;TPair&lt;FName, int64&gt;&gt; EnumNames;<br>EnumNames.<span class="hljs-built_in">Reserve</span>(Params.NumEnumerators);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> FEnumeratorParam* Enumerator = Params.EnumeratorParams, *EnumeratorEnd = Enumerator + Params.NumEnumerators; Enumerator != EnumeratorEnd; ++Enumerator)<br>&#123;<br>EnumNames.<span class="hljs-built_in">Emplace</span>(<span class="hljs-built_in">UTF8_TO_TCHAR</span>(Enumerator-&gt;NameUTF8), Enumerator-&gt;Value);<br>&#125;<br><span class="hljs-comment">// 设置数组</span><br><span class="hljs-type">const</span> <span class="hljs-type">bool</span> bAddMaxKeyIfMissing = <span class="hljs-literal">true</span>;<br>NewEnum-&gt;<span class="hljs-built_in">SetEnums</span>(EnumNames, (UEnum::ECppForm)Params.CppForm, Params.EnumFlags, bAddMaxKeyIfMissing);<br>NewEnum-&gt;CppType = <span class="hljs-built_in">UTF8_TO_TCHAR</span>(Params.CppTypeUTF8);<br><br><span class="hljs-keyword">if</span> (Params.DisplayNameFunc)<br>&#123;<br>NewEnum-&gt;<span class="hljs-built_in">SetEnumDisplayNameFn</span>(Params.DisplayNameFunc); <span class="hljs-comment">//设置自定义显示名字回调</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>OuterFunc()</code>保证了所属的 <code>UPackage</code>存在</li><li>UEnum构造重载了 <code>New</code>(定义在了宏 <code>DECLARE_CLASS </code>中)，触发了 <code>StaticAllocateObject </code>方法来分配出一块对象内存(<code>GUObjectAllocator.AllocateUObject</code>)。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/** For internal use only; use StaticConstructObject() to create new objects. */</span> <br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> InSize, EInternal InInternalOnly, UObject* InOuter = (UObject*)GetTransientPackage(), FName InName = NAME_None, EObjectFlags InSetFlags = RF_NoFlags)</span> </span><br><span class="hljs-function"></span>&#123; <br><span class="hljs-keyword">return</span> <span class="hljs-built_in">StaticAllocateObject</span>(<span class="hljs-built_in">StaticClass</span>(), InOuter, InName, InSetFlags); <br>&#125; <br><span class="hljs-comment">/** For internal use only; use StaticConstructObject() to create new objects. */</span> <br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> InSize, EInternal* InMem )</span> </span><br><span class="hljs-function"></span>&#123; <br><span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)InMem; <br>&#125; <br></code></pre></td></tr></table></figure></li></ul><p>最后是 <code>SetEnum</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">UEnum::SetEnums</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TArray&lt;TPair&lt;FName, int64&gt;&gt;&amp; InNames,  <span class="hljs-comment">// 枚举名字-值的数组</span></span></span><br><span class="hljs-params"><span class="hljs-function">UEnum::ECppForm InCppForm, <span class="hljs-comment">// cpp的类型，这里是(uint8)UEnum::ECppForm::EnumClass</span></span></span><br><span class="hljs-params"><span class="hljs-function">EEnumFlags InFlags,  <span class="hljs-comment">// EEnumFlags::None</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">bool</span> bAddMaxKeyIfMissing)</span> <span class="hljs-comment">// true</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (Names.<span class="hljs-built_in">Num</span>() &gt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">RemoveNamesFromPrimaryList</span>(); <span class="hljs-comment">// 清空之前的名字</span><br>&#125;<br>Names     = InNames;<br>CppForm   = InCppForm;<br>EnumFlags = InFlags;<br><br><span class="hljs-keyword">if</span> (bAddMaxKeyIfMissing)<br>&#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ContainsExistingMax</span>())<br>&#123;<br>FName MaxEnumItem = *<span class="hljs-built_in">GenerateFullEnumName</span>(*(<span class="hljs-built_in">GenerateEnumPrefix</span>() + <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;_MAX&quot;</span>)));<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">LookupEnumName</span>(<span class="hljs-built_in">GetOutermost</span>()-&gt;<span class="hljs-built_in">GetFName</span>(), MaxEnumItem) != INDEX_NONE)<br>&#123;<br><span class="hljs-comment">// the MAX identifier is already being used by another enum</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br>Names.<span class="hljs-built_in">Emplace</span>(MaxEnumItem, <span class="hljs-built_in">GetMaxEnumValue</span>() + <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><span class="hljs-built_in">AddNamesToPrimaryList</span>(); <span class="hljs-comment">// 添加Names</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>UEnum中维护了全局的静态成员 <code>AllEnumNames</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/** global list of all value names used by all enums in memory, used for property text import */</span><br><span class="hljs-type">static</span> TMap&lt;FName, TMap&lt;FName, UEnum*&gt; &gt; AllEnumNames;<br></code></pre></td></tr></table></figure><p>通过 <code>RemoveNamesFromPrimaryList</code>和 <code>AddNamesToPrimaryList</code>来进行维护。</p><h3 id="UScriptStruct"><a href="#UScriptStruct" class="headerlink" title="UScriptStruct"></a>UScriptStruct</h3><h4 id="关键的生成代码-1"><a href="#关键的生成代码-1" class="headerlink" title="关键的生成代码"></a>关键的生成代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">static</span> FStructRegistrationInfo Z_Registration_Info_UScriptStruct_MyStruct;<br><span class="hljs-function"><span class="hljs-keyword">class</span> UScriptStruct* <span class="hljs-title">FMyStruct::StaticStruct</span><span class="hljs-params">()</span> <span class="hljs-comment">// OuterRegisterFn</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!Z_Registration_Info_UScriptStruct_MyStruct.OuterSingleton)<br>&#123;<br>Z_Registration_Info_UScriptStruct_MyStruct.OuterSingleton = <span class="hljs-built_in">GetStaticStruct</span>(<br>Z_Construct_UScriptStruct_FMyStruct, <span class="hljs-built_in">Z_Construct_UPackage__Script_UObjectLearn</span>(), <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;MyStruct&quot;</span>));<br>&#125;<br><span class="hljs-keyword">return</span> Z_Registration_Info_UScriptStruct_MyStruct.OuterSingleton;<br>&#125;<br><span class="hljs-comment">// 构造FMyStruct对应的UScriptStruct对象</span><br><span class="hljs-function">UScriptStruct* <span class="hljs-title">Z_Construct_UScriptStruct_FMyStruct</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!Z_Registration_Info_UScriptStruct_MyStruct.InnerSingleton)<br>&#123;<br>UECodeGen_Private::<span class="hljs-built_in">ConstructUScriptStruct</span>(Z_Registration_Info_UScriptStruct_MyStruct.InnerSingleton,<br>                                          Z_Construct_UScriptStruct_FMyStruct_Statics::ReturnStructParams);<br>&#125;<br><span class="hljs-keyword">return</span> Z_Registration_Info_UScriptStruct_MyStruct.InnerSingleton;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">Z_Construct_UScriptStruct_FMyStruct_Statics::NewStructOps</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (UScriptStruct::ICppStructOps*)<span class="hljs-keyword">new</span> UScriptStruct::<span class="hljs-built_in">TCppStructOps</span>&lt;FMyStruct&gt;();<br>&#125;<br><span class="hljs-type">const</span> UECodeGen_Private::FStructParams Z_Construct_UScriptStruct_FMyStruct_Statics::ReturnStructParams = &#123;<br>(UObject* (*)())Z_Construct_UPackage__Script_UObjectLearn, <span class="hljs-comment">// Outer</span><br><span class="hljs-literal">nullptr</span>,<br>&amp;NewStructOps,<br><span class="hljs-string">&quot;MyStruct&quot;</span>,<br><span class="hljs-built_in">sizeof</span>(FMyStruct),<br><span class="hljs-built_in">alignof</span>(FMyStruct),<br><span class="hljs-literal">nullptr</span>,<br><span class="hljs-number">0</span>,<br>RF_Public | RF_Transient | RF_MarkAsNative,<br><span class="hljs-built_in">EStructFlags</span>(<span class="hljs-number">0x00000001</span>),<br><span class="hljs-built_in">METADATA_PARAMS</span>(Z_Construct_UScriptStruct_FMyStruct_Statics::Struct_MetaDataParams,<br>                <span class="hljs-built_in">UE_ARRAY_COUNT</span>(Z_Construct_UScriptStruct_FMyStruct_Statics::Struct_MetaDataParams))<br>&#125;;<br><br><span class="hljs-type">const</span> FStructRegisterCompiledInInfo<br>Z_CompiledInDeferFile_FID_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyStruct_h_Statics::ScriptStructInfo<br>[] = &#123;<br>&#123;<br>FMyStruct::StaticStruct, Z_Construct_UScriptStruct_FMyStruct_Statics::NewStructOps, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;MyStruct&quot;</span>),<br>&amp;Z_Registration_Info_UScriptStruct_MyStruct,<br><span class="hljs-built_in">CONSTRUCT_RELOAD_VERSION_INFO</span>(FStructReloadVersionInfo, <span class="hljs-built_in">sizeof</span>(FMyStruct), <span class="hljs-number">4101929637U</span>)<br>&#125;,<br>&#125;;<br><span class="hljs-comment">// 对象注册，调用RegisterCompiledInInfo</span><br><span class="hljs-function"><span class="hljs-type">static</span> FRegisterCompiledInInfo</span><br><span class="hljs-function"><span class="hljs-title">Z_CompiledInDeferFile_FID_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyStruct_h_137600743</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;/Script/UObjectLearn&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">Z_CompiledInDeferFile_FID_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyStruct_h_Statics::ScriptStructInfo,</span></span><br><span class="hljs-params"><span class="hljs-function">UE_ARRAY_COUNT(</span></span><br><span class="hljs-params"><span class="hljs-function">Z_CompiledInDeferFile_FID_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyStruct_h_Statics::</span></span><br><span class="hljs-params"><span class="hljs-function">ScriptStructInfo),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>讨论和Enum一样，通过类型系统的收集(<code>static FRegisterCompiledInInfo xxx</code>)，将 <code>FMyStruct::StaticStruct </code>方法注册给了 <code>OuterReigsterFn</code>。</p><p>调用的时候内部的 <code>GetStaticEnum</code>方法会调用 <code>Z_Construct_UScriptStruct_FMyStruct</code>，最终发给  <code>UECodeGen_Private::ConstructUScriptStruct</code>进行构造。</p><h4 id="UECodeGen-Private-ConstructUScriptStruct"><a href="#UECodeGen-Private-ConstructUScriptStruct" class="headerlink" title="UECodeGen_Private::ConstructUScriptStruct"></a>UECodeGen_Private::ConstructUScriptStruct</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ConstructUScriptStruct</span><span class="hljs-params">(UScriptStruct*&amp; OutStruct, <span class="hljs-type">const</span> FStructParams&amp; Params)</span></span><br><span class="hljs-function"></span>&#123;<br>UObject*                      (*OuterFunc)()     = Params.OuterFunc;<br>UScriptStruct*                (*SuperFunc)()     = Params.SuperFunc;<br>UScriptStruct::ICppStructOps* (*StructOpsFunc)() = (UScriptStruct::ICppStructOps* (*)())Params.StructOpsFunc;<br><span class="hljs-comment">// 保证Outer的存在</span><br>UObject*                      Outer     = OuterFunc     ? <span class="hljs-built_in">OuterFunc</span>() : <span class="hljs-literal">nullptr</span>;<br><span class="hljs-comment">// 保证Super的存在</span><br>UScriptStruct*                Super     = SuperFunc     ? <span class="hljs-built_in">SuperFunc</span>() : <span class="hljs-literal">nullptr</span>;<br><span class="hljs-comment">// 保证StructOps的存在</span><br>UScriptStruct::ICppStructOps* StructOps = StructOpsFunc ? <span class="hljs-built_in">StructOpsFunc</span>() : <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-keyword">if</span> (OutStruct) <span class="hljs-comment">// 防止重复构造</span><br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// 重载new</span><br>UScriptStruct* NewStruct = <span class="hljs-built_in">new</span>(EC_InternalUseOnlyConstructor, Outer, <span class="hljs-built_in">UTF8_TO_TCHAR</span>(Params.NameUTF8), Params.ObjectFlags) <span class="hljs-built_in">UScriptStruct</span>(<span class="hljs-built_in">FObjectInitializer</span>(), Super, StructOps, (EStructFlags)Params.StructFlags, Params.SizeOf, Params.AlignOf);<br>OutStruct = NewStruct;<br><span class="hljs-comment">// 从属性参数数组里构造出FProperty*数组</span><br><span class="hljs-built_in">ConstructFProperties</span>(NewStruct, Params.PropertyArray, Params.NumProperties);<br><span class="hljs-comment">// 所有复合类型（继承于UStruct）都会接着调用StaticLink来链接子属性</span><br>NewStruct-&gt;<span class="hljs-built_in">StaticLink</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>调用模式和Enum很类似，首先构造出依赖的对象(Outer、Super、StructOps)，然后调用重载的new。</p><p>与Enum不同的是调用了 <code>ConstructFProperties</code>，作用是构造出 <code>FProperty*</code>数组。</p><p>最后，所有复合类型（继承UStruct）都会调用 <code>StaticLink</code>来链接子属性。</p><h4 id="ICppStructOps的作用"><a href="#ICppStructOps的作用" class="headerlink" title="ICppStructOps的作用"></a>ICppStructOps的作用</h4><p>定义了结构的一些公共操作，而具体实现是在 <code>template&lt;class CPPSTRUCT&gt; struct TCppStructOps final : public ICppStructOps</code></p><p>这里还可以显示的定义c++结构的一些特性，在 <code>template &lt;class CPPSTRUCT&gt; struct TStructOpsTypeTraitsBase2</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">CPPSTRUCT</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TStructOpsTypeTraitsBase2</span><br>&#123;<br><span class="hljs-keyword">enum</span><br>&#123;<br>WithZeroConstructor = <span class="hljs-literal">false</span>, <span class="hljs-comment">// 0构造，内存清零后就可以了，说明这个结构的默认值就是0</span><br>WithNoInitConstructor = <span class="hljs-literal">false</span>, <span class="hljs-comment">// 有个ForceInit的参数的构造，用来专门构造出0值结构来</span><br>WithNoDestructor = <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否没有结构有自定义的析构函数， 如果没有析构的话，DestroyStruct里面就可以省略调用析构函数了。默认是有的。结构如果是pod类型，则肯定没有析构。</span><br>WithCopy = !TIsPODType&lt;CPPSTRUCT&gt;::Value, <span class="hljs-comment">// 是否结构有自定义的=赋值函数。如果没有的话，在CopyScriptStruct的时候就只需要拷贝内存就可以了</span><br>WithIdenticalViaEquality = <span class="hljs-literal">false</span>, <span class="hljs-comment">// 用==来比较结构</span><br>WithIdentical = <span class="hljs-literal">false</span>, <span class="hljs-comment">// 有一个自定义的Identical函数来专门用来比较，和WithIdenticalViaEquality互斥</span><br>WithExportTextItem = <span class="hljs-literal">false</span>, <span class="hljs-comment">// 有一个ExportTextItem函数来把结构值导出为字符串</span><br>WithImportTextItem = <span class="hljs-literal">false</span>, <span class="hljs-comment">// 有一个ImportTextItem函数把字符串导进结构值</span><br>WithAddStructReferencedObjects = <span class="hljs-literal">false</span>, <span class="hljs-comment">// 有一个AddStructReferencedObjects函数用来添加结构额外的引用对象</span><br>WithSerializer = <span class="hljs-literal">false</span>, <span class="hljs-comment">// 有一个Serialize函数用来序列化</span><br>WithStructuredSerializer = <span class="hljs-literal">false</span>, <span class="hljs-comment">// 有一个结构结构Serialize函数用来序列化</span><br>WithPostSerialize = <span class="hljs-literal">false</span>, <span class="hljs-comment">// 有一个PostSerialize回调用来在序列化后调用</span><br>WithNetSerializer = <span class="hljs-literal">false</span>, <span class="hljs-comment">// 有一个NetSerialize函数用来在网络复制中序列化</span><br>WithNetDeltaSerializer = <span class="hljs-literal">false</span>, <span class="hljs-comment">// 有一个NetDeltaSerialize函数用来在之前NetSerialize的基础上只序列化出差异来，一般用在TArray属性上进行优化</span><br>WithSerializeFromMismatchedTag = <span class="hljs-literal">false</span>, <span class="hljs-comment">// 有一个SerializeFromMismatchedTag函数用来处理属性tag未匹配到的属性值，一般是在结构进行升级后，但值还是原来的值，这个时候用来把旧值升级到新结构时使用</span><br>WithStructuredSerializeFromMismatchedTag = <span class="hljs-literal">false</span>, <span class="hljs-comment">// SerializeFromMismatchedTag的结构版本</span><br>WithPostScriptConstruct = <span class="hljs-literal">false</span>,<span class="hljs-comment">// 有一个PostScriptConstruct函数用在蓝图构造脚本后调用</span><br>WithNetSharedSerialization = <span class="hljs-literal">false</span>, <span class="hljs-comment">// 指明结构的NetSerialize函数不需要用到UPackageMap</span><br>WithGetPreloadDependencies = <span class="hljs-literal">false</span>, <span class="hljs-comment">// 有一个GetPreloadDependencies函数用于返回在加载时被PreLoad()的所有object</span><br>WithPureVirtual = <span class="hljs-literal">false</span>, <span class="hljs-comment">// 当 CHECK_PUREVIRTUALS 为真时无法构造</span><br>WithCanEditChange = <span class="hljs-literal">false</span>, <span class="hljs-comment">// 有一个仅供编辑器使用的 CanEditChange 函数，可以在详细信息面板中有条件地将子属性设置为只读，类似于UObject::CanEditChange</span><br>&#125;;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">CPPSTRUCT</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TStructOpsTypeTraits</span> : <span class="hljs-keyword">public</span> TStructOpsTypeTraitsBase2&lt;CPPSTRUCT&gt;<br>&#123;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>ICppStructOps里的接口，内部实现大部分都是通过TStructOpsTypeTraits <code>&lt;CPPSTRUCT&gt;</code>的结构来分别调用不同版本的函数。结构的操作可以分为：</p><ul><li>构造：HasNoopConstructor、HasZeroConstructor、Construct、HasPostScriptConstruct、PostScriptConstruct、IsAbstract</li><li>析构：HasDestructor、Destruct</li><li>拷贝：IsPlainOldData、HasCopy、Copy</li><li>比较：HasIdentical、Identical</li><li>导入导出：HasExportTextItem、ExportTextItem、HasImportTextItem、ImportTextItem</li><li>GC：HasAddStructReferencedObjects、AddStructReferencedObjects</li><li>序列化：HasSerializer、HasStructuredSerializer、Serialize、HasPostSerialize、PostSerialize、HasNetSerializer、HasNetSharedSerialization、NetSerialize、HasNetDeltaSerializer、NetDeltaSerialize、HasSerializeFromMismatchedTag、HasStructuredSerializeFromMismatchedTag、SerializeFromMismatchedTag、StructuredSerializeFromMismatchedTag</li></ul><p>有了ICppStructOps的公共接口，和上面特化的信息，UE4在内部对结构进行构造析构或序列化的时候，就可以选择最优的步骤(比如拷贝的时候只需要直接拷贝内存而不需要调用赋值函数)，在GC的时候，也可以告诉UE4这个结构内部有可能有额外的UObject*对象。从而让UE4实现对该结构实现出更高的性能。</p><h3 id="UClass"><a href="#UClass" class="headerlink" title="UClass"></a>UClass</h3><p>Class和Interface放在一起来梳理。</p><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">UINTERFACE</span>(BlueprintType, Blueprintable)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UMyInterface</span> : <span class="hljs-keyword">public</span> UInterface<br>&#123;<br><span class="hljs-built_in">GENERATED_BODY</span>()<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IMyInterface</span><br>&#123;<br><span class="hljs-built_in">GENERATED_BODY</span>()<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">UFUNCTION</span>(BlueprintCallable, BlueprintNativeEvent)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NativeInterfaceFunc</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-built_in">UFUNCTION</span>(BlueprintCallable, BlueprintImplementableEvent)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ImplementableInterfaceFunc</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-built_in">UCLASS</span>(BlueprintType)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UOBJECTLEARN_API</span> UMyClass : <span class="hljs-keyword">public</span> UObject, <span class="hljs-keyword">public</span> IMyInterface<br>&#123;<br><span class="hljs-built_in">GENERATED_BODY</span>()<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">UPROPERTY</span>(BlueprintReadWrite)<br><span class="hljs-type">float</span> Score;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">UFUNCTION</span>(BlueprintCallable)<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Func</span><span class="hljs-params">(<span class="hljs-type">float</span> param1)</span></span>;    <span class="hljs-comment">//C++实现，蓝图调用</span><br><br><span class="hljs-built_in">UFUNCTION</span>(BlueprintNativeEvent)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NativeFunc</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//C++实现默认版本，蓝图可重载实现</span><br><br><span class="hljs-built_in">UFUNCTION</span>(BlueprintImplementableEvent)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ImplementableFunc</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">//C++不实现，蓝图实现</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="关键的生成代码-2"><a href="#关键的生成代码-2" class="headerlink" title="关键的生成代码"></a>关键的生成代码</h4><p>做了些排版的调整，原始生成代码可参考《类型系统收集》部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// UMyInterface参数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Z_Construct_UClass_UMyInterface_Statics</span><br>&#123;<br><span class="hljs-comment">// 依赖项列表</span><br><span class="hljs-type">static</span> UObject* (*<span class="hljs-type">const</span> DependentSingletons[])() = &#123;<br>(UObject* (*)())Z_Construct_UClass_UInterface,<br>(UObject* (*)())Z_Construct_UPackage__Script_UObjectLearn,<br>&#125;;<br><span class="hljs-comment">// 函数参数&#123;(UFunction* (*CreateFuncPtr)()), const char* FuncNameUTF8&#125;[]</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> FClassFunctionLinkInfo FuncInfo[] = &#123;<br>&#123;&amp;Z_Construct_UFunction_UMyInterface_ImplementableInterfaceFunc, <span class="hljs-string">&quot;ImplementableInterfaceFunc&quot;</span>&#125;, <span class="hljs-comment">// 1158132935</span><br>&#123;&amp;Z_Construct_UFunction_UMyInterface_NativeInterfaceFunc, <span class="hljs-string">&quot;NativeInterfaceFunc&quot;</span>&#125;, <span class="hljs-comment">// 737685105</span><br>&#125;;<br><span class="hljs-comment">// c++类信息</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> FCppClassTypeInfoStatic StaticCppClassTypeInfo = &#123;<br>TCppClassTypeTraits&lt;IMyInterface&gt;::IsAbstract,<br>&#125;;<br><span class="hljs-comment">// 类参数</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FClassParams ClassParams = &#123;<br>&amp;UMyInterface::StaticClass, <span class="hljs-comment">// 取出UClass*的函数指针</span><br><span class="hljs-literal">nullptr</span>, <span class="hljs-comment">// config name</span><br>&amp;StaticCppClassTypeInfo, <span class="hljs-comment">// c++类信息</span><br>DependentSingletons, <span class="hljs-comment">// 依赖项</span><br>FuncInfo, <span class="hljs-comment">// 函数参数</span><br><span class="hljs-literal">nullptr</span>,<br><span class="hljs-literal">nullptr</span>,<br><span class="hljs-built_in">UE_ARRAY_COUNT</span>(DependentSingletons),<br><span class="hljs-built_in">UE_ARRAY_COUNT</span>(FuncInfo),<br><span class="hljs-number">0</span>,<br><span class="hljs-number">0</span>,<br><span class="hljs-number">0x000040A1u</span>,<br><span class="hljs-built_in">METADATA_PARAMS</span>(Z_Construct_UClass_UMyInterface_Statics::Class_MetaDataParams,<br><span class="hljs-built_in">UE_ARRAY_COUNT</span>(Z_Construct_UClass_UMyInterface_Statics::Class_MetaDataParams))<br>&#125;;<br>&#125;;<br><span class="hljs-keyword">using</span> FClassRegistrationInfo = TRegistrationInfo&lt;UClass, FClassReloadVersionInfo&gt;;<br>FClassRegistrationInfo Z_Registration_Info_UClass_UMyInterface;<br><span class="hljs-function">UClass* <span class="hljs-title">Z_Construct_UClass_UMyInterface</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!Z_Registration_Info_UClass_UMyInterface.OuterSingleton)<br>&#123;<br>UECodeGen_Private::<span class="hljs-built_in">ConstructUClass</span>(Z_Registration_Info_UClass_UMyInterface.OuterSingleton,<br>                                   Z_Construct_UClass_UMyInterface_Statics::ClassParams);<br>&#125;<br><span class="hljs-keyword">return</span> Z_Registration_Info_UClass_UMyInterface.OuterSingleton;<br>&#125;<br><span class="hljs-comment">// UMyClass参数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Z_Construct_UClass_UMyClass_Statics</span><br>&#123;<br><span class="hljs-comment">// 依赖项列表</span><br><span class="hljs-type">static</span> UObject* (*<span class="hljs-type">const</span> DependentSingletons[])() = &#123;<br>(UObject* (*)())Z_Construct_UClass_UObject, <span class="hljs-comment">// 依赖的基类UObject</span><br>(UObject* (*)())Z_Construct_UPackage__Script_UObjectLearn, <span class="hljs-comment">// 依赖的所属的UPackage</span><br>&#125;;<br><span class="hljs-comment">// 函数参数&#123;(UFunction* (*CreateFuncPtr)()), const char* FuncNameUTF8&#125;[]</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> FClassFunctionLinkInfo FuncInfo[]= &#123;<br>&#123; &amp;Z_Construct_UFunction_UMyClass_Func, <span class="hljs-string">&quot;Func&quot;</span> &#125;, <br>&#123; &amp;Z_Construct_UFunction_UMyClass_ImplementableFunc, <span class="hljs-string">&quot;ImplementableFunc&quot;</span> &#125;, <br>&#123; &amp;Z_Construct_UFunction_UMyClass_NativeFunc, <span class="hljs-string">&quot;NativeFunc&quot;</span> &#125;, <br>&#125;;<br><span class="hljs-comment">// 属性参数</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FFloatPropertyParams NewProp_Score;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FPropertyParamsBase* <span class="hljs-type">const</span> PropPointers[] = &#123;<br>(<span class="hljs-type">const</span> UECodeGen_Private::FPropertyParamsBase*)&amp;Z_Construct_UClass_UMyClass_Statics::NewProp_Score,<br>&#125;;<br><span class="hljs-comment">// 接口</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FImplementedInterfaceParams InterfaceParams[]= &#123;<br>&#123;<br>Z_Construct_UClass_UMyInterface_NoRegister,  <span class="hljs-comment">// 构造UMyInterface所属的UClass*函数指针</span><br>(int32)<span class="hljs-built_in">VTABLE_OFFSET</span>(UMyClass, IMyInterface), <span class="hljs-comment">// 多重继承的指针偏移static_cast&lt;IMyInterface*&gt;((UMyClass*)1)) - 1)</span><br><span class="hljs-literal">false</span> &#125;,  <span class="hljs-comment">// 是否在蓝图实现</span><br>&#125;;<br><span class="hljs-comment">// c++类信息</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> FCppClassTypeInfoStatic StaticCppClassTypeInfo= &#123;<br>TCppClassTypeTraits&lt;UMyClass&gt;::IsAbstract, <span class="hljs-comment">// 是否是虚类</span><br>&#125;;<br><span class="hljs-comment">// class参数</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FClassParams ClassParams= &#123;<br>&amp;UMyClass::StaticClass, <span class="hljs-comment">// 取出UClass*的函数指针</span><br><span class="hljs-literal">nullptr</span>, <span class="hljs-comment">// config name</span><br>&amp;StaticCppClassTypeInfo, <span class="hljs-comment">// c++类信息</span><br>DependentSingletons, <span class="hljs-comment">// 依赖项</span><br>FuncInfo, <span class="hljs-comment">// 函数参数</span><br>Z_Construct_UClass_UMyClass_Statics::PropPointers, <span class="hljs-comment">// 属性参数</span><br>InterfaceParams, <span class="hljs-comment">// 接口信息</span><br><span class="hljs-built_in">UE_ARRAY_COUNT</span>(DependentSingletons),<br><span class="hljs-built_in">UE_ARRAY_COUNT</span>(FuncInfo),<br><span class="hljs-built_in">UE_ARRAY_COUNT</span>(Z_Construct_UClass_UMyClass_Statics::PropPointers),<br><span class="hljs-built_in">UE_ARRAY_COUNT</span>(InterfaceParams),<br><span class="hljs-number">0x001000A0u</span>,<br><span class="hljs-built_in">METADATA_PARAMS</span>(Z_Construct_UClass_UMyClass_Statics::Class_MetaDataParams, <span class="hljs-built_in">UE_ARRAY_COUNT</span>(Z_Construct_UClass_UMyClass_Statics::Class_MetaDataParams))<br>&#125;;<br>&#125;;<br>FClassRegistrationInfo Z_Registration_Info_UClass_UMyClass;<br><span class="hljs-function">UClass* <span class="hljs-title">Z_Construct_UClass_UMyClass</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!Z_Registration_Info_UClass_UMyClass.OuterSingleton)<br>&#123;<br>UECodeGen_Private::<span class="hljs-built_in">ConstructUClass</span>(Z_Registration_Info_UClass_UMyClass.OuterSingleton,<br>                                   Z_Construct_UClass_UMyClass_Statics::ClassParams);<br>&#125;<br><span class="hljs-keyword">return</span> Z_Registration_Info_UClass_UMyClass.OuterSingleton;<br>&#125;<br><span class="hljs-type">const</span> FClassRegisterCompiledInInfo<br>Z_CompiledInDeferFile_FID_code_unreal_learning_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyClass_h_Statics::ClassInfo<br>[] = &#123;<br>&#123;<br>Z_Construct_UClass_UMyInterface, <span class="hljs-comment">// OuterRegister</span><br>UMyInterface::StaticClass, <span class="hljs-comment">// InnerRegister</span><br><span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;UMyInterface&quot;</span>), <span class="hljs-comment">// Name</span><br>&amp;Z_Registration_Info_UClass_UMyInterface, <span class="hljs-comment">// Info</span><br><span class="hljs-built_in">CONSTRUCT_RELOAD_VERSION_INFO</span>(FClassReloadVersionInfo, <span class="hljs-built_in">sizeof</span>(UMyInterface), <span class="hljs-number">2744265783U</span>)<br>&#125;,<br>&#123;<br>Z_Construct_UClass_UMyClass, <span class="hljs-comment">// OuterRegister</span><br>UMyClass::StaticClass, <span class="hljs-comment">// InnerRegister</span><br><span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;UMyClass&quot;</span>), <span class="hljs-comment">// Name</span><br>&amp;Z_Registration_Info_UClass_UMyClass, <span class="hljs-comment">// Info</span><br><span class="hljs-built_in">CONSTRUCT_RELOAD_VERSION_INFO</span>(FClassReloadVersionInfo, <span class="hljs-built_in">sizeof</span>(UMyClass), <span class="hljs-number">220536775U</span>)<br>&#125;,<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">static</span> FRegisterCompiledInInfo</span><br><span class="hljs-function"><span class="hljs-title">Z_CompiledInDeferFile_FID_code_unreal_learning_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyClass_h_2439806653</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;/Script/UObjectLearn&quot;</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">Z_CompiledInDeferFile_FID_code_unreal_learning_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyClass_h_Statics::ClassInfo,</span></span><br><span class="hljs-params"><span class="hljs-function">UE_ARRAY_COUNT(</span></span><br><span class="hljs-params"><span class="hljs-function">Z_CompiledInDeferFile_FID_code_unreal_learning_UELearnProj_Plugins_UObjectLearn_Source_UObjectLearn_Private_MyClass_h_Statics</span></span><br><span class="hljs-params"><span class="hljs-function">::ClassInfo),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>UMyInterface和UClass都是UObject类，所以两者的模式是一样的。但因为UClass继承与IMyInterface，因此就要在UMyClass的UClass*里添加额外的接口继承信息。</p><p><code>FCppClassTypeInfoStatic</code>的作用其实和结构的 <code>ICppStructOps</code>差不多，都是识别原生C++里的类型信息，但UClass毕竟和UStruct的作用不一样，没有那些纯内存构造析构的操作，也都必然有序列化器，所以 <code>FCppClassTypeInfoStatic</code>里目前只有一项bIsAbstract来判断是否该类是虚类。</p><h4 id="UECodeGen-Private-ConstructUClass"><a href="#UECodeGen-Private-ConstructUClass" class="headerlink" title="UECodeGen_Private::ConstructUClass"></a>UECodeGen_Private::ConstructUClass</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ConstructUClass</span><span class="hljs-params">(UClass*&amp; OutClass, <span class="hljs-type">const</span> FClassParams&amp; Params)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (OutClass &amp;&amp; (OutClass-&gt;ClassFlags &amp; CLASS_Constructed)) &#123; <span class="hljs-keyword">return</span>; &#125; <span class="hljs-comment">// 防止重复写入</span><br><span class="hljs-comment">// 构造依赖对象</span><br><span class="hljs-keyword">for</span> (UObject* (*<span class="hljs-type">const</span> *SingletonFunc)() = Params.DependencySingletonFuncArray, *(*<span class="hljs-type">const</span> *SingletonFuncEnd)() = SingletonFunc + Params.NumDependencySingletons; SingletonFunc != SingletonFuncEnd; ++SingletonFunc)<br>&#123;<br>(*SingletonFunc)(); <br>&#125;<br><span class="hljs-comment">// 取得先前生成的UClass*，NoRegister是指没有经过DeferRegister</span><br>UClass* NewClass = Params.<span class="hljs-built_in">ClassNoRegisterFunc</span>(); <br>OutClass = NewClass;<br><br><span class="hljs-keyword">if</span> (NewClass-&gt;ClassFlags &amp; CLASS_Constructed) &#123; <span class="hljs-keyword">return</span>; &#125; <span class="hljs-comment">// 防止重复构造</span><br><br><span class="hljs-built_in">UObjectForceRegistration</span>(NewClass); <span class="hljs-comment">// 确保此UClass*已经注册</span><br><br>UClass* SuperClass = NewClass-&gt;<span class="hljs-built_in">GetSuperClass</span>();<br><span class="hljs-keyword">if</span> (SuperClass)<br>&#123;<br>NewClass-&gt;ClassFlags |= (SuperClass-&gt;ClassFlags &amp; CLASS_Inherit); <span class="hljs-comment">// 标记继承</span><br>&#125;<br><br>NewClass-&gt;ClassFlags |= (EClassFlags)(Params.ClassFlags | CLASS_Constructed); <span class="hljs-comment">// 标记已经构造</span><br><span class="hljs-comment">// 构造函数列表</span><br>NewClass-&gt;<span class="hljs-built_in">CreateLinkAndAddChildFunctionsToMap</span>(Params.FunctionLinkArray, Params.NumFunctions);<br><span class="hljs-comment">// 构造属性列表</span><br><span class="hljs-built_in">ConstructFProperties</span>(NewClass, Params.PropertyArray, Params.NumProperties);<br><span class="hljs-comment">// 设置配置文件名</span><br><span class="hljs-keyword">if</span> (Params.ClassConfigNameUTF8)<br>&#123;<br>NewClass-&gt;ClassConfigName = <span class="hljs-built_in">FName</span>(<span class="hljs-built_in">UTF8_TO_TCHAR</span>(Params.ClassConfigNameUTF8));<br>&#125;<br><span class="hljs-comment">// c++类型信息</span><br>NewClass-&gt;<span class="hljs-built_in">SetCppTypeInfoStatic</span>(Params.CppClassInfo);<br><span class="hljs-comment">// 接口信息</span><br><span class="hljs-keyword">if</span> (int32 NumImplementedInterfaces = Params.NumImplementedInterfaces)<br>&#123;<br>NewClass-&gt;Interfaces.<span class="hljs-built_in">Reserve</span>(NumImplementedInterfaces);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> FImplementedInterfaceParams* ImplementedInterface = Params.ImplementedInterfaceArray, *ImplementedInterfaceEnd = ImplementedInterface + NumImplementedInterfaces; ImplementedInterface != ImplementedInterfaceEnd; ++ImplementedInterface)<br>&#123;<br>UClass* (*ClassFunc)() = ImplementedInterface-&gt;ClassFunc;<br>UClass* InterfaceClass = ClassFunc ? <span class="hljs-built_in">ClassFunc</span>() : <span class="hljs-literal">nullptr</span>;<br><br>NewClass-&gt;Interfaces.<span class="hljs-built_in">Emplace</span>(InterfaceClass, ImplementedInterface-&gt;Offset, ImplementedInterface-&gt;bImplementedByK2);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 复合类型的链接</span><br>NewClass-&gt;<span class="hljs-built_in">StaticLink</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UClass::CreateLinkAndAddChildFunctionsToMap</span><span class="hljs-params">(<span class="hljs-type">const</span> FClassFunctionLinkInfo* Functions, uint32 NumFunctions)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (; NumFunctions; --NumFunctions, ++Functions)<br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* FuncNameUTF8 = Functions-&gt;FuncNameUTF8;<br>UFunction*  Func         = Functions-&gt;<span class="hljs-built_in">CreateFuncPtr</span>(); <span class="hljs-comment">// 调用构造UFunction*对象</span><br><br>Func-&gt;Next = Children;<br>Children = Func; <span class="hljs-comment">// 新函数挂在UField*链表的开头</span><br><br><span class="hljs-built_in">AddFunctionToFunctionMap</span>(Func, <span class="hljs-built_in">FName</span>(<span class="hljs-built_in">UTF8_TO_TCHAR</span>(FuncNameUTF8)));<br><span class="hljs-comment">//内部实现是：FuncMap.Add(FuncName, Function);添加到FuncMap里</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用模式和UScriptStruct类似，首先构造依赖的对象，然后通过 <code>ClassNoRegisterFunc</code>获得 <code>UClass*</code>对象(NoRegister指的是没有经过DeferRegister，即 <code>UMyClass::StaticClass</code>)。</p><p>然后进行函数列表、属性列表和接口的构造。最后调用 <code>StaticLink</code>来链接子属性。</p><p><code>CreateLinkAndAddChildFunctionsToMap</code>构造函数列表，就是循环创建 <code>UFunction*</code>，然后添加到 <code>FuncMap</code>中。</p><p><code>Children</code>其实是一个 <code>UFiled*</code>的单链表，添加属性和函数都是直接挂在链表头的。通过构造顺序得知，<code>Children</code>的顺序是先所有 <code>FProperty*</code>，之后才是所有的 <code>UFunction*</code>。但 <code>FProperty*</code>的顺序跟代码里定义顺序一致，因为UHT生成的代码里 <code>PropPointers</code>里敲好是倒序排列的。而 <code>UFunction*</code>的顺序是根据函数名字排序后的反序。</p><h3 id="UPackage"><a href="#UPackage" class="headerlink" title="UPackage"></a>UPackage</h3><p>我们注意到在构造UEnum、UScriptStruct和UClass的一开始都有一个构造Outer的过程，这个OuterFunc其实指向了这个Module的Package的构造，这个函数一般在模块的init.gen.cpp里。</p><h4 id="关键的生成代码-3"><a href="#关键的生成代码-3" class="headerlink" title="关键的生成代码"></a>关键的生成代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">static</span> FPackageRegistrationInfo Z_Registration_Info_UPackage__Script_UObjectLearn;<br><span class="hljs-function">UPackage* <span class="hljs-title">Z_Construct_UPackage__Script_UObjectLearn</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!Z_Registration_Info_UPackage__Script_UObjectLearn.OuterSingleton)<br>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FPackageParams PackageParams = &#123;<br><span class="hljs-string">&quot;/Script/UObjectLearn&quot;</span>,<br><span class="hljs-literal">nullptr</span>,<br><span class="hljs-number">0</span>,<br>PKG_CompiledIn | <span class="hljs-number">0x00000000</span>,<br><span class="hljs-number">0xAADC3A20</span>,<br><span class="hljs-number">0xD6628E7C</span>,<br><span class="hljs-built_in">METADATA_PARAMS</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>)<br>&#125;;<br>UECodeGen_Private::<span class="hljs-built_in">ConstructUPackage</span>(Z_Registration_Info_UPackage__Script_UObjectLearn.OuterSingleton, PackageParams);<br>&#125;<br><span class="hljs-keyword">return</span> Z_Registration_Info_UPackage__Script_UObjectLearn.OuterSingleton;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> FRegisterCompiledInInfo <span class="hljs-title">Z_CompiledInDeferPackage_UPackage__Script_UObjectLearn</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">Z_Construct_UPackage__Script_UObjectLearn, </span></span><br><span class="hljs-params"><span class="hljs-function">TEXT(<span class="hljs-string">&quot;/Script/UObjectLearn&quot;</span>), </span></span><br><span class="hljs-params"><span class="hljs-function">Z_Registration_Info_UPackage__Script_UObjectLearn, </span></span><br><span class="hljs-params"><span class="hljs-function">CONSTRUCT_RELOAD_VERSION_INFO(FPackageReloadVersionInfo, <span class="hljs-number">0xAADC3A20</span>, <span class="hljs-number">0xD6628E7C</span>)</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br><br><br></code></pre></td></tr></table></figure><h4 id="UECodeGen-Private-ConstructUPackage"><a href="#UECodeGen-Private-ConstructUPackage" class="headerlink" title="UECodeGen_Private::ConstructUPackage"></a>UECodeGen_Private::ConstructUPackage</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ConstructUPackage</span><span class="hljs-params">(UPackage*&amp; OutPackage, <span class="hljs-type">const</span> FPackageParams&amp; Params)</span></span><br><span class="hljs-function"></span>&#123; <br><span class="hljs-keyword">if</span> (OutPackage) &#123; <span class="hljs-keyword">return</span>; &#125; <span class="hljs-comment">// 防止重复写入</span><br><span class="hljs-comment">// 找到之前创建的UPackage，UPackage在之前UClass*对象Register的时候就已经Create出来了</span><br>UObject* FoundPackage = <span class="hljs-built_in">StaticFindObjectFast</span>(UPackage::<span class="hljs-built_in">StaticClass</span>(), <span class="hljs-literal">nullptr</span>, <span class="hljs-built_in">FName</span>(<span class="hljs-built_in">UTF8_TO_TCHAR</span>(Params.NameUTF8)), <span class="hljs-literal">false</span>);<br><br>UPackage* NewPackage = <span class="hljs-built_in">CastChecked</span>&lt;UPackage&gt;(FoundPackage);<br>OutPackage = NewPackage;<br><span class="hljs-comment">// 设定标记</span><br>NewPackage-&gt;<span class="hljs-built_in">SetPackageFlags</span>(Params.PackageFlags);<br>NewPackage-&gt;<span class="hljs-built_in">SetGuid</span>(<span class="hljs-built_in">FGuid</span>(Params.BodyCRC, Params.DeclarationsCRC, <span class="hljs-number">0u</span>, <span class="hljs-number">0u</span>));<br><br>TCHAR PackageName[FName::StringBufferSize];<br>NewPackage-&gt;<span class="hljs-built_in">GetFName</span>().<span class="hljs-built_in">ToString</span>(PackageName);<br><span class="hljs-keyword">for</span> (UObject* (*<span class="hljs-type">const</span> *SingletonFunc)() = Params.SingletonFuncArray, *(*<span class="hljs-type">const</span> *SingletonFuncEnd)() = SingletonFunc + Params.NumSingletons; SingletonFunc != SingletonFuncEnd; ++SingletonFunc)<br>&#123;<br>UObject* Object = (*SingletonFunc)(); <span class="hljs-comment">// 调用构造前提对象</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="FProperty"><a href="#FProperty" class="headerlink" title="FProperty"></a>FProperty</h3><h4 id="关键的生成代码-4"><a href="#关键的生成代码-4" class="headerlink" title="关键的生成代码"></a>关键的生成代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// UMyClass参数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Z_Construct_UClass_UMyClass_Statics</span><br>&#123;<br><span class="hljs-comment">// 属性参数</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FFloatPropertyParams NewProp_Score = &#123;<br><span class="hljs-string">&quot;Score&quot;</span>, <br><span class="hljs-literal">nullptr</span>, <br>(EPropertyFlags)<span class="hljs-number">0x0010000000000004</span>, <br>UECodeGen_Private::EPropertyGenFlags::Float,<br>RF_Public | RF_Transient | RF_MarkAsNative, <br><span class="hljs-number">1</span>, <span class="hljs-literal">nullptr</span>, <br><span class="hljs-literal">nullptr</span>, <br><span class="hljs-built_in">STRUCT_OFFSET</span>(UMyClass, Score), <br><span class="hljs-built_in">METADATA_PARAMS</span>(<br>Z_Construct_UClass_UMyClass_Statics::NewProp_Score_MetaData,<br><span class="hljs-built_in">UE_ARRAY_COUNT</span>(Z_Construct_UClass_UMyClass_Statics::NewProp_Score_MetaData))<br>&#125;;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FPropertyParamsBase* <span class="hljs-type">const</span> PropPointers[] = &#123;<br>(<span class="hljs-type">const</span> UECodeGen_Private::FPropertyParamsBase*)&amp;Z_Construct_UClass_UMyClass_Statics::NewProp_Score,<br>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="UECodeGen-Private-ConstructFProperties"><a href="#UECodeGen-Private-ConstructFProperties" class="headerlink" title="UECodeGen_Private::ConstructFProperties"></a>UECodeGen_Private::ConstructFProperties</h4><p>在 <code>UECodeGen_Private::ConstructUClass</code>中调用了 <code>ConstructFProperties</code>,会遍历数组调用 <code>ConstructFProperty</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ConstructFProperties</span><span class="hljs-params">(UObject* Outer, <span class="hljs-type">const</span> FPropertyParamsBase* <span class="hljs-type">const</span>* PropertyArray, int32 NumProperties)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// Move pointer to the end, because we&#x27;ll iterate backwards over the properties</span><br>PropertyArray += NumProperties;<br><span class="hljs-keyword">while</span> (NumProperties)<br>&#123;<br><span class="hljs-built_in">ConstructFProperty</span>(Outer, PropertyArray, NumProperties);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ConstructFProperty</span><span class="hljs-params">(FFieldVariant Outer, <span class="hljs-type">const</span> FPropertyParamsBase* <span class="hljs-type">const</span>*&amp; PropertyArray, int32&amp; NumProperties)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> FPropertyParamsBase* PropBase = *--PropertyArray;<br><br>uint32 ReadMore = <span class="hljs-number">0</span>;<br><br>FProperty* NewProp = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">switch</span> (PropBase-&gt;Flags &amp; PropertyTypeMask)<br>&#123;<br><span class="hljs-keyword">default</span>:<br>&#123;<br><span class="hljs-comment">// Unsupported property type</span><br><span class="hljs-built_in">check</span>(<span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-keyword">case</span> EPropertyGenFlags::Float:<br>&#123;<br>NewProp = <span class="hljs-built_in">NewFProperty</span>&lt;FFloatProperty, FFloatPropertyParams&gt;(Outer, *PropBase);<br>&#125;<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> EPropertyGenFlags::Array:<br>&#123;<br>NewProp = <span class="hljs-built_in">NewFProperty</span>&lt;FArrayProperty, FArrayPropertyParams&gt;(Outer, *PropBase);<br><br><span class="hljs-comment">// Next property is the array inner</span><br>ReadMore = <span class="hljs-number">1</span>; <span class="hljs-comment">// 需要一个子属性</span><br>&#125;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">// case其他的各种类型属性</span><br>&#125;<br><br>NewProp-&gt;ArrayDim = PropBase-&gt;ArrayDim; <span class="hljs-comment">// 设定属性维度，单属性为1，int32 prop[10]这种的为10</span><br><span class="hljs-keyword">if</span> (PropBase-&gt;RepNotifyFuncUTF8)<br>&#123; <span class="hljs-comment">// 属性的复制通知函数名</span><br>NewProp-&gt;RepNotifyFunc = <span class="hljs-built_in">FName</span>(<span class="hljs-built_in">UTF8_TO_TCHAR</span>(PropBase-&gt;RepNotifyFuncUTF8));<br>&#125;<br><br>--NumProperties;<br><br><span class="hljs-keyword">for</span> (; ReadMore; --ReadMore)<br>&#123; <span class="hljs-comment">// 构造子属性，注意这里以现在的属性NewProp为Outer</span><br><span class="hljs-built_in">ConstructFProperty</span>(NewProp, PropertyArray, NumProperties);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="UProperty和FProperty"><a href="#UProperty和FProperty" class="headerlink" title="UProperty和FProperty"></a>UProperty和FProperty</h4><p>UE4.25将 <code>UProporty</code>变成了 <code>FProproty</code>。</p><p>因为 <code>UProperty</code>继承了 <code>UObject</code>，而整个UE框架下的类中会有大量的属性，导致 <code>UProperty</code>的<strong>构建\消耗成本很高</strong>，影响垃圾回收性能。</p><p>更改为FProperty，不在继承UObject。</p><p><a href="https://zhuanlan.zhihu.com/p/380610877">UE4 FProperty - 知乎 (zhihu.com)</a></p><h3 id="UFunction"><a href="#UFunction" class="headerlink" title="UFunction"></a>UFunction</h3><h4 id="关键的生成代码-5"><a href="#关键的生成代码-5" class="headerlink" title="关键的生成代码"></a>关键的生成代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UMyClass::ImplementableFunc</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">ProcessEvent</span>(<span class="hljs-built_in">FindFunctionChecked</span>(NAME_UMyClass_ImplementableFunc),<span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UMyClass::NativeFunc</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">ProcessEvent</span>(<span class="hljs-built_in">FindFunctionChecked</span>(NAME_UMyClass_NativeFunc),<span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UMyClass::StaticRegisterNativesUMyClass</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>UClass* Class = UMyClass::<span class="hljs-built_in">StaticClass</span>();<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> FNameNativePtrPair Funcs[] = &#123;<br>&#123;<span class="hljs-string">&quot;Func&quot;</span>, &amp;UMyClass::execFunc&#125;,<br>&#123;<span class="hljs-string">&quot;NativeFunc&quot;</span>, &amp;UMyClass::execNativeFunc&#125;,<br>&#125;;<br>FNativeFunctionRegistrar::<span class="hljs-built_in">RegisterFunctions</span>(Class, Funcs, <span class="hljs-built_in">UE_ARRAY_COUNT</span>(Funcs));<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Z_Construct_UFunction_UMyClass_Func_Statics</span><br>&#123;<br><span class="hljs-comment">// 将参数和返回值打包成一个结构来存储</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyClass_eventFunc_Parms</span> <br>&#123;<br><span class="hljs-type">float</span> param1;<br>int32 ReturnValue;<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FFloatPropertyParams NewProp_param1 = &#123;<br><span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-comment">// Name</span><br><span class="hljs-literal">nullptr</span>, <span class="hljs-comment">// NotifyFuncName</span><br>(EPropertyFlags)<span class="hljs-number">0x0010000000000080</span>,  <span class="hljs-comment">// PerportyFlags</span><br>UECodeGen_Private::EPropertyGenFlags::Float, <span class="hljs-comment">// Flags</span><br>RF_Public | RF_Transient | RF_MarkAsNative, <span class="hljs-comment">// ObjectFlag</span><br><span class="hljs-number">1</span>, <span class="hljs-comment">// ArrayDim</span><br><span class="hljs-literal">nullptr</span>, <span class="hljs-comment">// SetterFunc</span><br><span class="hljs-literal">nullptr</span>, <span class="hljs-comment">// GetterFunc</span><br><span class="hljs-built_in">STRUCT_OFFSET</span>(MyClass_eventFunc_Parms, param1),<br><span class="hljs-built_in">METADATA_PARAMS</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>)<br>&#125;;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FUnsizedIntPropertyParams NewProp_ReturnValue = &#123;<br><span class="hljs-string">&quot;ReturnValue&quot;</span>, <br><span class="hljs-literal">nullptr</span>, <br>(EPropertyFlags)<span class="hljs-number">0x0010000000000580</span>, <br>UECodeGen_Private::EPropertyGenFlags::Int,<br>RF_Public | RF_Transient | RF_MarkAsNative, <br><span class="hljs-number">1</span>, <br><span class="hljs-literal">nullptr</span>, <br><span class="hljs-literal">nullptr</span>,<br><span class="hljs-built_in">STRUCT_OFFSET</span>(MyClass_eventFunc_Parms, ReturnValue), <br><span class="hljs-built_in">METADATA_PARAMS</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>)<br>&#125;;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FPropertyParamsBase* <span class="hljs-type">const</span> PropPointers[] = &#123;<br>(<span class="hljs-type">const</span> UECodeGen_Private::FPropertyParamsBase*)&amp;Z_Construct_UFunction_UMyClass_Func_Statics::NewProp_param1,<br>(<span class="hljs-type">const</span> UECodeGen_Private::FPropertyParamsBase*)&amp;Z_Construct_UFunction_UMyClass_Func_Statics::NewProp_ReturnValue,<br>&#125;;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> UECodeGen_Private::FFunctionParams FuncParams = &#123;<br>(UObject*(*)())Z_Construct_UClass_UMyClass, <span class="hljs-comment">// OuterFunc</span><br><span class="hljs-literal">nullptr</span>, <span class="hljs-comment">// SuperFunc</span><br><span class="hljs-string">&quot;Func&quot;</span>,  <span class="hljs-comment">// Name</span><br><span class="hljs-literal">nullptr</span>,  <span class="hljs-comment">// OwningClassName</span><br><span class="hljs-literal">nullptr</span>, <span class="hljs-comment">// DelegateName</span><br><span class="hljs-built_in">sizeof</span>(Z_Construct_UFunction_UMyClass_Func_Statics::MyClass_eventFunc_Parms),<br>Z_Construct_UFunction_UMyClass_Func_Statics::PropPointers, <br><span class="hljs-built_in">UE_ARRAY_COUNT</span>(Z_Construct_UFunction_UMyClass_Func_Statics::PropPointers),<br>RF_Public | RF_Transient | RF_MarkAsNative, <span class="hljs-comment">// ObjectFlag</span><br>(EFunctionFlags)<span class="hljs-number">0x04020401</span>, <span class="hljs-comment">// FunctionFlag</span><br><span class="hljs-number">0</span>, <span class="hljs-comment">// RPCId</span><br><span class="hljs-number">0</span>, <span class="hljs-comment">// RPCResId</span><br><span class="hljs-built_in">METADATA_PARAMS</span>(<br>Z_Construct_UFunction_UMyClass_Func_Statics::Function_MetaDataParams,<br><span class="hljs-built_in">UE_ARRAY_COUNT</span>(Z_Construct_UFunction_UMyClass_Func_Statics::Function_MetaDataParams))<br>&#125;;<br>&#125;;<br><span class="hljs-function">UFunction* <span class="hljs-title">Z_Construct_UFunction_UMyClass_Func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">static</span> UFunction* ReturnFunction = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">if</span> (!ReturnFunction)<br>&#123;<br>UECodeGen_Private::<span class="hljs-built_in">ConstructUFunction</span>(&amp;ReturnFunction, Z_Construct_UFunction_UMyClass_Func_Statics::FuncParams);<br>&#125;<br><span class="hljs-keyword">return</span> ReturnFunction;<br>&#125;<br>... 其他函数 ...<br><span class="hljs-comment">// 用于构造UClass的Function信息</span><br><span class="hljs-type">const</span> FClassFunctionLinkInfo Z_Construct_UClass_UMyClass_Statics::FuncInfo[] = &#123;<br>&#123;&amp;Z_Construct_UFunction_UMyClass_Func, <span class="hljs-string">&quot;Func&quot;</span>&#125;, <span class="hljs-comment">// 606342113</span><br>&#123;&amp;Z_Construct_UFunction_UMyClass_ImplementableFunc, <span class="hljs-string">&quot;ImplementableFunc&quot;</span>&#125;, <span class="hljs-comment">// 3002894782</span><br>&#123;&amp;Z_Construct_UFunction_UMyClass_NativeFunc, <span class="hljs-string">&quot;NativeFunc&quot;</span>&#125;, <span class="hljs-comment">// 3237508567</span><br>&#125;;<br><span class="hljs-comment">// 接口函数</span><br><span class="hljs-function">UFunction* <span class="hljs-title">Z_Construct_UFunction_UMyInterface_ImplementableInterfaceFunc</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">static</span> UFunction* ReturnFunction = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">if</span> (!ReturnFunction)<br>&#123;<br>UECodeGen_Private::<span class="hljs-built_in">ConstructUFunction</span>(&amp;ReturnFunction,<br>                                      Z_Construct_UFunction_UMyInterface_ImplementableInterfaceFunc_Statics::FuncParams);<br>&#125;<br><span class="hljs-keyword">return</span> ReturnFunction;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">IMyInterface::Execute_ImplementableInterfaceFunc</span><span class="hljs-params">(UObject* O)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 通过名字查找函数</span><br>UFunction* <span class="hljs-type">const</span> Func = O-&gt;<span class="hljs-built_in">FindFunction</span>(NAME_UMyInterface_ImplementableInterfaceFunc);<br><span class="hljs-keyword">if</span> (Func)<br>&#123;<br>O-&gt;<span class="hljs-built_in">ProcessEvent</span>(Func, <span class="hljs-literal">NULL</span>);<br>&#125;<span class="hljs-comment">//找不到，其实不会报错，所以是在尝试调用一个接口函数</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">IMyInterface::Execute_NativeInterfaceFunc</span><span class="hljs-params">(UObject* O)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 通过名字查找函数</span><br>UFunction* <span class="hljs-type">const</span> Func = O-&gt;<span class="hljs-built_in">FindFunction</span>(NAME_UMyInterface_NativeInterfaceFunc);<br><span class="hljs-keyword">if</span> (Func)<br>&#123;<br>O-&gt;<span class="hljs-built_in">ProcessEvent</span>(Func, <span class="hljs-literal">NULL</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> I = (IMyInterface*)(O-&gt;<span class="hljs-built_in">GetNativeInterfaceAddress</span>(UMyInterface::<span class="hljs-built_in">StaticClass</span>())))<br>&#123; <span class="hljs-comment">// 如果找不到蓝图中的版本，则会尝试调用C++里的_Implementation默认实现。</span><br>I-&gt;<span class="hljs-built_in">NativeInterfaceFunc_Implementation</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数的参数和返回值都打包成一个结构（<code>MyClass_eventFunc_Parms</code>），这样 <code>FProperty</code>才能有一个Offset的宿主。但有意思的是，其实这个结构（<code>MyClass_eventFunc_Parms</code>）我们只需要它的大小，并不需要它的实际类型定义，因为只要用它分配一块内存布局一致的内存就可以了。</p><p>UHT为我们生成了一些函数的默认实现，如 <code>ImplementableFunc</code>和 <code>NativeFunc</code>，还有接口里的函数，所以我们不应该在C++里再重复实现（写了也会报错）。它们的内部实现也都是通过 <code>ProcessEvent</code>来调用蓝图中的版本，或者调用C++里的 <code>_Implementation</code>默认版本实现。</p><h4 id="UECodeGen-Private-ConstructUFunction"><a href="#UECodeGen-Private-ConstructUFunction" class="headerlink" title="UECodeGen_Private::ConstructUFunction"></a>UECodeGen_Private::ConstructUFunction</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ConstructUFunction</span><span class="hljs-params">(UFunction** SingletonPtr, <span class="hljs-type">const</span> FFunctionParams&amp; Params)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">ConstructUFunctionInternal</span>(*SingletonPtr, Params, SingletonPtr);<br>&#125;<br><span class="hljs-function">FORCEINLINE <span class="hljs-type">void</span> <span class="hljs-title">ConstructUFunctionInternal</span><span class="hljs-params">(UFunction*&amp; OutFunction, <span class="hljs-type">const</span> FFunctionParams&amp; Params, UFunction** SingletonPtr)</span></span><br><span class="hljs-function"></span>&#123;<br>UObject*   (*OuterFunc)() = Params.OuterFunc;<br>UFunction* (*SuperFunc)() = Params.SuperFunc;<br><span class="hljs-comment">// 构造依赖对象</span><br>UObject*   Outer = OuterFunc ? <span class="hljs-built_in">OuterFunc</span>() : <span class="hljs-literal">nullptr</span>;<br>UFunction* Super = SuperFunc ? <span class="hljs-built_in">SuperFunc</span>() : <span class="hljs-literal">nullptr</span>;<br><span class="hljs-comment">// 防止重新写入</span><br><span class="hljs-keyword">if</span> (OutFunction)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function">FName <span class="hljs-title">FuncName</span><span class="hljs-params">(UTF8_TO_TCHAR(Params.NameUTF8))</span></span>;<br><span class="hljs-comment">// 构造UFunction*</span><br>UFunction* NewFunction;<br><span class="hljs-keyword">if</span> (Params.FunctionFlags &amp; FUNC_Delegate)<br>&#123; <span class="hljs-comment">//生成委托函数</span><br><span class="hljs-keyword">if</span> (Params.OwningClassName == <span class="hljs-literal">nullptr</span>)<br>&#123;<br>NewFunction = <span class="hljs-built_in">new</span> (EC_InternalUseOnlyConstructor, Outer, FuncName, Params.ObjectFlags) <span class="hljs-built_in">UDelegateFunction</span>(<br><span class="hljs-built_in">FObjectInitializer</span>(),<br>Super,<br>Params.FunctionFlags,<br>Params.StructureSize<br>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>USparseDelegateFunction* NewSparseFunction = <span class="hljs-built_in">new</span> (EC_InternalUseOnlyConstructor, Outer, FuncName, Params.ObjectFlags) <span class="hljs-built_in">USparseDelegateFunction</span>(<br><span class="hljs-built_in">FObjectInitializer</span>(),<br>Super,<br>Params.FunctionFlags,<br>Params.StructureSize<br>);<br>NewSparseFunction-&gt;OwningClassName = <span class="hljs-built_in">FName</span>(Params.OwningClassName);<br>NewSparseFunction-&gt;DelegateName = <span class="hljs-built_in">FName</span>(Params.DelegateName);<br>NewFunction = NewSparseFunction;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>NewFunction = <span class="hljs-built_in">new</span> (EC_InternalUseOnlyConstructor, Outer, FuncName, Params.ObjectFlags) <span class="hljs-built_in">UFunction</span>(<br><span class="hljs-built_in">FObjectInitializer</span>(),<br>Super,<br>Params.FunctionFlags,<br>Params.StructureSize<br>);<br>&#125;<br>OutFunction = NewFunction;<br><br>NewFunction-&gt;RPCId = Params.RPCId;<br>NewFunction-&gt;RPCResponseId = Params.RPCResponseId;<br><span class="hljs-comment">// 构造FProperty</span><br><span class="hljs-built_in">ConstructFProperties</span>(NewFunction, Params.PropertyArray, Params.NumProperties);<br><br>NewFunction-&gt;<span class="hljs-built_in">Bind</span>(); <span class="hljs-comment">// 函数绑定</span><br>NewFunction-&gt;<span class="hljs-built_in">StaticLink</span>(); <span class="hljs-comment">// 函数链接</span><br>&#125;<br></code></pre></td></tr></table></figure><p>构造的老套路，生成依赖，然后在new出对象，<code>UFunction</code>生成 <code>FProperty</code>列表当做参数和返回值，最后在依次Bind和Link。</p><h3 id="绑定链接"><a href="#绑定链接" class="headerlink" title="绑定链接"></a>绑定链接</h3><p>在构造完各类型对象后，还需要完成一些后初始化工作。类比C++编译，最后一步是链接，通过符号定位到函数地址来替换。</p><h4 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h4><p><strong>绑定的作用是把函数指针绑定到正确的地址！</strong></p><p>Bind()是UField的虚方法，但只有UFunction和UClass才重写了这个方法。</p><h5 id="UFunction-Bind"><a href="#UFunction-Bind" class="headerlink" title="UFunction::Bind()"></a>UFunction::Bind()</h5><p>目的是把 <code>FNativeFuncPtr Func</code>绑定到正确的函数指针里去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UFunction::Bind</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>UClass* OwnerClass = <span class="hljs-built_in">GetOwnerClass</span>();<br><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">HasAnyFunctionFlags</span>(FUNC_Native))<br>&#123;<br><span class="hljs-comment">// 非native函数指向蓝图调用</span><br>Func = &amp;UObject::ProcessInternal;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>FName Name = <span class="hljs-built_in">GetFName</span>();<br><span class="hljs-comment">// 在之前注册的naive函数表里去查找函数指针</span><br>FNativeFunctionLookup* Found = OwnerClass-&gt;NativeFunctionLookupTable.<span class="hljs-built_in">FindByPredicate</span>(<br>[=](<span class="hljs-type">const</span> FNativeFunctionLookup&amp; NativeFunctionLookup)&#123; <br><span class="hljs-keyword">return</span> Name == NativeFunctionLookup.Name; &#125;);<br><span class="hljs-keyword">if</span> (Found)<br>&#123;<br>Func = Found-&gt;Pointer; <span class="hljs-comment">// 定位到c++代码里的函数指针。</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="UClass-Bind"><a href="#UClass-Bind" class="headerlink" title="UClass::Bind()"></a>UClass::Bind()</h5><p>UClass的Bind在编译蓝图和载入Package里的类才需要调用，因为native的类在之前的GetPrivateStaticClassBody的时候已经传进去了函数指针。只有没有C++代码实体的类才需要绑定到基类里的构造函数等才能正确正确继承下来这些函数来调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UClass::Bind</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>UStruct::<span class="hljs-built_in">Bind</span>();<br>UClass* SuperClass = <span class="hljs-built_in">GetSuperClass</span>();<br><span class="hljs-keyword">if</span> (SuperClass <br>&amp;&amp; <br>(ClassConstructor == <span class="hljs-literal">nullptr</span> <br>|| !CppClassStaticFunctions.<span class="hljs-built_in">IsInitialized</span>()<br>|| ClassVTableHelperCtorCaller == <span class="hljs-literal">nullptr</span>)<br>)<br>&#123;<br>SuperClass-&gt;<span class="hljs-built_in">Bind</span>(); <span class="hljs-comment">// 确保基类已经绑定</span><br><span class="hljs-keyword">if</span> (!ClassConstructor)<br>&#123;<br>ClassConstructor = SuperClass-&gt;ClassConstructor; <span class="hljs-comment">// 绑定构造函数指针</span><br>&#125;<br><span class="hljs-keyword">if</span> (!ClassVTableHelperCtorCaller)<br>&#123;<br>ClassVTableHelperCtorCaller = SuperClass-&gt;ClassVTableHelperCtorCaller; <span class="hljs-comment">// 绑定HotReload函数指针</span><br>&#125;<br><span class="hljs-keyword">if</span> (!CppClassStaticFunctions.<span class="hljs-built_in">IsInitialized</span>())<br>&#123;<br>CppClassStaticFunctions = SuperClass-&gt;CppClassStaticFunctions; <span class="hljs-comment">// 绑定AddReferencedObjects指针</span><br>&#125;<br><br>ClassCastFlags |= SuperClass-&gt;ClassCastFlags;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Bind的这三个函数指针和 <code>GetPrivateStaticClassBody</code>传入的指针是一样的。</p><h4 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h4><p>在构造UScriptStuct和UClass的最后一步都调用了StaicLink，它其实是UStruct的一个方法，包装了一个空的序列化归档类对象后转发到 <code>UStruct::Link</code>函数上去</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UStruct::StaticLink</span><span class="hljs-params">(<span class="hljs-type">bool</span> bRelinkExistingProperties)</span></span><br><span class="hljs-function"></span>&#123;<br>FArchive ArDummy;<br><span class="hljs-built_in">Link</span>(ArDummy, bRelinkExistingProperties);<br>&#125;<br></code></pre></td></tr></table></figure><p>而 <code>UStruct::Link</code>又是一个虚函数，在很多的子类中都有重载。StaicLink也在很多地方有调用。 Link这个词其实有三层意思：</p><ol><li>跟编译器的Link一样，编译完成后的最后一个操作链接，替换符号地址等。典型的是在结构改变或者编译后重新Link。</li><li>把子字段们按照属性特征分成一个个链条，为了在不同的应用场景下加速性能，不需要每次去遍历所有的属性。</li><li>序列化的时候也有概念Link，用来充当磁盘和内存里对象的链接桥梁。同样，在一个保存在磁盘里的类型被序列化出来之后，就需要再Link一下来重新设置属性的偏移，结构内存对齐等。这也是Link需要一个FArchive参数的原因。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UStruct::Link</span><span class="hljs-params">(FArchive&amp; Ar, <span class="hljs-type">bool</span> bRelinkExistingProperties)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (FField* Field = ChildProperties; (Field != <span class="hljs-literal">NULL</span>) &amp;&amp; (Field-&gt;<span class="hljs-built_in">GetOwner</span>&lt;UObject&gt;() == <span class="hljs-keyword">this</span>); Field = Field-&gt;Next)<br>&#123;<br><span class="hljs-keyword">if</span> (FProperty* Property = <span class="hljs-built_in">CastField</span>&lt;FProperty&gt;(Field))<br>&#123;<br>Property-&gt;<span class="hljs-built_in">LinkWithoutChangingOffset</span>(Ar); <span class="hljs-comment">// 调用LinkInternal。有FBoolProperty、FEnumProperty、FStructProperty实现</span><br>&#125;<br>&#125;<br>FProperty** PropertyLinkPtr = &amp;PropertyLink; <span class="hljs-comment">// 所有属性</span><br>FProperty** DestructorLinkPtr = &amp;DestructorLink; <span class="hljs-comment">// 包含对象引用(UObject*)的属性，对GC有影响</span><br>FProperty** RefLinkPtr = (FProperty**)&amp;RefLink; <span class="hljs-comment">// 所有需要从CDO中获取初始值的属性</span><br>FProperty** PostConstructLinkPtr = &amp;PostConstructLink; <span class="hljs-comment">// 需要额外析构的属性</span><br><br>TArray&lt;<span class="hljs-type">const</span> FStructProperty*&gt; EncounteredStructProps;<br><span class="hljs-keyword">for</span> (TFieldIterator&lt;FProperty&gt; <span class="hljs-built_in">It</span>(<span class="hljs-keyword">this</span>); It; ++It)  <span class="hljs-comment">// 遍历出所有属性</span><br>&#123;<br>FProperty* Property = *It;<br><br><span class="hljs-keyword">if</span> (Property-&gt;<span class="hljs-built_in">ContainsObjectReference</span>(EncounteredStructProps) <br>|| Property-&gt;<span class="hljs-built_in">ContainsWeakObjectReference</span>())<br>&#123;<br>*RefLinkPtr = Property; <span class="hljs-comment">// 包含对象引用的属性</span><br>RefLinkPtr = &amp;(*RefLinkPtr)-&gt;NextRef;<br>&#125;<br><br><span class="hljs-type">const</span> UClass* OwnerClass = Property-&gt;<span class="hljs-built_in">GetOwnerClass</span>();<br><span class="hljs-type">bool</span> bOwnedByNativeClass = OwnerClass &amp;&amp; OwnerClass-&gt;<span class="hljs-built_in">HasAnyClassFlags</span>(CLASS_Native | CLASS_Intrinsic);<br><br><span class="hljs-keyword">if</span> (!Property-&gt;<span class="hljs-built_in">HasAnyPropertyFlags</span>(CPF_IsPlainOldData | CPF_NoDestructor) <br>&amp;&amp;<br>!bOwnedByNativeClass) <br>&#123;<br>*DestructorLinkPtr = Property; <span class="hljs-comment">// 需要额外析构的属性</span><br>DestructorLinkPtr = &amp;(*DestructorLinkPtr)-&gt;DestructorLinkNext;<br>&#125;<br><br><span class="hljs-keyword">if</span> (OwnerClass <br>&amp;&amp; <br>(!bOwnedByNativeClass <br>|| (Property-&gt;<span class="hljs-built_in">HasAnyPropertyFlags</span>(CPF_Config) <br>&amp;&amp; <br>!OwnerClass-&gt;<span class="hljs-built_in">HasAnyClassFlags</span>(CLASS_PerObjectConfig))<br>))<br>&#123;<br>*PostConstructLinkPtr = Property; <span class="hljs-comment">// 需要从CDO中获取初始值的属性</span><br>PostConstructLinkPtr = &amp;(*PostConstructLinkPtr)-&gt;PostConstructLinkNext;<br>&#125;<br><br>*PropertyLinkPtr = Property; <span class="hljs-comment">// 所有属性</span><br>PropertyLinkPtr = &amp;(*PropertyLinkPtr)-&gt;PropertyLinkNext;<br>&#125;<br><br>*PropertyLinkPtr = <span class="hljs-literal">nullptr</span>;<br>*DestructorLinkPtr = <span class="hljs-literal">nullptr</span>;<br>*RefLinkPtr = <span class="hljs-literal">nullptr</span>;<br>*PostConstructLinkPtr = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>是把之前AddCppProperty添加到UField* Children里的字段们，抽出FProperty们，然后再串成4个链条：</p><ol><li>PropertyLink：所有的属性</li><li>RefLink：包含对象引用（UObject*）的属性，这些属性对GC有影响，所以单独分类出来加速分析。</li><li>PostConstructLink：所有需要从CDO中获取初始值的属性，属性可以从Config文件中或者CDO中获取初始值，因此在序列化后需要初始化一下属性们的值。</li><li>DestructorLink：需要额外析构的属性，在析构的时候，需要去调用一下属性的析构函数。否则的话，如一个int属性，就不用管它，释放内存就可以了。</li></ol><p>单独分类出来这4个链条也是为了在不同的应用场景下加速性能，不需要每次去遍历所有的属性。UFunction本身也是个UStruct，它的Link的之后会调用InitializeDerivedMembers来算一下参数和返回值的信息偏移而已。</p><p><strong>至此，类型系统算是构造完毕。</strong></p><hr><h2 id="UObject（十二）类型系统-总结"><a href="#UObject（十二）类型系统-总结" class="headerlink" title="UObject（十二）类型系统-总结"></a><a href="https://zhuanlan.zhihu.com/p/60291730">UObject（十二）类型系统-总结</a></h2><h3 id="UClass-的构建过程"><a href="#UClass-的构建过程" class="headerlink" title="UClass*的构建过程"></a>UClass*的构建过程</h3><ol><li>内存构造。简单调用了UClass的构造函数。</li><li>注册。通过 <code>DeferredRegister</code>注册，给一个名字，将自己注册在对象系统中。</li><li>对象构造。往对象中填充属性、函数、接口和元数据的信息。</li><li>绑定链接。优化存储结构，为后续的使用提供更高的性能和便利。</li><li>CDO创建。每个UClass都有一个CDO(Class Default Object)，有了CDO，相当于有了一个存档备份和参照。</li><li>引用记号流构建。一个Class是怎么样有可能引用其他别的对象的，这棵引用树怎么样构建的高效，也是GC中一个非常重要的话题。</li></ol><h3 id="UDataMeta"><a href="#UDataMeta" class="headerlink" title="UDataMeta"></a>UDataMeta</h3><p>仅在Editor模式下使用，在所有的类型对象Construct的一步就是AddMetaData。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">if</span> WITH_METADATA <span class="hljs-comment">// UObjectGlobals.cpp</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddMetaData</span><span class="hljs-params">(UObject* Object, <span class="hljs-type">const</span> FMetaDataPairParam* MetaDataArray, int32 NumMetaData)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (NumMetaData)<br>&#123;<br><span class="hljs-comment">// Outer(UPackage)的MetaData</span><br>UMetaData* MetaData = Object-&gt;<span class="hljs-built_in">GetOutermost</span>()-&gt;<span class="hljs-built_in">GetMetaData</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> FMetaDataPairParam* MetaDataParam = MetaDataArray, *MetaDataParamEnd = MetaDataParam + NumMetaData; <br>MetaDataParam != MetaDataParamEnd; ++MetaDataParam)<br>&#123;<br>MetaData-&gt;<span class="hljs-built_in">SetValue</span>(Object, <span class="hljs-built_in">UTF8_TO_TCHAR</span>(MetaDataParam-&gt;NameUTF8), <span class="hljs-built_in">UTF8_TO_TCHAR</span>(MetaDataParam-&gt;ValueUTF8));<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">// Package.cpp</span><br><span class="hljs-function">UMetaData* <span class="hljs-title">UPackage::GetMetaData</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>UMetaData* LocalMetaData = MetaData;<br><span class="hljs-keyword">if</span> (LocalMetaData == <span class="hljs-literal">nullptr</span>)<br>&#123;<br>LocalMetaData = <span class="hljs-built_in">FindObjectFast</span>&lt;UMetaData&gt;(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">FName</span>(NAME_PackageMetaData));<br><br><span class="hljs-keyword">if</span>(LocalMetaData == <span class="hljs-literal">nullptr</span>)<br>&#123;<br>LocalMetaData = <span class="hljs-built_in">NewObject</span>&lt;UMetaData&gt;(<span class="hljs-keyword">this</span>, NAME_PackageMetaData, RF_Standalone | RF_LoadCompleted);<br>&#125;<br><span class="hljs-built_in">SetMetaData</span>(LocalMetaData);<br>&#125;<br><br><span class="hljs-keyword">if</span> (LocalMetaData-&gt;<span class="hljs-built_in">HasAnyFlags</span>(RF_NeedLoad))<br>&#123;<br>FLinkerLoad* MetaDataLinker = LocalMetaData-&gt;<span class="hljs-built_in">GetLinker</span>();<br>MetaDataLinker-&gt;<span class="hljs-built_in">Preload</span>(LocalMetaData);<br>&#125;<br><br><span class="hljs-keyword">return</span> LocalMetaData;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">COREUOBJECT_API</span> UMetaData : <span class="hljs-keyword">public</span> UObject<br>&#123;<br><span class="hljs-keyword">public</span>:<br>TMap&lt; FWeakObjectPtr, TMap&lt;FName, FString&gt; &gt; ObjectMetaDataMap;<br>TMap&lt; FName, FString &gt; RootMetaDataMap;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>UMetaData是属于UPackage关联的，而不是跟某个UField直接绑定</li><li>UMetaData在Runtime是被略过去的</li><li>UMetaData也是个对象</li></ul><h3 id="Flags"><a href="#Flags" class="headerlink" title="Flags"></a>Flags</h3><p>各种Flags的枚举。UE利用这些枚举标志来判断对象的状态和特征。 重要的有：</p><ul><li>EObjectFlags：对象本身的标志。</li><li>EInternalObjectFlags：对象存储的标志，GC的时候用来检查可达性。</li><li>EObjectMark：用来额外标记对象特征的标志，用在序列化过程中标识状态。</li><li>EClassFlags：类的标志，定义了一个类的特征。</li><li>EClassCastFlags：类之间的转换，可以快速的测试一个类是否可以转换成某种类型。</li><li>EStructFlags：结构的特征标志。</li><li>EFunctionFlags：函数的特征标志。</li><li>EPropertyFlags：属性的特征标志。</li></ul><p>具体的请读者们自己去查看定义了，太多了就不一一解释了。这也是一种常用的C++惯用法，枚举标志来表示叠加的特征。</p><h4 id="类型系统类图"><a href="#类型系统类图" class="headerlink" title="类型系统类图"></a>类型系统类图</h4><img src="/2023/05/16/link/UE/UE-C++/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F-%E7%B1%BB%E5%9B%BE.svg" class="" title="结构关系"><h4 id="各个类型的构造"><a href="#各个类型的构造" class="headerlink" title="各个类型的构造"></a>各个类型的构造</h4><img src="/2023/05/16/link/UE/UE-C++/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B.svg" class="" title="类型构造过程"><hr><h2 id="UObject（十三）类型系统-反射实战"><a href="#UObject（十三）类型系统-反射实战" class="headerlink" title="UObject（十三）类型系统-反射实战"></a><a href="https://zhuanlan.zhihu.com/p/61042237">UObject（十三）类型系统-反射实战</a></h2><p>本篇讲一些利用反射的例子。</p><h3 id="获取类型对象"><a href="#获取类型对象" class="headerlink" title="获取类型对象"></a>获取类型对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">TArray&lt;UObject*&gt; Results;<br><span class="hljs-built_in">GetObjectsOfClass</span>(UClass::<span class="hljs-built_in">StaticClass</span>(), Results); <span class="hljs-comment">// 获取所有的Class和Interface</span><br><span class="hljs-built_in">GetObjectsOfClass</span>(UEnum::<span class="hljs-built_in">StaticClass</span>(), Results); <span class="hljs-comment">// 获取所有的enum</span><br><span class="hljs-built_in">GetObjectsOfClass</span>(UScriptStruct::<span class="hljs-built_in">StaticClass</span>(), Results); <span class="hljs-comment">// 获取所有的Struct</span><br></code></pre></td></tr></table></figure><p>如果要精确的根据一个名字来查找某个类型对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">UClass* MyClass = <span class="hljs-built_in">FindObject</span>&lt;UClass&gt;(ANY_PACKAGE, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;MyClass&quot;</span>));<br></code></pre></td></tr></table></figure><h3 id="遍历字段"><a href="#遍历字段" class="headerlink" title="遍历字段"></a>遍历字段</h3><p>使用迭代器 <code>TFieldIterator&lt;T&gt;</code>进行筛选遍历字段。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (TFieldIterator&lt;FProperty&gt; <span class="hljs-built_in">Iter</span>(MyClass); Iter; ++Iter)<br>&#123;<br>FProperty* Property = *Iter;<br><span class="hljs-built_in">LogDebug</span>(<span class="hljs-string">&quot;Property Name:&quot;</span>, Property-&gt;<span class="hljs-built_in">GetName</span>());<br>&#125;<br><span class="hljs-keyword">for</span> (TFieldIterator&lt;UFunction&gt; <span class="hljs-built_in">Iter</span>(MyClass); Iter; ++Iter)<br>&#123;<br>UFunction* Function = *Iter;<br><span class="hljs-built_in">LogDebug</span>(<span class="hljs-string">&quot;Function Name:&quot;</span>, Function-&gt;<span class="hljs-built_in">GetName</span>());<br><span class="hljs-keyword">for</span> (TFieldIterator&lt;FProperty&gt; <span class="hljs-built_in">ParamIter</span>(Function); ParamIter; ++ParamIter)<br>&#123;<br>FProperty* ParamProperty = *ParamIter;<br><span class="hljs-built_in">LogDebug</span>(<span class="hljs-string">&quot;Function Name:&quot;</span>, ParamProperty-&gt;<span class="hljs-built_in">GetName</span>(), ParamProperty-&gt;PropertyFlags);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 接口</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> FImplementedInterface&amp; Interface : MyClass-&gt;Interfaces)<br>&#123;<br>UClass* InterfaceClass = Interface.Class;<br><span class="hljs-built_in">LogDebug</span>(<span class="hljs-string">&quot;InterfaceClass Name:&quot;</span>, InterfaceClass-&gt;<span class="hljs-built_in">GetName</span>());<br>&#125;<br><span class="hljs-comment">// 遍历枚举</span><br>UEnum* MyEnum = <span class="hljs-built_in">FindObject</span>&lt;UEnum&gt;(ANY_PACKAGE, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;EMyEnum&quot;</span>));<br><span class="hljs-keyword">for</span> (int32 Index = <span class="hljs-number">0</span>; Index &lt; MyEnum-&gt;<span class="hljs-built_in">NumEnums</span>(); ++Index)<br>&#123;<br>FName name = MyEnum-&gt;<span class="hljs-built_in">GetNameByIndex</span>(Index);<br><span class="hljs-type">int</span> Val = MyEnum-&gt;<span class="hljs-built_in">GetValueByIndex</span>(Index);<br><span class="hljs-built_in">LogDebug</span>(<span class="hljs-string">&quot;MyEnum Name:&quot;</span>, *(name.<span class="hljs-built_in">ToString</span>()), <span class="hljs-string">&quot;Val:&quot;</span>, Val);<br>&#125;<br><span class="hljs-comment">// 遍历元数据</span><br>UMetaData* MetaData = MyClass-&gt;<span class="hljs-built_in">GetPackage</span>()-&gt;<span class="hljs-built_in">GetMetaData</span>();<br>TMap&lt;FName, FString&gt;* KeyValues = MetaData-&gt;<span class="hljs-built_in">GetMapForObject</span>(MyClass);<br><span class="hljs-keyword">if</span>(KeyValues != <span class="hljs-literal">nullptr</span> &amp;&amp; KeyValues-&gt;<span class="hljs-built_in">Num</span>() &gt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; Pair : *KeyValues)<br>&#123;<br>FName Key = Pair.Key;<br>FString Value = Pair.Value;<br><span class="hljs-built_in">LogDebug</span>(<span class="hljs-string">&quot;MetaData Key:&quot;</span>, Key, <span class="hljs-string">&quot;Values:&quot;</span>, Value);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 查找属性</span><br><span class="hljs-function">FProperty* <span class="hljs-title">UStruct::FindPropertyByName</span><span class="hljs-params">(FName InName)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-comment">// 查找函数</span><br><span class="hljs-function">UFunction* <span class="hljs-title">UClass::FindFunctionByName</span><span class="hljs-params">(FName InName, EIncludeSuperFlag::Type IncludeSuper)</span> <span class="hljs-type">const</span></span>;<br><br></code></pre></td></tr></table></figure><p>注意：<code>FindObject</code>方法的 <code>Name</code>参数，在 <code>UClass</code>和 <code>UInterface</code>时，<code>Name</code>参数是类名去掉前缀 <code>U</code>的。因为 <code>Class</code>和 <code>Interface </code>继承了 <code>UObject</code>，而 <code>UObject::StaticClass</code>调用了 <code>GetPrivateStaticClass</code>，继而调用 <code>GetPrivateStaticClassBody</code>，该方法的Name参数是：<code>(TCHAR*)TEXT(#TClass) + 1 + ((StaticClassFlags &amp; CLASS_Deprecated) ? 11 : 0)</code>，忽略了前缀。而 <code>UScriptStruct</code>、<code>UEnum</code>没有继承 <code>UObject</code>，其名字就是本来的名字。两者的构造机制不同，可参见 <code>UECodeGen_Private::ConstructUEnum</code>和 <code>UECodeGen_Private::ConstructUClass</code></p><h3 id="查看继承"><a href="#查看继承" class="headerlink" title="查看继承"></a>查看继承</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 查看继承</span><br>TArray&lt;FString&gt; ClassNames;<br>ClassNames.<span class="hljs-built_in">Add</span>(MyClass-&gt;<span class="hljs-built_in">GetName</span>());<br>UClass* SuperClass = MyClass-&gt;<span class="hljs-built_in">GetSuperClass</span>();<br><span class="hljs-keyword">while</span>(SuperClass)<br>&#123;<br>ClassNames.<span class="hljs-built_in">Add</span>(SuperClass-&gt;<span class="hljs-built_in">GetName</span>());<br>SuperClass = SuperClass-&gt;<span class="hljs-built_in">GetSuperClass</span>();<br>&#125;<br><span class="hljs-built_in">LogDebug</span>(<span class="hljs-string">&quot;UMyClass Inherit:&quot;</span>, *FString::<span class="hljs-built_in">Join</span>(ClassNames, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;-&gt;&quot;</span>)));<br><br><span class="hljs-comment">// 获得子类</span><br>TArray&lt;UClass*&gt; Result;<br><span class="hljs-built_in">GetDerivedClasses</span>(MyClass, Result, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">for</span>(UClass* Class : Result)<br>&#123;<br><span class="hljs-built_in">LogDebug</span>(<span class="hljs-string">&quot;UMyInterface Derived:&quot;</span>, Class-&gt;<span class="hljs-built_in">GetName</span>());<br>&#125;<br><br>输出：<br>UMyClass Inherit: MyClass-&gt;Object <br>UMyInterface Derived: MySubClass <br></code></pre></td></tr></table></figure><h3 id="获取设置属性值"><a href="#获取设置属性值" class="headerlink" title="获取设置属性值"></a>获取设置属性值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">UCLASS</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UOBJECTLEARN_API</span> UTestClass : <span class="hljs-keyword">public</span> UObject<br>&#123;<br><span class="hljs-built_in">GENERATED_BODY</span>()<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">UPROPERTY</span>()<br><span class="hljs-type">int</span> Num = <span class="hljs-number">1</span>;<br>&#125;;<br><span class="hljs-built_in">UCLASS</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UOBJECTLEARN_API</span> UMySubClass : <span class="hljs-keyword">public</span> UMyClass<br>&#123;<br><span class="hljs-built_in">GENERATED_BODY</span>()<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">UFUNCTION</span>()<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-literal">nullptr</span> == TestClass) TestClass = <span class="hljs-built_in">NewObject</span>&lt;UTestClass&gt;();<br>&#125;<br><br><span class="hljs-built_in">UPROPERTY</span>()<br><span class="hljs-type">int</span> Member;<br><br><span class="hljs-built_in">UPROPERTY</span>()<br>FMyStruct MyStruct;<br><br><span class="hljs-built_in">UPROPERTY</span>()<br>UTestClass* TestClass;<br>&#125;;<br><br><br>FMyStruct MyStructObj;<br>MyStructObj.Score = <span class="hljs-number">12321.f</span>;<br><span class="hljs-keyword">for</span> (TFieldIterator&lt;FProperty&gt; <span class="hljs-built_in">It</span>(MyStructObj.<span class="hljs-built_in">StaticStruct</span>()); It; ++It)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;Score&quot;</span> == It-&gt;<span class="hljs-built_in">GetName</span>())<br>&#123;<br>FFloatProperty* ScoreValue = <span class="hljs-built_in">Cast</span>&lt;FFloatProperty&gt;(*It);<br><span class="hljs-keyword">if</span> (ScoreValue)<br>&#123;<br><span class="hljs-type">void</span>* Param = ScoreValue-&gt;<span class="hljs-built_in">ContainerPtrToValuePtr</span>&lt;<span class="hljs-type">void</span>*&gt;(&amp;MyStructObj);<br><span class="hljs-type">float</span> GetVal = ScoreValue-&gt;<span class="hljs-built_in">GetPropertyValue</span>(Param);<br><span class="hljs-built_in">LogDebug</span>(<span class="hljs-string">&quot;Get Perporty Score:&quot;</span>, GetVal);<br>ScoreValue-&gt;<span class="hljs-built_in">SetPropertyValue</span>(Param, <span class="hljs-number">111.f</span>);<br><span class="hljs-built_in">LogDebug</span>(<span class="hljs-string">&quot;Set Perporty Score:&quot;</span>, MyStructObj.Score);<br><br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;Str&quot;</span> == It-&gt;<span class="hljs-built_in">GetName</span>())<br>&#123;<br>FStrProperty* StrValue = <span class="hljs-built_in">Cast</span>&lt;FStrProperty&gt;(*It);<br><span class="hljs-keyword">if</span> (StrValue)<br>&#123;<br><span class="hljs-keyword">auto</span>* Param = StrValue-&gt;<span class="hljs-built_in">ContainerPtrToValuePtr</span>&lt;<span class="hljs-type">void</span>*&gt;(&amp;MyStructObj);<br>StrValue-&gt;<span class="hljs-built_in">ImportText</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;赋值&quot;</span>), Param, EPropertyFlags::CPF_None, <span class="hljs-literal">nullptr</span>);<br>FString StrTemp;<br>StrValue-&gt;<span class="hljs-built_in">ExportTextItem</span>(StrTemp, Param,<span class="hljs-literal">nullptr</span>,<span class="hljs-literal">nullptr</span>, EPropertyPortFlags::PPF_None, <span class="hljs-literal">nullptr</span>);<br><span class="hljs-built_in">LogDebug</span>(<span class="hljs-string">&quot;Get Perporty Str:&quot;</span>, MyStructObj.Str);<br>&#125;<br>&#125;<br>&#125;<br>UMySubClass* MySubClass = <span class="hljs-built_in">NewObject</span>&lt;UMySubClass&gt;();<br><span class="hljs-keyword">if</span>(FIntProperty* MemberProperty = <span class="hljs-built_in">Cast</span>&lt;FIntProperty&gt;(MySubClass-&gt;<span class="hljs-built_in">GetClass</span>()-&gt;<span class="hljs-built_in">FindPropertyByName</span>(<span class="hljs-string">&quot;Member&quot;</span>)))<br>&#123;<br><span class="hljs-keyword">auto</span> *MySubClassParam = MemberProperty-&gt;<span class="hljs-built_in">ContainerPtrToValuePtr</span>&lt;UMySubClass&gt;(MySubClass);<br>MemberProperty-&gt;<span class="hljs-built_in">SetPropertyValue</span>(MySubClassParam, <span class="hljs-number">123</span>);<br><span class="hljs-type">int</span> MemberPropertyVal = MemberProperty-&gt;<span class="hljs-built_in">GetPropertyValue</span>(MySubClassParam);<br><span class="hljs-built_in">LogDebug</span>(<span class="hljs-string">&quot;Member Property:&quot;</span>, MemberPropertyVal);<br>&#125;<br><span class="hljs-keyword">if</span>(FStructProperty* StructProperty = <span class="hljs-built_in">Cast</span>&lt;FStructProperty&gt;(MySubClass-&gt;<span class="hljs-built_in">GetClass</span>()-&gt;<span class="hljs-built_in">FindPropertyByName</span>(<span class="hljs-string">&quot;MyStruct&quot;</span>)))<br>&#123;<br>UScriptStruct* Struct = StructProperty-&gt;Struct;<br><span class="hljs-keyword">for</span>(TFieldIterator&lt;FProperty&gt; <span class="hljs-built_in">It</span>(Struct); It; ++It)<br>&#123;<br><span class="hljs-built_in">LogDebug</span>(<span class="hljs-string">&quot;MyStruct : Property name:&quot;</span>, Struct-&gt;<span class="hljs-built_in">GetName</span>());<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(FObjectProperty* ObjectProperty = <span class="hljs-built_in">Cast</span>&lt;FObjectProperty&gt;(MySubClass-&gt;<span class="hljs-built_in">GetClass</span>()-&gt;<span class="hljs-built_in">FindPropertyByName</span>(<span class="hljs-string">&quot;TestClass&quot;</span>)))<br>&#123;<br><span class="hljs-keyword">for</span> (TFieldIterator&lt;FProperty&gt; <span class="hljs-built_in">It</span>(UTestClass::<span class="hljs-built_in">StaticClass</span>()); It; ++It)<br>&#123;<br><span class="hljs-built_in">LogDebug</span>(<span class="hljs-string">&quot;MySubClass : Property:&quot;</span>, It-&gt;<span class="hljs-built_in">GetName</span>());<br>&#125;<br>&#125;<br><br>输出：<br>Get Perporty Score: <span class="hljs-number">12321</span> <br>Set Perporty Score: <span class="hljs-number">111</span> <br>Get Perporty Str: 赋值 <br>Member Property: <span class="hljs-number">123</span> <br>object Property: MyStruct <br>MySubClass : Property: Num<br></code></pre></td></tr></table></figure><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 调用函数</span><br>FName CallFunctionName = <span class="hljs-string">&quot;Func&quot;</span>;<br><span class="hljs-type">float</span> CallFunctionParam1 = <span class="hljs-number">123.456</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Class_Func_Params</span><br>&#123;<br><span class="hljs-type">float</span> param1;<br>int32 ReturnValue;<br>&#125;;<br>UObject* Obj = <span class="hljs-built_in">NewObject</span>&lt;UMyClass&gt;();<br>UFunction* Function = Obj-&gt;<span class="hljs-built_in">FindFunctionChecked</span>(CallFunctionName);<br>Class_Func_Params FuncParams;<br>FuncParams.param1 = <span class="hljs-number">123.456</span>;<br>Obj-&gt;<span class="hljs-built_in">ProcessEvent</span>(Function, &amp;FuncParams);<br><span class="hljs-built_in">LogDebug</span>(<span class="hljs-string">&quot;Call UMyClass Func, result:&quot;</span>, FuncParams.ReturnValue);<br><br>输出：<br>Call UMyClass Func, result: <span class="hljs-number">123</span> <br></code></pre></td></tr></table></figure><hr><h2 id="TheEnd"><a href="#TheEnd" class="headerlink" title="TheEnd"></a>TheEnd</h2><h3 id="一些名词的解释"><a href="#一些名词的解释" class="headerlink" title="一些名词的解释"></a>一些名词的解释</h3><ul><li>ClassPrivate<br>对象的 UClass 类型</li><li>NamePrivate<br>对象名，也是全局唯一</li><li>UClass::GetClass()、UClass::StaticClass()、ClassDefaultObject<br><a href="https://blog.csdn.net/j756915370/article/details/117913118">一文搞懂StaticClass、GetClass和ClassDefaultObject_ue4 staticclass_水曜日鸡的博客-CSDN博客</a></li><li>Outer<br>所有的Object都拥有一个Outer，称之为父对象。使UObject建立父子及的关系，便于GC。</li><li>OuterPrivate<br>对象所属的 Outer 对象，即对象所在的 UPackage</li></ul><h3 id="其他的参考资料"><a href="#其他的参考资料" class="headerlink" title="其他的参考资料"></a>其他的参考资料</h3><p><a href="https://zhuanlan.zhihu.com/p/414454390">UE4 反射 - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/wellbye/p/5808894.html">ue4 NewObject&#x2F;StaticConstructObject_Internal&#x2F;StaticAllocateObject&#x2F;FObjectInitializer：对象创建和初始化 - 冷欺花 - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>UE</category>
      
      <category>UE-C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE</tag>
      
      <tag>UE-C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
